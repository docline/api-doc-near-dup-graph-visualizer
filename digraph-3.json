{
  "digraph": [
    {
      "vertexName": "Method public SortedDocValues select(final SortedSetDocValues values, final BitSet parentDocs, final DocIdSetIterator childDocs, int maxChildren) throws IOException  (MultiValueMode.java)",
      "children": [
        {
          "name": "Method public BinaryDocValues select(final SortedBinaryDocValues values, final BytesRef missingValue)  (MultiValueMode.java)"
        }
      ],
      "comment": "\n     * Return a {@link SortedDocValues} instance that can be used to sort root documents\n     * with this mode, the provided values and filters for root/inner documents.\n     *\n     * For every root document, the values of its inner documents will be aggregated.\n     *\n     * Allowed Modes: MIN, MAX\n     *\n     * NOTE: Calling the returned instance on docs that are not root docs is illegal\n     *       The returned instance can only be evaluate the current and upcoming docs\n     ",
      "vertexLabel": "SortedDocValues select()"
    },
    {
      "vertexName": "Method public String[] ignoreIndexSettings()  (RestoreSnapshotRequest.java)",
      "children": [
        {
          "name": "Method public RestoreSnapshotRequest ignoreIndexSettings(List<String> ignoreIndexSettings)  (RestoreSnapshotRequest.java)"
        }
      ],
      "comment": "\n     * Returns the list of index settings and index settings groups that shouldn't be restored from snapshot\n     ",
      "vertexLabel": "String[] ignoreIndexSettings()"
    },
    {
      "vertexName": "Method public Map<String, Object> getErrorAsMap()  (TaskResult.java)",
      "children": [
        {
          "name": "Method public BytesReference getError()  (TaskResult.java)"
        }
      ],
      "comment": "\n     * Convert {@link #getError()} from XContent to a Map for easy processing. Will return an empty map if the task didn't finish with an\n     * error, hasn't yet finished, or didn't store its result.\n     ",
      "vertexLabel": "Map<String, Object> getErrorAsMap()"
    },
    {
      "vertexName": "Method public ClusterHealthRequest waitForNodes(String waitForNodes)  (ClusterHealthRequest.java)",
      "comment": "\n     * Waits for N number of nodes. Use \"12\" for exact mapping, \"&gt;12\" and \"&lt;12\" for range.\n     ",
      "vertexLabel": "ClusterHealthRequest waitForNodes()"
    },
    {
      "vertexName": "Method public static BucketOrder aggregation(String path, String metricName, boolean asc)  (BucketOrder.java)",
      "children": [
        {
          "name": "Method public static BucketOrder aggregation(String path, boolean asc)  (BucketOrder.java)"
        }
      ],
      "comment": "\n     * Creates a bucket ordering strategy which sorts buckets based on a metric from a multi-valued sub-aggregation.\n     *\n     * @param path       path to the sub-aggregation to sort on.\n     * @param metricName name of the value of the multi-value metric to sort on.\n     * @param asc        direction to sort by: {@code true} for ascending, {@code false} for descending.\n     * @see AggregationPath\n     ",
      "vertexLabel": "BucketOrder aggregation()"
    },
    {
      "vertexName": "Method public RestoreSnapshotRequestBuilder setIndexSettings(String source, XContentType xContentType)  (RestoreSnapshotRequestBuilder.java)",
      "children": [
        {
          "name": "Method public RestoreSnapshotRequestBuilder setIndexSettings(Map<String, Object> source)  (RestoreSnapshotRequestBuilder.java)"
        }
      ],
      "comment": "\n     * Sets index settings that should be added or replaced during restore\n     *\n     * @param source index settings\n     * @param xContentType the content type of the source\n     * @return this builder\n     ",
      "vertexLabel": "RestoreSnapshotRequestBuilder setIndexSettings()"
    },
    {
      "vertexName": "Method private int seqNoToBitSetOffset(final long seqNo)  (LocalCheckpointTracker.java)",
      "children": [
        {
          "name": "Method private long getBitSetKey(final long seqNo)  (LocalCheckpointTracker.java)"
        }
      ],
      "comment": "\n     * Obtain the position in the bit set corresponding to the provided sequence number. The bit set corresponding to the sequence number\n     * can be obtained via {@link #getBitSetForSeqNo(long)}.\n     *\n     * @param seqNo the sequence number to obtain the position for\n     * @return the position in the bit set corresponding to the provided sequence number\n     ",
      "vertexLabel": "int seqNoToBitSetOffset()"
    },
    {
      "vertexName": "Method public BulkRequestBuilder setWaitForActiveShards(final int waitForActiveShards)  (BulkRequestBuilder.java)",
      "children": [
        {
          "name": "Method public ResizeRequestBuilder setWaitForActiveShards(final int waitForActiveShards)  (ResizeRequestBuilder.java)"
        }
      ],
      "comment": "\n     * A shortcut for {@link #setWaitForActiveShards(ActiveShardCount)} where the numerical\n     * shard count is passed in, instead of having to first call {@link ActiveShardCount#from(int)}\n     * to get the ActiveShardCount.\n     ",
      "vertexLabel": "BulkRequestBuilder setWaitForActiveShards()"
    },
    {
      "vertexName": "Method public Self setSize(int size)  (AbstractBulkByScrollRequest.java)",
      "children": [
        {
          "name": "Field size  (AbstractBulkByScrollRequest.java)"
        }
      ],
      "comment": "\n     * Maximum number of processed documents. Defaults to -1 meaning process all\n     * documents.\n     ",
      "vertexLabel": "Self setSize()"
    },
    {
      "vertexName": "Method public TermSuggestionBuilder minDocFreq(float minDocFreq)  (TermSuggestionBuilder.java)",
      "comment": "\n     * Sets a minimal threshold in number of documents a suggested term should\n     * appear in. This can be specified as an absolute number or as a relative\n     * percentage of number of documents. This can improve quality by only\n     * suggesting high frequency terms. Defaults to 0f and is not enabled. If a\n     * value higher than 1 is specified then the number cannot be fractional.\n     ",
      "vertexLabel": "TermSuggestionBuilder minDocFreq()"
    },
    {
      "vertexName": "Method public SearchSourceBuilder scriptField(String name, Script script, boolean ignoreFailure)  (SearchSourceBuilder.java)",
      "children": [
        {
          "name": "Method public TopHitsAggregationBuilder scriptField(String name, Script script)  (TopHitsAggregationBuilder.java)"
        }
      ],
      "comment": "\n     * Adds a script field under the given name with the provided script.\n     *\n     * @param name\n     *            The name of the field\n     * @param script\n     *            The script\n     ",
      "vertexLabel": "SearchSourceBuilder scriptField()"
    },
    {
      "vertexName": "Method public CoordinatesBuilder close()  (CoordinatesBuilder.java)",
      "children": [
        {
          "name": "Method public LineStringBuilder close()  (LineStringBuilder.java)"
        }
      ],
      "comment": "\n     * Makes a closed ring out of the current coordinates by adding the starting point as the end point.\n     * Will have no effect of starting and end point are already the same coordinate.\n     ",
      "vertexLabel": "CoordinatesBuilder close()"
    },
    {
      "vertexName": "Method public PutMappingRequestBuilder setSource(Object... source)  (PutMappingRequestBuilder.java)",
      "children": [
        {
          "name": "Method public CreateIndexRequest mapping(String type, Object... source)  (CreateIndexRequest.java)"
        }
      ],
      "comment": "\n     * A specialized simplified mapping source method, takes the form of simple properties definition:\n     * (\"field1\", \"type=string,store=true\").\n     ",
      "vertexLabel": "PutMappingRequestBuilder setSource()"
    },
    {
      "vertexName": "Method public CreateSnapshotRequest settings(Settings settings)  (CreateSnapshotRequest.java)",
      "comment": "\n     * Sets repository-specific snapshot settings.\n     * <p>\n     * See repository documentation for more information.\n     *\n     * @param settings repository-specific snapshot settings\n     * @return this request\n     ",
      "vertexLabel": "CreateSnapshotRequest settings()"
    },
    {
      "vertexName": "Method ActionFuture<NodesInfoResponse> nodesInfo(NodesInfoRequest request)  (ClusterAdminClient.java)",
      "comment": "\n     * Nodes info of the cluster.\n     *\n     * @param request The nodes info request\n     * @return The result future\n     * @see org.elasticsearch.client.Requests#nodesInfoRequest(String...)\n     ",
      "vertexLabel": "ActionFuture<NodesInfoResponse> nodesInfo()"
    },
    {
      "vertexName": "Method public RequestBuilder setWaitForActiveShards(final int waitForActiveShards)  (ReplicationRequestBuilder.java)",
      "children": [
        {
          "name": "Method public ResizeRequestBuilder setWaitForActiveShards(final int waitForActiveShards)  (ResizeRequestBuilder.java)"
        }
      ],
      "comment": "\n     * A shortcut for {@link #setWaitForActiveShards(ActiveShardCount)} where the numerical\n     * shard count is passed in, instead of having to first call {@link ActiveShardCount#from(int)}\n     * to get the ActiveShardCount.\n     ",
      "vertexLabel": "RequestBuilder setWaitForActiveShards()"
    },
    {
      "vertexName": "Method public RestoreSnapshotRequest ignoreIndexSettings(String... ignoreIndexSettings)  (RestoreSnapshotRequest.java)",
      "comment": "\n     * Sets the list of index settings and index settings groups that shouldn't be restored from snapshot\n     ",
      "vertexLabel": "RestoreSnapshotRequest ignoreIndexSettings()"
    },
    {
      "vertexName": "Class FileBasedUnicastHostsProvider  (FileBasedUnicastHostsProvider.java)",
      "children": [
        {
          "name": "Class SettingsBasedHostsProvider  (SettingsBasedHostsProvider.java)"
        }
      ],
      "comment": "\n * An implementation of {@link UnicastHostsProvider} that reads hosts/ports\n * from {@link #UNICAST_HOSTS_FILE}.\n *\n * Each unicast host/port that is part of the discovery process must be listed on\n * a separate line.  If the port is left off an entry, a default port of 9300 is\n * assumed.  An example unicast hosts file could read:\n *\n * 67.81.244.10\n * 67.81.244.11:9305\n * 67.81.244.15:9400\n ",
      "vertexLabel": "Class FileBasedUnicastHostsProvider"
    },
    {
      "vertexName": "Method public Function<String, Predicate<String>> getFieldFilter()  (MapperRegistry.java)",
      "children": [
        {
          "name": "Field NOOP_FIELD_FILTER  (MapperPlugin.java)"
        },
        {
          "name": "Method Function<String, Predicate<String>> getFieldFilter()  (MapperPlugin.java)"
        }
      ],
      "comment": "\n     * Returns a function that given an index name, returns a predicate that fields must match in order to be returned by get mappings,\n     * get index, get field mappings and field capabilities API. Useful to filter the fields that such API return.\n     * The predicate receives the field name as input arguments. In case multiple plugins register a field filter through\n     * {@link MapperPlugin#getFieldFilter()}, only fields that match all the registered filters will be returned by get mappings,\n     * get index, get field mappings and field capabilities API.\n     ",
      "vertexLabel": "Function<String, Predicate<String>> getFieldFilter()"
    },
    {
      "vertexName": "Method public Self setMaxRetries(int maxRetries)  (AbstractBulkByScrollRequest.java)",
      "children": [
        {
          "name": "Field maxRetries  (AbstractBulkByScrollRequest.java)"
        }
      ],
      "comment": "\n     * Set the total number of retries attempted for rejections. There is no way to ask for unlimited retries.\n     ",
      "vertexLabel": "Self setMaxRetries()"
    },
    {
      "vertexName": "Class BulkProcessor  (BulkProcessor.java)",
      "children": [
        {
          "name": "Method public Builder setBulkActions(int bulkActions)  (BulkProcessor.java)"
        }
      ],
      "comment": "\n * A bulk processor is a thread safe bulk processing class, allowing to easily set when to \"flush\" a new bulk request\n * (either based on number of actions, based on the size, or time), and to easily control the number of concurrent bulk\n * requests allowed to be executed in parallel.\n * <p>\n * In order to create a new bulk processor, use the {@link Builder}.\n ",
      "vertexLabel": "Class BulkProcessor"
    },
    {
      "vertexName": "Method void delete(DeleteIndexRequest request, ActionListener<AcknowledgedResponse> listener)  (IndicesAdminClient.java)",
      "children": [
        {
          "name": "Method void close(CloseIndexRequest request, ActionListener<AcknowledgedResponse> listener)  (IndicesAdminClient.java)"
        },
        {
          "name": "Method ActionFuture<AcknowledgedResponse> delete(DeleteIndexRequest request)  (IndicesAdminClient.java)"
        },
        {
          "name": "Method void delete(DeleteRequest request, ActionListener<DeleteResponse> listener)  (Client.java)"
        }
      ],
      "comment": "\n     * Deletes an index based on the index name.\n     *\n     * @param request  The delete index request\n     * @param listener A listener to be notified with a result\n     * @see org.elasticsearch.client.Requests#deleteIndexRequest(String)\n     ",
      "vertexLabel": "void delete()"
    },
    {
      "vertexName": "Method public static TermsQueryBuilder termsQuery(String name, float... values)  (QueryBuilders.java)",
      "children": [
        {
          "name": "Method public static TermsQueryBuilder termsQuery(String name, String... values)  (QueryBuilders.java)"
        }
      ],
      "comment": "\n     * A filer for a field based on several terms matching on any of them.\n     *\n     * @param name   The field name\n     * @param values The terms\n     ",
      "vertexLabel": "TermsQueryBuilder termsQuery()"
    },
    {
      "vertexName": "Method public OpenIndexRequest indicesOptions(IndicesOptions indicesOptions)  (OpenIndexRequest.java)",
      "children": [
        {
          "name": "Method public RestoreSnapshotRequest indicesOptions(IndicesOptions indicesOptions)  (RestoreSnapshotRequest.java)"
        }
      ],
      "comment": "\n     * Specifies what type of requested indices to ignore and how to deal with wildcard expressions.\n     * For example indices that don't exist.\n     *\n     * @param indicesOptions the desired behaviour regarding indices to ignore and wildcard indices expressions\n     * @return the request itself\n     ",
      "vertexLabel": "OpenIndexRequest indicesOptions()"
    },
    {
      "vertexName": "Method public Self setSlices(int slices)  (AbstractBulkByScrollRequestBuilder.java)",
      "children": [
        {
          "name": "Field slices  (AbstractBulkByScrollRequest.java)"
        }
      ],
      "comment": "\n     * The number of slices this task should be divided into. Defaults to 1 meaning the task isn't sliced into subtasks.\n     ",
      "vertexLabel": "Self setSlices()"
    },
    {
      "vertexName": "Method public List<String> getAsList(String key) throws SettingsException  (Settings.java)",
      "comment": "\n     * The values associated with a setting key as an immutable list.\n     * <p>\n     * It will also automatically load a comma separated list under the settingPrefix and merge with\n     * the numbered format.\n     *\n     * @param key The setting key to load the list by\n     * @return The setting list values\n     ",
      "vertexLabel": "List<String> getAsList()"
    },
    {
      "vertexName": "Method public DateRangeAggregationBuilder addRange(String key, double from, double to)  (DateRangeAggregationBuilder.java)",
      "children": [
        {
          "name": "Method public DateRangeAggregationBuilder addRange(String key, String from, String to)  (DateRangeAggregationBuilder.java)"
        }
      ],
      "comment": "\n     * Add a new range to this aggregation.\n     *\n     * @param key\n     *            the key to use for this range in the response\n     * @param from\n     *            the lower bound on the dates, inclusive\n     * @param to\n     *            the upper bound on the dates, exclusive\n     ",
      "vertexLabel": "DateRangeAggregationBuilder addRange()"
    },
    {
      "vertexName": "Method public ClusterState reroute(ClusterState clusterState, String reason)  (AllocationService.java)",
      "comment": "\n     * Reroutes the routing table based on the live nodes.\n     * <p>\n     * If the same instance of ClusterState is returned, then no change has been made.\n     ",
      "vertexLabel": "ClusterState reroute()"
    },
    {
      "vertexName": "Method public SortedDocValues select(final SortedSetDocValues values)  (MultiValueMode.java)",
      "comment": "\n     * Return a {@link SortedDocValues} instance that can be used to sort documents\n     * with this mode and the provided values.\n     *\n     * Allowed Modes: MIN, MAX\n     ",
      "vertexLabel": "SortedDocValues select()"
    },
    {
      "vertexName": "Method public void removeField(TemplateScript.Factory fieldPathTemplate)  (IngestDocument.java)",
      "children": [
        {
          "name": "Method public void removeField(String path)  (IngestDocument.java)"
        }
      ],
      "comment": "\n     * Removes the field identified by the provided path.\n     * @param fieldPathTemplate Resolves to the path with dot-notation within the document\n     * @throws IllegalArgumentException if the path is null, empty, invalid or if the field doesn't exist.\n     ",
      "vertexLabel": "void removeField()"
    },
    {
      "vertexName": "Method public void writeVInt(int i) throws IOException  (StreamOutput.java)",
      "comment": "\n     * Writes an int in a variable-length format.  Writes between one and\n     * five bytes.  Smaller values take fewer bytes.  Negative numbers\n     * will always use all 5 bytes and are therefore better serialized\n     * using {@link #writeInt}\n     ",
      "vertexLabel": "void writeVInt()"
    },
    {
      "vertexName": "Method public ClusterHealthRequestBuilder setWaitForNoInitializingShards(boolean waitForNoInitializingShards)  (ClusterHealthRequestBuilder.java)",
      "children": [
        {
          "name": "Method public ClusterHealthRequest waitForNoInitializingShards(boolean waitForNoInitializingShards)  (ClusterHealthRequest.java)"
        }
      ],
      "comment": "\n     * Sets whether the request should wait for there to be no initializing shards before\n     * retrieving the cluster health status.  Defaults to <code>false</code>, meaning the\n     * operation does not wait on there being no more initializing shards.  Set to <code>true</code>\n     * to wait until the number of initializing shards in the cluster is 0.\n     ",
      "vertexLabel": "ClusterHealthRequestBuilder setWaitForNoInitializingShards()"
    },
    {
      "vertexName": "Method public static double ewma(double[] values, double alpha)  (MovingFunctions.java)",
      "children": [
        {
          "name": "Method public static double linearWeightedAvg(double[] values)  (MovingFunctions.java)"
        },
        {
          "name": "Method public EWMAModelBuilder alpha(double alpha)  (EwmaModel.java)"
        }
      ],
      "comment": "\n     *\n     * Calculate a exponentially weighted moving average.\n     *\n     * Alpha controls the smoothing of the data.  Alpha = 1 retains no memory of past values\n     * (e.g. a random walk), while alpha = 0 retains infinite memory of past values (e.g.\n     * the series mean).  Useful values are somewhere in between.  Defaults to 0.5.\n     *\n     * Only finite values are averaged.  NaN or null are ignored.\n     * If all values are missing/null/NaN, the return value will be NaN\n     * The average is based on the count of non-null, non-NaN values.\n     *\n     * @param alpha A double between 0-1 inclusive, controls data smoothing\n     ",
      "vertexLabel": "double ewma()"
    },
    {
      "vertexName": "Method public Index[] concreteIndices(ClusterState state, IndicesOptions options, String... indexExpressions)  (IndexNameExpressionResolver.java)",
      "children": [
        {
          "name": "Method public String[] concreteIndexNames(ClusterState state, IndicesOptions options, String... indexExpressions)  (IndexNameExpressionResolver.java)"
        }
      ],
      "comment": "\n     * Translates the provided index expression into actual concrete indices, properly deduplicated.\n     *\n     * @param state             the cluster state containing all the data to resolve to expressions to concrete indices\n     * @param options           defines how the aliases or indices need to be resolved to concrete indices\n     * @param indexExpressions  expressions that can be resolved to alias or index names.\n     * @return the resolved concrete indices based on the cluster state, indices options and index expressions\n     * @throws IndexNotFoundException if one of the index expressions is pointing to a missing index or alias and the\n     * provided indices options in the context don't allow such a case, or if the final result of the indices resolution\n     * contains no indices and the indices options in the context don't allow such a case.\n     * @throws IllegalArgumentException if one of the aliases resolve to multiple indices and the provided\n     * indices options in the context don't allow such a case.\n     ",
      "vertexLabel": "Index[] concreteIndices()"
    },
    {
      "vertexName": "Method public final void validate(final Settings settings, final boolean validateDependencies, final boolean ignorePrivateSettings, final boolean ignoreArchivedSettings, final boolean validateInternalOrPrivateIndex)  (AbstractScopedSettings.java)",
      "children": [
        {
          "name": "Method public final void validate(final Settings settings, final boolean validateDependencies, final boolean ignorePrivateSettings, final boolean ignoreArchivedSettings)  (AbstractScopedSettings.java)"
        }
      ],
      "comment": "\n     * Validates that all settings are registered and valid.\n     *\n     * @param settings                       the settings\n     * @param validateDependencies           true if dependent settings should be validated\n     * @param ignorePrivateSettings          true if private settings should be ignored during validation\n     * @param ignoreArchivedSettings         true if archived settings should be ignored during validation\n     * @param validateInternalOrPrivateIndex true if index internal settings should be validated\n     * @see Setting#getSettingsDependencies(String)\n     ",
      "vertexLabel": "final void validate()"
    },
    {
      "vertexName": "Method public DateHistogramAggregationBuilder dateHistogramInterval(DateHistogramInterval dateHistogramInterval)  (DateHistogramAggregationBuilder.java)",
      "children": [
        {
          "name": "Method public DateHistogramAggregationBuilder interval(long interval)  (DateHistogramAggregationBuilder.java)"
        }
      ],
      "comment": " Set the interval on this builder, and return the builder so that calls can be chained.\n     *  If both {@link #interval()} and {@link #dateHistogramInterval()} are set, then the\n     *  {@link #dateHistogramInterval()} wins. ",
      "vertexLabel": "DateHistogramAggregationBuilder dateHistogramInterval()"
    },
    {
      "vertexName": "Method public String toString()  (StopWatch.java)",
      "children": [
        {
          "name": "Method public String prettyPrint()  (StopWatch.java)"
        }
      ],
      "comment": "\n     * Return an informative string describing all tasks performed\n     * For custom reporting, call <code>getTaskInfo()</code> and use the task info directly.\n     ",
      "vertexLabel": "String toString()"
    },
    {
      "vertexName": "Method public DirectCandidateGeneratorBuilder accuracy(float accuracy)  (DirectCandidateGeneratorBuilder.java)",
      "children": [
        {
          "name": "Method public TermSuggestionBuilder accuracy(float accuracy)  (TermSuggestionBuilder.java)"
        }
      ],
      "comment": "\n     * Sets how similar the suggested terms at least need to be compared to\n     * the original suggest text tokens. A value between 0 and 1 can be\n     * specified. This value will be compared to the string distance result\n     * of each candidate spelling correction.\n     * <p>\n     * Default is {@code 0.5}\n     ",
      "vertexLabel": "DirectCandidateGeneratorBuilder accuracy()"
    },
    {
      "vertexName": "Method public Builder setBulkActions(int bulkActions)  (BulkProcessor.java)",
      "children": [
        {
          "name": "Method public Builder setBulkSize(ByteSizeValue bulkSize)  (BulkProcessor.java)"
        }
      ],
      "comment": "\n         * Sets when to flush a new bulk request based on the number of actions currently added. Defaults to\n         * {@code 1000}. Can be set to {@code -1} to disable it.\n         ",
      "vertexLabel": "Builder setBulkActions()"
    },
    {
      "vertexName": "Method public ObjectLongMap<String> getInSyncGlobalCheckpoints()  (IndexShard.java)",
      "children": [
        {
          "name": "Method public synchronized ObjectLongMap<String> getInSyncGlobalCheckpoints()  (ReplicationTracker.java)"
        }
      ],
      "comment": "\n     * Get the local knowledge of the global checkpoints for all in-sync allocation IDs.\n     *\n     * @return a map from allocation ID to the local knowledge of the global checkpoint for that allocation ID\n     ",
      "vertexLabel": "ObjectLongMap<String> getInSyncGlobalCheckpoints()"
    },
    {
      "vertexName": "Method public boolean addAll(Collection<? extends T> c)  (EvictingQueue.java)",
      "children": [
        {
          "name": "Method public boolean add(T t)  (EvictingQueue.java)"
        }
      ],
      "comment": "\n     * Add the given elements to the queue, possibly forcing evictions from the head if {@link #remainingCapacity()} is\n     * zero or becomes zero during the execution of this method.\n     *\n     * @param c the collection of elements to add\n     * @return true if any elements were added to the queue\n     ",
      "vertexLabel": "boolean addAll()"
    },
    {
      "vertexName": "Method public void asyncBlockOperations(final ActionListener<Releasable> onAcquired, final long timeout, final TimeUnit timeUnit)  (IndexShardOperationPermits.java)",
      "comment": "\n     * Immediately delays operations and on another thread waits for in-flight operations to finish and then acquires all permits. When all\n     * permits are acquired, the provided {@link ActionListener} is called under the guarantee that no new operations are started. Delayed\n     * operations are run once the {@link Releasable} is released or if a failure occurs while acquiring all permits; in this case the\n     * {@code onFailure} handler will be invoked after delayed operations are released.\n     *\n     * @param onAcquired {@link ActionListener} that is invoked once acquisition is successful or failed\n     * @param timeout    the maximum time to wait for the in-flight operations block\n     * @param timeUnit   the time unit of the {@code timeout} argument\n     ",
      "vertexLabel": "void asyncBlockOperations()"
    },
    {
      "vertexName": "Method public void setFieldValue(TemplateScript.Factory fieldPathTemplate, ValueSource valueSource)  (IngestDocument.java)",
      "comment": "\n     * Sets the provided value to the provided path in the document.\n     * Any non existing path element will be created. If the last element is a list,\n     * the value will replace the existing list.\n     * @param fieldPathTemplate Resolves to the path with dot-notation within the document\n     * @param valueSource The value source that will produce the value to put in for the path key\n     * @throws IllegalArgumentException if the path is null, empty, invalid or if the value cannot be set to the\n     * item identified by the provided path.\n     ",
      "vertexLabel": "void setFieldValue()"
    },
    {
      "vertexName": "Method public ClusterInfo(ImmutableOpenMap<String, DiskUsage> leastAvailableSpaceUsage, ImmutableOpenMap<String, DiskUsage> mostAvailableSpaceUsage, ImmutableOpenMap<String, Long> shardSizes, ImmutableOpenMap<ShardRouting, String> routingToDataPath)  (ClusterInfo.java)",
      "children": [
        {
          "name": "Method public ImmutableOpenMap<String, DiskUsage> getNodeLeastAvailableDiskUsages()  (ClusterInfo.java)"
        }
      ],
      "comment": "\n     * Creates a new ClusterInfo instance.\n     *\n     * @param leastAvailableSpaceUsage a node id to disk usage mapping for the path that has the least available space on the node.\n     * @param mostAvailableSpaceUsage  a node id to disk usage mapping for the path that has the most available space on the node.\n     * @param shardSizes a shardkey to size in bytes mapping per shard.\n     * @param routingToDataPath the shard routing to datapath mapping\n     * @see #shardIdentifierFromRouting\n     ",
      "vertexLabel": "ClusterInfo()"
    },
    {
      "vertexName": "Field MAX_SCRIPT_FIELDS_SETTING  (IndexSettings.java)",
      "comment": "\n     * Index setting describing the maximum value of allowed `script_fields`that can be retrieved\n     * per search request. The default maximum of 32 is defensive for the reason that retrieving\n     * script fields is a costly operation.\n     ",
      "vertexLabel": "Field MAX_SCRIPT_FIELDS_SETTING"
    },
    {
      "vertexName": "Method public static RestRequest request(NamedXContentRegistry xContentRegistry, HttpRequest httpRequest, HttpChannel httpChannel)  (RestRequest.java)",
      "children": [
        {
          "name": "Method public static RestRequest requestWithoutParameters(NamedXContentRegistry xContentRegistry, HttpRequest httpRequest, HttpChannel httpChannel)  (RestRequest.java)"
        }
      ],
      "comment": "\n     * Creates a new REST request. This method will throw {@link BadParameterException} if the path cannot be\n     * decoded\n     *\n     * @param xContentRegistry the content registry\n     * @param httpRequest      the http request\n     * @param httpChannel      the http channel\n     * @throws BadParameterException      if the parameters can not be decoded\n     * @throws ContentTypeHeaderException if the Content-Type header can not be parsed\n     ",
      "vertexLabel": "RestRequest request()"
    },
    {
      "vertexName": "Method public void registerHandler(RestRequest.Method method, String path, RestHandler handler)  (RestController.java)",
      "comment": "\n     * Registers a REST handler to be executed when one of the provided methods and path match the request.\n     *\n     * @param path Path to handle (e.g., \"/{index}/{type}/_bulk\")\n     * @param handler The handler to actually execute\n     * @param method GET, POST, etc.\n     ",
      "vertexLabel": "void registerHandler()"
    },
    {
      "vertexName": "Method public RolloverRequestBuilder waitForActiveShards(ActiveShardCount waitForActiveShards)  (RolloverRequestBuilder.java)",
      "children": [
        {
          "name": "Method public void setWaitForActiveShards(ActiveShardCount waitForActiveShards)  (ResizeRequest.java)"
        }
      ],
      "comment": "\n     * Sets the number of shard copies that should be active for creation of the\n     * new rollover index to return. Defaults to {@link ActiveShardCount#DEFAULT}, which will\n     * wait for one shard copy (the primary) to become active. Set this value to\n     * {@link ActiveShardCount#ALL} to wait for all shards (primary and all replicas) to be active\n     * before returning. Otherwise, use {@link ActiveShardCount#from(int)} to set this value to any\n     * non-negative integer, up to the number of copies per shard (number of replicas + 1),\n     * to wait for the desired amount of shard copies to become active before returning.\n     * Index creation will only wait up until the timeout value for the number of shard copies\n     * to be active before returning.  Check {@link RolloverResponse#isShardsAcknowledged()} to\n     * determine if the requisite shard copies were all started before returning or timing out.\n     *\n     * @param waitForActiveShards number of active shard copies to wait on\n     ",
      "vertexLabel": "RolloverRequestBuilder waitForActiveShards()"
    },
    {
      "vertexName": "Method public Collection<String> simpleMatchToFullName(String pattern)  (MapperService.java)",
      "children": [
        {
          "name": "Method public Collection<String> simpleMatchToIndexNames(String pattern)  (QueryShardContext.java)"
        }
      ],
      "comment": "\n     * Returns all the fields that match the given pattern. If the pattern is prefixed with a type\n     * then the fields will be returned with a type prefix.\n     ",
      "vertexLabel": "Collection<String> simpleMatchToFullName()"
    },
    {
      "vertexName": "Method public GeoDistanceSortBuilder setNestedFilter(QueryBuilder nestedFilter)  (GeoDistanceSortBuilder.java)",
      "children": [
        {
          "name": "Method public FieldSortBuilder setNestedFilter(QueryBuilder nestedFilter)  (FieldSortBuilder.java)"
        }
      ],
      "comment": "\n     * Sets the nested filter that the nested objects should match with in order to\n     * be taken into account for sorting.\n     *\n     * @deprecated set nested sort with {@link #setNestedSort(NestedSortBuilder)}\n     *             and retrieve with {@link #getNestedSort()}\n     *",
      "vertexLabel": "GeoDistanceSortBuilder setNestedFilter()"
    },
    {
      "vertexName": "Field fieldsAndWeights  (SimpleQueryStringBuilder.java)",
      "comment": "\n     * Fields to query against. If left empty will query default field,\n     * currently _ALL. Uses a TreeMap to hold the fields so boolean clauses are\n     * always sorted in same order for generated Lucene query for easier\n     * testing.\n     ",
      "vertexLabel": "Field fieldsAndWeights"
    },
    {
      "vertexName": "Method public void addRefreshListener(Translog.Location location, Consumer<Boolean> listener)  (IndexShard.java)",
      "comment": "\n     * Add a listener for refreshes.\n     *\n     * @param location the location to listen for\n     * @param listener for the refresh. Called with true if registering the listener ran it out of slots and forced a refresh. Called with\n     *        false otherwise.\n     ",
      "vertexLabel": "void addRefreshListener()"
    },
    {
      "vertexName": "Method public Decision canAllocate(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation)  (SnapshotInProgressAllocationDecider.java)",
      "children": [
        {
          "name": "Method public Decision canAllocate(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation)  (AllocationDecider.java)"
        }
      ],
      "comment": "\n     * Returns a {@link Decision} whether the given shard routing can be\n     * allocated on the given node. The default is {@link Decision#ALWAYS}.\n     ",
      "vertexLabel": "Decision canAllocate()"
    },
    {
      "vertexName": "Method public DirectCandidateGeneratorBuilder minDocFreq(float minDocFreq)  (DirectCandidateGeneratorBuilder.java)",
      "children": [
        {
          "name": "Method public TermSuggestionBuilder minDocFreq(float minDocFreq)  (TermSuggestionBuilder.java)"
        }
      ],
      "comment": "\n     * Sets a minimal threshold in number of documents a suggested term\n     * should appear in. This can be specified as an absolute number or as a\n     * relative percentage of number of documents. This can improve quality\n     * by only suggesting high frequency terms. Defaults to 0f and is not\n     * enabled. If a value higher than 1 is specified then the number cannot\n     * be fractional.\n     ",
      "vertexLabel": "DirectCandidateGeneratorBuilder minDocFreq()"
    },
    {
      "vertexName": "Class SearchPhaseResults  (InitialSearchPhase.java)",
      "comment": "\n     * This class acts as a basic result collection that can be extended to do on-the-fly reduction or result processing\n     ",
      "vertexLabel": "Class SearchPhaseResults"
    },
    {
      "vertexName": "Method void searchScroll(SearchScrollRequest request, ActionListener<SearchResponse> listener)  (Client.java)",
      "children": [
        {
          "name": "Method ActionFuture<SearchResponse> searchScroll(SearchScrollRequest request)  (Client.java)"
        }
      ],
      "comment": "\n     * A search scroll request to continue searching a previous scrollable search request.\n     *\n     * @param request  The search scroll request\n     * @param listener A listener to be notified of the result\n     * @see Requests#searchScrollRequest(String)\n     ",
      "vertexLabel": "void searchScroll()"
    },
    {
      "vertexName": "Method boolean advanceExact(int doc) throws IOException  (FieldData.java)",
      "children": [
        {
          "name": "Method public abstract boolean advanceExact(int doc) throws IOException  (SortedBinaryDocValues.java)"
        }
      ],
      "comment": "\n         * Advance this instance to the given document id\n         * @return true if there is a value for this document\n         ",
      "vertexLabel": "boolean advanceExact()"
    },
    {
      "vertexName": "Method ActionFuture<FlushResponse> flush(FlushRequest request)  (IndicesAdminClient.java)",
      "comment": "\n     * Explicitly flush one or more indices (releasing memory from the node).\n     *\n     * @param request The flush request\n     * @return A result future\n     * @see org.elasticsearch.client.Requests#flushRequest(String...)\n     ",
      "vertexLabel": "ActionFuture<FlushResponse> flush()"
    },
    {
      "vertexName": "Method public boolean hasField(String path, boolean failOutOfRange)  (IngestDocument.java)",
      "children": [
        {
          "name": "Method public boolean hasField(String path)  (IngestDocument.java)"
        }
      ],
      "comment": "\n     * Checks whether the document contains a value for the provided path\n     * @param path The path within the document in dot-notation\n     * @param failOutOfRange Whether to throw an IllegalArgumentException if array is accessed outside of its range\n     * @return true if the document contains a value for the field, false otherwise\n     * @throws IllegalArgumentException if the path is null, empty or invalid.\n     ",
      "vertexLabel": "boolean hasField()"
    },
    {
      "vertexName": "Method public GeoDistanceSortBuilder setNestedPath(String nestedPath)  (GeoDistanceSortBuilder.java)",
      "children": [
        {
          "name": "Method public FieldSortBuilder setNestedPath(String nestedPath)  (FieldSortBuilder.java)"
        }
      ],
      "comment": "\n     * Sets the nested path if sorting occurs on a field that is inside a nested object. By default when sorting on a\n     * field inside a nested object, the nearest upper nested object is selected as nested path.\n     * @deprecated set nested sort with {@link #setNestedSort(NestedSortBuilder)}\n     *             and retrieve with {@link #getNestedSort()}\n     *",
      "vertexLabel": "GeoDistanceSortBuilder setNestedPath()"
    },
    {
      "vertexName": "Method public boolean ignoreUnmapped()  (GeoShapeQueryBuilder.java)",
      "children": [
        {
          "name": "Method public boolean ignoreUnmapped()  (GeoBoundingBoxQueryBuilder.java)"
        }
      ],
      "comment": "\n     * Gets whether the query builder will ignore unmapped fields (and run a\n     * {@link MatchNoDocsQuery} in place of this query) or throw an exception if\n     * the field is unmapped.\n     ",
      "vertexLabel": "boolean ignoreUnmapped()"
    },
    {
      "vertexName": "Field maxNumTokensParsed  (XMoreLikeThis.java)",
      "comment": "\n     * The maximum number of tokens to parse in each example doc field that is not stored with TermVector support\n     ",
      "vertexLabel": "Field maxNumTokensParsed"
    },
    {
      "vertexName": "Method public static WrapperQueryBuilder wrapperQuery(String source)  (QueryBuilders.java)",
      "comment": "\n     * A Query builder which allows building a query thanks to a JSON string or binary data.\n     ",
      "vertexLabel": "WrapperQueryBuilder wrapperQuery()"
    },
    {
      "vertexName": "Method public static CreateIndexRequest createIndexRequest(String index)  (Requests.java)",
      "comment": "\n     * Creates a create index request.\n     *\n     * @param index The index to create\n     * @return The index create request\n     * @see org.elasticsearch.client.IndicesAdminClient#create(org.elasticsearch.action.admin.indices.create.CreateIndexRequest)\n     ",
      "vertexLabel": "CreateIndexRequest createIndexRequest()"
    },
    {
      "vertexName": "Method public long getRemainingDelayInMillis()  (AllocateUnassignedDecision.java)",
      "comment": "\n     * Gets the remaining delay for allocating the replica shard when a node holding the replica left\n     * the cluster and the deciders are waiting to see if the node returns before allocating the replica\n     * elsewhere.  Only returns a meaningful positive value if {@link #getAllocationStatus()} returns\n     * {@link AllocationStatus#DELAYED_ALLOCATION}.  If {@link #isDecisionTaken()} returns {@code false},\n     * then invoking this method will throw an {@code IllegalStateException}.\n     ",
      "vertexLabel": "long getRemainingDelayInMillis()"
    },
    {
      "vertexName": "Method public void write(T obj, BlobContainer blobContainer, String name) throws IOException  (ChecksumBlobStoreFormat.java)",
      "comment": "\n     * Writes blob with resolving the blob name using {@link #blobName} method.\n     * <p>\n     * The blob will be compressed and checksum will be written if required.\n     *\n     * @param obj           object to be serialized\n     * @param blobContainer blob container\n     * @param name          blob name\n     ",
      "vertexLabel": "void write()"
    },
    {
      "vertexName": "Method public DiscoveryNode(String nodeName, String nodeId, TransportAddress address, Map<String, String> attributes, Set<Role> roles, Version version)  (DiscoveryNode.java)",
      "children": [
        {
          "name": "Method public DiscoveryNode(String id, TransportAddress address, Map<String, String> attributes, Set<Role> roles, Version version)  (DiscoveryNode.java)"
        }
      ],
      "comment": "\n     * Creates a new {@link DiscoveryNode}\n     * <p>\n     * <b>Note:</b> if the version of the node is unknown {@link Version#minimumCompatibilityVersion()} should be used for the current\n     * version. it corresponds to the minimum version this elasticsearch version can communicate with. If a higher version is used\n     * the node might not be able to communicate with the remote node. After initial handshakes node versions will be discovered\n     * and updated.\n     * </p>\n     *\n     * @param nodeName         the nodes name\n     * @param nodeId           the nodes unique persistent id. An ephemeral id will be auto generated.\n     * @param address          the nodes transport address\n     * @param attributes       node attributes\n     * @param roles            node roles\n     * @param version          the version of the node\n     ",
      "vertexLabel": "DiscoveryNode()"
    },
    {
      "vertexName": "Method protected void initializeUnassignedShard(RoutingAllocation allocation, RoutingNodes routingNodes, RoutingNode routingNode, ShardRouting shardRouting, @Nullable UnassignedInfo unassignedInfo, @Nullable RecoverySource recoverySource)  (AbstractAllocateAllocationCommand.java)",
      "children": [
        {
          "name": "Method protected void initializeUnassignedShard(RoutingAllocation allocation, RoutingNodes routingNodes, RoutingNode routingNode, ShardRouting shardRouting)  (AbstractAllocateAllocationCommand.java)"
        }
      ],
      "comment": "\n     * Initializes an unassigned shard on a node and removes it from the unassigned\n     *\n     * @param allocation the allocation\n     * @param routingNodes the routing nodes\n     * @param routingNode the node to initialize it to\n     * @param shardRouting the shard routing that is to be matched in unassigned shards\n     * @param unassignedInfo unassigned info to override\n     * @param recoverySource recovery source to override\n     ",
      "vertexLabel": "void initializeUnassignedShard()"
    },
    {
      "vertexName": "Method public GetRequest refresh(boolean refresh)  (GetRequest.java)",
      "comment": "\n     * Should a refresh be executed before this get operation causing the operation to\n     * return the latest value. Note, heavy get should not set this to {@code true}. Defaults\n     * to {@code false}.\n     ",
      "vertexLabel": "GetRequest refresh()"
    },
    {
      "vertexName": "Method public static SortedBinaryDocValues toString(final MultiGeoPointValues values)  (FieldData.java)",
      "children": [
        {
          "name": "Method public static SortedBinaryDocValues toString(final SortedNumericDocValues values)  (FieldData.java)"
        }
      ],
      "comment": "\n     * Return a {@link String} representation of the provided values. That is\n     * typically used for scripts or for the `map` execution mode of terms aggs.\n     * NOTE: this is very slow!\n     ",
      "vertexLabel": "SortedBinaryDocValues toString()"
    },
    {
      "vertexName": "Method void performOn(ShardRouting replica, RequestT replicaRequest, long globalCheckpoint, long maxSeqNoOfUpdatesOrDeletes, ActionListener<ReplicaResponse> listener)  (ReplicationOperation.java)",
      "comment": "\n         * Performs the specified request on the specified replica.\n         *\n         * @param replica                    the shard this request should be executed on\n         * @param replicaRequest             the operation to perform\n         * @param globalCheckpoint           the global checkpoint on the primary\n         * @param maxSeqNoOfUpdatesOrDeletes the max seq_no of updates (index operations overwriting Lucene) or deletes on primary\n         *                                   after this replication was executed on it.\n         * @param listener                   callback for handling the response or failure\n         ",
      "vertexLabel": "void performOn()"
    },
    {
      "vertexName": "Method public ReverseNestedAggregationBuilder path(String path)  (ReverseNestedAggregationBuilder.java)",
      "comment": "\n     * Set the path to use for this nested aggregation. The path must match\n     * the path to a nested object in the mappings. If it is not specified\n     * then this aggregation will go back to the root document.\n     ",
      "vertexLabel": "ReverseNestedAggregationBuilder path()"
    },
    {
      "vertexName": "Method public FileInfo findNameFile(String name)  (BlobStoreIndexShardSnapshots.java)",
      "comment": "\n     * Finds reference to a snapshotted file by its snapshot name\n     *\n     * @param name file name\n     * @return file info or null if file is not present in any of snapshots\n     ",
      "vertexLabel": "FileInfo findNameFile()"
    },
    {
      "vertexName": "Method String readSysFsCgroupCpuAcctCpuAcctCfsQuota(final String controlGroup) throws IOException  (OsProbe.java)",
      "children": [
        {
          "name": "Method String readSysFsCgroupCpuAcctCpuCfsPeriod(final String controlGroup) throws IOException  (OsProbe.java)"
        }
      ],
      "comment": "\n     * Returns the line from {@code cpu.cfs_quota_us} for the control group to which the Elasticsearch process belongs for the {@code cpu}\n     * subsystem. This line represents the total time in microseconds that all tasks in the control group can run during one period as\n     * specified by {@code cpu.cfs_period_us}.\n     *\n     * @param controlGroup the control group to which the Elasticsearch process belongs for the {@code cpu} subsystem\n     * @return the line from {@code cpu.cfs_quota_us}\n     * @throws IOException if an I/O exception occurs reading {@code cpu.cfs_quota_us} for the control group\n     ",
      "vertexLabel": "String readSysFsCgroupCpuAcctCpuAcctCfsQuota()"
    },
    {
      "vertexName": "Method public MatchPhraseQueryBuilder analyzer(String analyzer)  (MatchPhraseQueryBuilder.java)",
      "children": [
        {
          "name": "Method public MatchPhrasePrefixQueryBuilder analyzer(String analyzer)  (MatchPhrasePrefixQueryBuilder.java)"
        }
      ],
      "comment": "\n     * Explicitly set the analyzer to use. Defaults to use explicit mapping\n     * config for the field, or, if not set, the default search analyzer.\n     ",
      "vertexLabel": "MatchPhraseQueryBuilder analyzer()"
    },
    {
      "vertexName": "Field LOW_LEVEL_CANCELLATION_SETTING  (SearchService.java)",
      "comment": "\n     * Enables low-level, frequent search cancellation checks. Enabling low-level checks will make long running searches to react\n     * to the cancellation request faster. However, since it will produce more cancellation checks it might slow the search performance\n     * down.\n     ",
      "vertexLabel": "Field LOW_LEVEL_CANCELLATION_SETTING"
    },
    {
      "vertexName": "Method public static BucketOrder readHistogramOrder(StreamInput in, boolean bwcOrderFlag) throws IOException  (InternalOrder.java)",
      "children": [
        {
          "name": "Method public static BucketOrder readOrder(StreamInput in) throws IOException  (InternalOrder.java)"
        },
        {
          "name": "Method public static void writeHistogramOrder(BucketOrder order, StreamOutput out, boolean bwcOrderFlag) throws IOException  (InternalOrder.java)"
        }
      ],
      "comment": "\n         * ONLY FOR HISTOGRAM ORDER: Backwards compatibility logic to read a {@link BucketOrder} from a {@link StreamInput}.\n         *\n         * @param in           stream with order data to read.\n         * @param bwcOrderFlag {@code true} to check {@code in.readBoolean()} in the backwards compat logic before reading\n         *                     the order. {@code false} to skip this flag (order always present).\n         * @return order read from the stream\n         * @throws IOException on error reading from the stream.\n         ",
      "vertexLabel": "BucketOrder readHistogramOrder()"
    },
    {
      "vertexName": "Class Builder  (UpdateResponse.java)",
      "children": [
        {
          "name": "Class Builder  (DeleteResponse.java)"
        }
      ],
      "comment": "\n     * Builder class for {@link UpdateResponse}. This builder is usually used during xcontent parsing to\n     * temporarily store the parsed values, then the {@link DocWriteResponse.Builder#build()} method is called to\n     * instantiate the {@link UpdateResponse}.\n     ",
      "vertexLabel": "Class Builder"
    },
    {
      "vertexName": "Method public ConstantScoreQueryBuilder(QueryBuilder filterBuilder)  (ConstantScoreQueryBuilder.java)",
      "children": [
        {
          "name": "Method public static ConstantScoreQueryBuilder constantScoreQuery(QueryBuilder queryBuilder)  (QueryBuilders.java)"
        }
      ],
      "comment": "\n     * A query that wraps another query and simply returns a constant score equal to the\n     * query boost for every document in the query.\n     *\n     * @param filterBuilder The query to wrap in a constant score query\n     ",
      "vertexLabel": "ConstantScoreQueryBuilder()"
    },
    {
      "vertexName": "Method public HighlightBuilder field(String name)  (HighlightBuilder.java)",
      "comment": "\n     * Adds a field to be highlighted with default fragment size of 100 characters, and\n     * default number of fragments of 5 using the default encoder\n     *\n     * @param name The field to highlight\n     ",
      "vertexLabel": "HighlightBuilder field()"
    },
    {
      "vertexName": "Method private void parse(ParseContext parseContext, Token token, XContentParser parser, Map<String, CompletionInputMetaData> inputMap) throws IOException  (CompletionFieldMapper.java)",
      "comment": "\n     * Acceptable inputs:\n     *  \"STRING\" - interpreted as the field value (input)\n     *  \"OBJECT\" - { \"input\": STRING|ARRAY, \"weight\": STRING|INT, \"contexts\": ARRAY|OBJECT }\n     ",
      "vertexLabel": "void parse()"
    },
    {
      "vertexName": "Method public UpdateSettingsRequestBuilder setIndicesOptions(IndicesOptions options)  (UpdateSettingsRequestBuilder.java)",
      "children": [
        {
          "name": "Method public DeleteIndexRequestBuilder setIndicesOptions(IndicesOptions options)  (DeleteIndexRequestBuilder.java)"
        }
      ],
      "comment": "\n     * Specifies what type of requested indices to ignore and wildcard indices expressions.\n     * <p>\n     * For example indices that don't exist.\n     ",
      "vertexLabel": "UpdateSettingsRequestBuilder setIndicesOptions()"
    },
    {
      "vertexName": "Method public IntLookupContainer keys()  (ImmutableOpenIntMap.java)",
      "children": [
        {
          "name": "Method public ObjectLookupContainer<KType> keys()  (ImmutableOpenMap.java)"
        }
      ],
      "comment": "\n     * Returns a specialized view of the keys of this associated container.\n     * The view additionally implements {@link com.carrotsearch.hppc.ObjectLookupContainer}.\n     ",
      "vertexLabel": "IntLookupContainer keys()"
    },
    {
      "vertexName": "Method public static boolean isRepositoryInUse(ClusterState clusterState, String repository)  (RestoreService.java)",
      "children": [
        {
          "name": "Method public static boolean isRepositoryInUse(ClusterState clusterState, String repository)  (SnapshotsService.java)"
        }
      ],
      "comment": "\n     * Checks if a repository is currently in use by one of the snapshots\n     *\n     * @param clusterState cluster state\n     * @param repository   repository id\n     * @return true if repository is currently in use by one of the running snapshots\n     ",
      "vertexLabel": "boolean isRepositoryInUse()"
    },
    {
      "vertexName": "Method static Optional<String> checkShardLimit(Settings settings, ClusterState clusterState, DeprecationLogger deprecationLogger)  (MetaDataCreateIndexService.java)",
      "comment": "\n     * Checks whether an index can be created without going over the cluster shard limit.\n     *\n     * @param settings The settings of the index to be created.\n     * @param clusterState The current cluster state.\n     * @param deprecationLogger The logger to use to emit a deprecation warning, if appropriate.\n     * @return If present, an error message to be used to reject index creation. If empty, a signal that this operation may be carried out.\n     ",
      "vertexLabel": "Optional<String> checkShardLimit()"
    },
    {
      "vertexName": "Method void state(ClusterStateRequest request, ActionListener<ClusterStateResponse> listener)  (ClusterAdminClient.java)",
      "comment": "\n     * The state of the cluster.\n     *\n     * @param request  The cluster state request.\n     * @param listener A listener to be notified with a result\n     * @see Requests#clusterStateRequest()\n     ",
      "vertexLabel": "void state()"
    },
    {
      "vertexName": "Method ResizeRequestBuilder prepareResizeIndex(String sourceIndex, String targetIndex)  (IndicesAdminClient.java)",
      "comment": "\n     * Resize an index using an explicit request allowing to specify the settings, mappings and aliases of the target index of the index.\n     ",
      "vertexLabel": "ResizeRequestBuilder prepareResizeIndex()"
    },
    {
      "vertexName": "Method public UpdateRequest script(String script, ScriptType scriptType, @Nullable Map<String, Object> scriptParams)  (UpdateRequest.java)",
      "children": [
        {
          "name": "Method public UpdateRequest script(String script, ScriptType scriptType)  (UpdateRequest.java)"
        }
      ],
      "comment": "\n     * The script to execute. Note, make sure not to send different script each\n     * times and instead use script params if possible with the same\n     * (automatically compiled) script.\n     *\n     * @deprecated Use {@link #script(Script)} instead\n     ",
      "vertexLabel": "UpdateRequest script()"
    },
    {
      "vertexName": "Method public GetRequestBuilder setFetchSource(@Nullable String include, @Nullable String exclude)  (GetRequestBuilder.java)",
      "children": [
        {
          "name": "Method public ExplainRequestBuilder setFetchSource(@Nullable String include, @Nullable String exclude)  (ExplainRequestBuilder.java)"
        }
      ],
      "comment": "\n     * Indicate that _source should be returned, with an \"include\" and/or \"exclude\" set which can include simple wildcard\n     * elements.\n     *\n     * @param include An optional include (optionally wildcarded) pattern to filter the returned _source\n     * @param exclude An optional exclude (optionally wildcarded) pattern to filter the returned _source\n     ",
      "vertexLabel": "GetRequestBuilder setFetchSource()"
    },
    {
      "vertexName": "Method public NumericDoubleValues select(final SortedNumericDoubleValues values, final double missingValue, final BitSet parentDocs, final DocIdSetIterator childDocs, int maxDoc, int maxChildren) throws IOException  (MultiValueMode.java)",
      "children": [
        {
          "name": "Method public NumericDocValues select(final SortedNumericDocValues values, final long missingValue, final BitSet parentDocs, final DocIdSetIterator childDocs, int maxDoc, int maxChildren) throws IOException  (MultiValueMode.java)"
        }
      ],
      "comment": "\n     * Return a {@link NumericDoubleValues} instance that can be used to sort root documents\n     * with this mode, the provided values and filters for root/inner documents.\n     *\n     * For every root document, the values of its inner documents will be aggregated.\n     * If none of the inner documents has a value, then <code>missingValue</code> is returned.\n     *\n     * Allowed Modes: SUM, AVG, MIN, MAX\n     *\n     * NOTE: Calling the returned instance on docs that are not root docs is illegal\n     *       The returned instance can only be evaluate the current and upcoming docs\n     ",
      "vertexLabel": "NumericDoubleValues select()"
    },
    {
      "vertexName": "Class MapBinder  (MapBinder.java)",
      "children": [
        {
          "name": "Class Multibinder  (Multibinder.java)"
        }
      ],
      "comment": "\n * An API to bind multiple map entries separately, only to later inject them as\n * a complete map. MapBinder is intended for use in your application's module:\n * <pre><code>\n * public class SnacksModule extends AbstractModule {\n *   protected void configure() {\n *     MapBinder&lt;String, Snack&gt; mapbinder\n *         = MapBinder.newMapBinder(binder(), String.class, Snack.class);\n *     mapbinder.addBinding(\"twix\").toInstance(new Twix());\n *     mapbinder.addBinding(\"snickers\").toProvider(SnickersProvider.class);\n *     mapbinder.addBinding(\"skittles\").to(Skittles.class);\n *   }\n * }</code></pre>\n * <p>\n * With this binding, a {@link Map}{@code <String, Snack>} can now be\n * injected:\n * <pre><code>\n * class SnackMachine {\n *   {@literal @}Inject\n *   public SnackMachine(Map&lt;String, Snack&gt; snacks) { ... }\n * }</code></pre>\n * <p>\n * In addition to binding {@code Map<K, V>}, a mapbinder will also bind\n * {@code Map<K, Provider<V>>} for lazy value provision:\n * <pre><code>\n * class SnackMachine {\n *   {@literal @}Inject\n *   public SnackMachine(Map&lt;String, Provider&lt;Snack&gt;&gt; snackProviders) { ... }\n * }</code></pre>\n * <p>\n * Creating mapbindings from different modules is supported. For example, it\n * is okay to have both {@code CandyModule} and {@code ChipsModule} both\n * create their own {@code MapBinder<String, Snack>}, and to each contribute\n * bindings to the snacks map. When that map is injected, it will contain\n * entries from both modules.\n * <p>\n * Values are resolved at map injection time. If a value is bound to a\n * provider, that provider's get method will be called each time the map is\n * injected (unless the binding is also scoped, or a map of providers is injected).\n * <p>\n * Annotations are used to create different maps of the same key/value\n * type. Each distinct annotation gets its own independent map.\n * <p>\n * <strong>Keys must be distinct.</strong> If the same key is bound more than\n * once, map injection will fail.\n * <p>\n * <strong>Keys must be non-null.</strong> {@code addBinding(null)} will\n * throw an unchecked exception.\n * <p>\n * <strong>Values must be non-null to use map injection.</strong> If any\n * value is null, map injection will fail (although injecting a map of providers\n * will not).\n *\n * @author dpb@google.com (David P. Baker)\n ",
      "vertexLabel": "Class MapBinder"
    },
    {
      "vertexName": "Method public FloatArray newFloatArray(long size, boolean clearOnResize)  (BigArrays.java)",
      "children": [
        {
          "name": "Method public IntArray newIntArray(long size, boolean clearOnResize)  (BigArrays.java)"
        }
      ],
      "comment": "\n     * Allocate a new {@link FloatArray}.\n     * @param size          the initial length of the array\n     * @param clearOnResize whether values should be set to 0 on initialization and resize\n     ",
      "vertexLabel": "FloatArray newFloatArray()"
    },
    {
      "vertexName": "Field INDEX_TRANSLOG_RETENTION_AGE_SETTING  (IndexSettings.java)",
      "children": [
        {
          "name": "Field INDEX_TRANSLOG_RETENTION_SIZE_SETTING  (IndexSettings.java)"
        }
      ],
      "comment": "\n     * Controls how long translog files that are no longer needed for persistence reasons\n     * will be kept around before being deleted. A longer retention policy is useful to increase\n     * the chance of ops based recoveries.\n     *",
      "vertexLabel": "Field INDEX_TRANSLOG_RETENTION_AGE_SETTING"
    },
    {
      "vertexName": "Method public abstract ClusterState execute(ClusterState currentState) throws Exception  (ClusterStateUpdateTask.java)",
      "comment": "\n     * Update the cluster state based on the current state. Return the *same instance* if no state\n     * should be changed.\n     ",
      "vertexLabel": "abstract ClusterState execute()"
    },
    {
      "vertexName": "Method public void setMinWordLen(int minWordLen)  (XMoreLikeThis.java)",
      "comment": "\n     * Sets the minimum word length below which words will be ignored.\n     *\n     * @param minWordLen the minimum word length below which words will be ignored.\n     ",
      "vertexLabel": "void setMinWordLen()"
    },
    {
      "vertexName": "Method public int getMaxWordLen()  (XMoreLikeThis.java)",
      "children": [
        {
          "name": "Method public void setMaxWordLen(int maxWordLen)  (XMoreLikeThis.java)"
        },
        {
          "name": "Method public int getMinWordLen()  (XMoreLikeThis.java)"
        }
      ],
      "comment": "\n     * Returns the maximum word length above which words will be ignored. Set this to 0 for no\n     * maximum word length. The default is {@link #DEFAULT_MAX_WORD_LENGTH}.\n     *\n     * @return the maximum word length above which words will be ignored.\n     ",
      "vertexLabel": "int getMaxWordLen()"
    },
    {
      "vertexName": "Method protected double[] emptyPredictions(int numPredictions)  (MovAvgModel.java)",
      "comment": "\n     * Returns an empty set of predictions, filled with NaNs\n     * @param numPredictions Number of empty predictions to generate\n     ",
      "vertexLabel": "double[] emptyPredictions()"
    },
    {
      "vertexName": "Method public EWMAModelBuilder alpha(double alpha)  (EwmaModel.java)",
      "children": [
        {
          "name": "Field alpha  (EwmaModel.java)"
        }
      ],
      "comment": "\n         * Alpha controls the smoothing of the data.  Alpha = 1 retains no memory of past values\n         * (e.g. a random walk), while alpha = 0 retains infinite memory of past values (e.g.\n         * the series mean).  Useful values are somewhere in between.  Defaults to 0.5.\n         *\n         * @param alpha A double between 0-1 inclusive, controls data smoothing\n         *\n         * @return The builder to continue chaining\n         ",
      "vertexLabel": "EWMAModelBuilder alpha()"
    },
    {
      "vertexName": "Method QueryBuilder rewrite(QueryRewriteContext queryShardContext) throws IOException  (QueryBuilder.java)",
      "children": [
        {
          "name": "Method public Builder rewrite(QueryRewriteContext context) throws IOException  (AggregatorFactories.java)"
        }
      ],
      "comment": "\n     * Rewrites this query builder into its primitive form. By default this method return the builder itself. If the builder\n     * did not change the identity reference must be returned otherwise the builder will be rewritten infinitely.\n     ",
      "vertexLabel": "QueryBuilder rewrite()"
    },
    {
      "vertexName": "Method public void validateAlias(Alias alias, String index, MetaData metaData)  (AliasValidator.java)",
      "children": [
        {
          "name": "Method public void validateAliasMetaData(AliasMetaData aliasMetaData, String index, MetaData metaData)  (AliasValidator.java)"
        }
      ],
      "comment": "\n     * Allows to validate an {@link org.elasticsearch.action.admin.indices.alias.Alias} and make sure\n     * it's valid before it gets added to the index metadata. Doesn't validate the alias filter.\n     * @throws IllegalArgumentException if the alias is not valid\n     ",
      "vertexLabel": "void validateAlias()"
    },
    {
      "vertexName": "Method private static BasicModel parseBasicModel(Version indexCreatedVersion, Settings settings)  (SimilarityProviders.java)",
      "children": [
        {
          "name": "Method private static Lambda parseLambda(Settings settings)  (SimilarityProviders.java)"
        }
      ],
      "comment": "\n     * Parses the given Settings and creates the appropriate {@link BasicModel}\n     *\n     * @param settings Settings to parse\n     * @return {@link BasicModel} referred to in the Settings\n     ",
      "vertexLabel": "BasicModel parseBasicModel()"
    },
    {
      "vertexName": "EnumConstant TEMPORARY_REDIRECT  (RestStatus.java)",
      "children": [
        {
          "name": "EnumConstant FOUND  (RestStatus.java)"
        }
      ],
      "comment": "\n     * The requested resource resides temporarily under a different URI. Since the redirection MAY be altered on\n     * occasion, the client SHOULD continue to use the Request-URI for future requests.  This response is only\n     * cacheable if indicated by a Cache-Control or Expires header field.\n     * <p>\n     * The temporary URI SHOULD be given by the Location field in the response. Unless the request method was\n     * HEAD, the entity of the response SHOULD contain a short hypertext note with a hyperlink to the new URI(s) ,\n     * since many pre-HTTP/1.1 user agents do not understand the 307 status. Therefore, the note SHOULD contain\n     * the information necessary for a user to repeat the original request on the new URI.\n     * <p>\n     * If the 307 status code is received in response to a request other than GET or HEAD, the user agent MUST NOT\n     * automatically redirect the request unless it can be confirmed by the user, since this might change the\n     * conditions under which the request was issued.\n     ",
      "vertexLabel": "EnumConstant TEMPORARY_REDIRECT"
    },
    {
      "vertexName": "Method QB fromXContent(XContentParser parser) throws IOException  (QueryParser.java)",
      "comment": "\n     * Creates a new {@link QueryBuilder} from the query held by the\n     * {@link XContentParser}. The state on the parser contained in this context\n     * will be changed as a side effect of this method call\n     ",
      "vertexLabel": "QB fromXContent()"
    },
    {
      "vertexName": "Method public DirectCandidateGeneratorBuilder maxInspections(Integer maxInspections)  (DirectCandidateGeneratorBuilder.java)",
      "comment": "\n     * A factor that is used to multiply with the size in order to inspect\n     * more candidate suggestions. Can improve accuracy at the cost of\n     * performance. Defaults to {@code 5}.\n     ",
      "vertexLabel": "DirectCandidateGeneratorBuilder maxInspections()"
    },
    {
      "vertexName": "Method public Builder put(String setting, int value)  (Settings.java)",
      "children": [
        {
          "name": "Method public Builder put(String key, String value)  (Settings.java)"
        }
      ],
      "comment": "\n         * Sets the setting with the provided setting key and the int value.\n         *\n         * @param setting The setting key\n         * @param value   The int value\n         * @return The builder\n         ",
      "vertexLabel": "Builder put()"
    },
    {
      "vertexName": "Method public CorruptStateException(Throwable ex)  (CorruptStateException.java)",
      "comment": "\n     * Creates a new {@link CorruptStateException} with the given exceptions stacktrace.\n     * This constructor copies the stacktrace as well as the message from the given {@link Throwable}\n     * into this exception.\n     *\n     * @param ex the exception cause\n     ",
      "vertexLabel": "CorruptStateException()"
    },
    {
      "vertexName": "Method private EmptyTopDocsCollectorContext(IndexReader reader, Query query, boolean trackTotalHits, boolean hasFilterCollector) throws IOException  (TopDocsCollectorContext.java)",
      "comment": "\n         * Ctr\n         * @param reader The index reader\n         * @param query The query to execute\n         * @param trackTotalHits True if the total number of hits should be tracked\n         * @param hasFilterCollector True if the collector chain contains a filter\n         ",
      "vertexLabel": "EmptyTopDocsCollectorContext()"
    },
    {
      "vertexName": "Class DefaultBindingTargetVisitor  (DefaultBindingTargetVisitor.java)",
      "children": [
        {
          "name": "Class DefaultBindingScopingVisitor  (DefaultBindingScopingVisitor.java)"
        }
      ],
      "comment": "\n * No-op visitor for subclassing. All interface methods simply delegate to {@link\n * #visitOther(Binding)}, returning its result.\n *\n * @param <V> any type to be returned by the visit method. Use {@link Void} with\n *            {@code return null} if no return type is needed.\n * @author jessewilson@google.com (Jesse Wilson)\n * @since 2.0\n ",
      "vertexLabel": "Class DefaultBindingTargetVisitor"
    },
    {
      "vertexName": "Interface HttpResponse  (HttpResponse.java)",
      "children": [
        {
          "name": "Interface HttpRequest  (HttpRequest.java)"
        }
      ],
      "comment": "\n * A basic http response abstraction. Http modules must implement this interface as the server package rest\n * handling needs to set http headers for a response.\n ",
      "vertexLabel": "Interface HttpResponse"
    },
    {
      "vertexName": "Method public Collection<String> simpleMatchToIndexNames(String pattern)  (QueryShardContext.java)",
      "comment": "\n     * Returns all the fields that match a given pattern. If prefixed with a\n     * type then the fields will be returned with a type prefix.\n     ",
      "vertexLabel": "Collection<String> simpleMatchToIndexNames()"
    },
    {
      "vertexName": "Method public TermVectorsRequestBuilder setSelectedFields(String... fields)  (TermVectorsRequestBuilder.java)",
      "children": [
        {
          "name": "Method public Set<String> selectedFields()  (TermVectorsRequest.java)"
        }
      ],
      "comment": "\n     * Sets whether to return only term vectors for special selected fields. Returns the term\n     * vectors for all fields if selectedFields == null\n     ",
      "vertexLabel": "TermVectorsRequestBuilder setSelectedFields()"
    },
    {
      "vertexName": "Class ImmutableOpenIntMap  (ImmutableOpenIntMap.java)",
      "children": [
        {
          "name": "Class ImmutableOpenMap  (ImmutableOpenMap.java)"
        }
      ],
      "comment": "\n * An immutable map implementation based on open hash map.\n * <p>\n * Can be constructed using a {@link #builder()}, or using {@link #builder(org.elasticsearch.common.collect.ImmutableOpenIntMap)}\n * (which is an optimized option to copy over existing content and modify it).\n ",
      "vertexLabel": "Class ImmutableOpenIntMap"
    },
    {
      "vertexName": "Method public ElasticsearchException(String msg, Object... args)  (ElasticsearchException.java)",
      "comment": "\n     * Construct a <code>ElasticsearchException</code> with the specified detail message.\n     *\n     * The message can be parameterized using <code>{}</code> as placeholders for the given\n     * arguments\n     *\n     * @param msg  the detail message\n     * @param args the arguments for the message\n     ",
      "vertexLabel": "ElasticsearchException()"
    },
    {
      "vertexName": "Method public void updatePersistentTaskState(final String taskId, final long taskAllocationId, final PersistentTaskState taskState, final ActionListener<PersistentTask<?>> listener)  (PersistentTasksClusterService.java)",
      "children": [
        {
          "name": "Method public void removePersistentTask(String id, ActionListener<PersistentTask<?>> listener)  (PersistentTasksClusterService.java)"
        }
      ],
      "comment": "\n     * Update the state of a persistent task\n     *\n     * @param taskId           the id of a persistent task\n     * @param taskAllocationId the expected allocation id of the persistent task\n     * @param taskState        new state\n     * @param listener         the listener that will be called when task is removed\n     ",
      "vertexLabel": "void updatePersistentTaskState()"
    },
    {
      "vertexName": "Method public static String readOptionalStringProperty(String processorType, String processorTag, Map<String, Object> configuration, String propertyName)  (ConfigurationUtils.java)",
      "children": [
        {
          "name": "Method public static String readOptionalStringOrIntProperty(String processorType, String processorTag, Map<String, Object> configuration, String propertyName)  (ConfigurationUtils.java)"
        }
      ],
      "comment": "\n     * Returns and removes the specified optional property from the specified configuration map.\n     *\n     * If the property value isn't of type string a {@link ElasticsearchParseException} is thrown.\n     ",
      "vertexLabel": "String readOptionalStringProperty()"
    },
    {
      "vertexName": "Method public GetRepositoriesRequest repositories(String[] repositories)  (GetRepositoriesRequest.java)",
      "comment": "\n     * Sets the list or repositories.\n     * <p>\n     * If the list of repositories is empty or it contains a single element \"_all\", all registered repositories\n     * are returned.\n     *\n     * @param repositories list of repositories\n     * @return this request\n     ",
      "vertexLabel": "GetRepositoriesRequest repositories()"
    },
    {
      "vertexName": "Interface TcpServerChannel  (TcpServerChannel.java)",
      "children": [
        {
          "name": "Interface TcpChannel  (TcpChannel.java)"
        }
      ],
      "comment": "\n * This is a tcp channel representing a server channel listening for new connections. It is the server\n * channel abstraction used by the {@link TcpTransport} and {@link TransportService}. All tcp transport\n * implementations must return server channels that adhere to the required method contracts.\n ",
      "vertexLabel": "Interface TcpServerChannel"
    },
    {
      "vertexName": "Class CategoryContextMapping  (CategoryContextMapping.java)",
      "comment": "\n * A {@link ContextMapping} that uses a simple string as a criteria\n * The suggestions are boosted and/or filtered by their associated\n * category (string) value.\n * {@link CategoryQueryContext} defines options for constructing\n * a unit of query context for this context type\n ",
      "vertexLabel": "Class CategoryContextMapping"
    },
    {
      "vertexName": "EnumConstant SUM  (SortMode.java)",
      "comment": " Use the sum of all values as sort value. Only applicable for number based array fields. *",
      "vertexLabel": "EnumConstant SUM"
    },
    {
      "vertexName": "Method private PriorityQueue<ScoreTerm> createQueue(Map<String, Int> words) throws IOException  (XMoreLikeThis.java)",
      "comment": "\n     * Create a PriorityQueue from a word-&gt;tf map.\n     *\n     * @param words a map of words keyed on the word(String) with Int objects as the values.\n     ",
      "vertexLabel": "PriorityQueue<ScoreTerm> createQueue()"
    },
    {
      "vertexName": "Method static Tuple<Integer, Class<? extends ElasticsearchException>>[] classes()  (ElasticsearchException.java)",
      "children": [
        {
          "name": "Method static int[] ids()  (ElasticsearchException.java)"
        }
      ],
      "comment": "\n     * Returns an array of all registered pairs of handle IDs and exception classes. These pairs are\n     * provided for every registered exception.\n     *\n     * @return an array of all registered pairs of handle IDs and exception classes\n     ",
      "vertexLabel": "Tuple<Integer, Class<? extends ElasticsearchException>>[] classes()"
    },
    {
      "vertexName": "Method public void submitStateUpdateTask(String source, T task, ClusterStateTaskConfig config, ClusterStateTaskExecutor<T> executor, ClusterStateTaskListener listener)  (MasterService.java)",
      "children": [
        {
          "name": "Method public void submitStateUpdateTask(String source, T task, ClusterStateTaskConfig config, ClusterStateTaskExecutor<T> executor, ClusterStateTaskListener listener)  (ClusterService.java)"
        }
      ],
      "comment": "\n     * Submits a cluster state update task; submitted updates will be\n     * batched across the same instance of executor. The exact batching\n     * semantics depend on the underlying implementation but a rough\n     * guideline is that if the update task is submitted while there\n     * are pending update tasks for the same executor, these update\n     * tasks will all be executed on the executor in a single batch\n     *\n     * @param source   the source of the cluster state update task\n     * @param task     the state needed for the cluster state update task\n     * @param config   the cluster state update task configuration\n     * @param executor the cluster state update task executor; tasks\n     *                 that share the same executor will be executed\n     *                 batches on this executor\n     * @param listener callback after the cluster state update task\n     *                 completes\n     * @param <T>      the type of the cluster state update task state\n     *\n     ",
      "vertexLabel": "void submitStateUpdateTask()"
    },
    {
      "vertexName": "Method public static long copy(InputStream in, OutputStream out, byte[] buffer) throws IOException  (Streams.java)",
      "children": [
        {
          "name": "Method public static void copy(byte[] in, OutputStream out) throws IOException  (Streams.java)"
        }
      ],
      "comment": "\n     * Copy the contents of the given InputStream to the given OutputStream.\n     * Closes both streams when done.\n     *\n     * @param in  the stream to copy from\n     * @param out the stream to copy to\n     * @return the number of bytes copied\n     * @throws IOException in case of I/O errors\n     ",
      "vertexLabel": "long copy()"
    },
    {
      "vertexName": "Class JavaDateMathParser  (JavaDateMathParser.java)",
      "children": [
        {
          "name": "Class JodaDateMathParser  (JodaDateMathParser.java)"
        }
      ],
      "comment": "\n * A parser for date/time formatted text with optional date math.\n *\n * The format of the datetime is configurable, and unix timestamps can also be used. Datemath\n * is appended to a datetime with the following syntax:\n * <code>||[+-/](\\d+)?[yMwdhHms]</code>.\n ",
      "vertexLabel": "Class JavaDateMathParser"
    },
    {
      "vertexName": "Method void resizeIndex(ResizeRequest request, ActionListener<ResizeResponse> listener)  (IndicesAdminClient.java)",
      "children": [
        {
          "name": "Method ResizeRequestBuilder prepareResizeIndex(String sourceIndex, String targetIndex)  (IndicesAdminClient.java)"
        }
      ],
      "comment": "\n     * Shrinks an index using an explicit request allowing to specify the settings, mappings and aliases of the target index of the index.\n     ",
      "vertexLabel": "void resizeIndex()"
    },
    {
      "vertexName": "Method List<String> getActiveOperations()  (IndexShardOperationPermits.java)",
      "children": [
        {
          "name": "Method public List<String> getActiveOperations()  (IndexShard.java)"
        }
      ],
      "comment": "\n     * @return a list of describing each permit that wasn't released yet. The description consist of the debugInfo supplied\n     *         when the permit was acquired plus a stack traces that was captured when the permit was request.\n     ",
      "vertexLabel": "List<String> getActiveOperations()"
    },
    {
      "vertexName": "Method public GeoDistanceSortBuilder(String fieldName, double lat, double lon)  (GeoDistanceSortBuilder.java)",
      "children": [
        {
          "name": "Method public static GeoDistanceSortBuilder geoDistanceSort(String fieldName, double lat, double lon)  (SortBuilders.java)"
        }
      ],
      "comment": "\n     * Constructs a new distance based sort on a geo point like field.\n     *\n     * @param fieldName The geo point like field name.\n     * @param lat Latitude of the point to create the range distance facets from.\n     * @param lon Longitude of the point to create the range distance facets from.\n     ",
      "vertexLabel": "GeoDistanceSortBuilder()"
    },
    {
      "vertexName": "Method public AggregationSpec(ParseField name, Writeable.Reader<? extends AggregationBuilder> reader, Aggregator.Parser parser)  (SearchPlugin.java)",
      "children": [
        {
          "name": "Method public AggregationSpec(String name, Writeable.Reader<? extends AggregationBuilder> reader, Aggregator.Parser parser)  (SearchPlugin.java)"
        }
      ],
      "comment": "\n         * Specification for an {@link Aggregation}.\n         *\n         * @param name holds the names by which this aggregation might be parsed. The {@link ParseField#getPreferredName()} is special as it\n         *        is the name by under which the reader is registered. So it is the name that the {@link AggregationBuilder} should return\n         *        from {@link NamedWriteable#getWriteableName()}.\n         * @param reader the reader registered for this aggregation's builder. Typically a reference to a constructor that takes a\n         *        {@link StreamInput}\n         * @param parser the parser the reads the aggregation builder from xcontent\n         ",
      "vertexLabel": "AggregationSpec()"
    },
    {
      "vertexName": "EnumConstant NOT_MODIFIED  (RestStatus.java)",
      "comment": "\n     * If the client has performed a conditional GET request and access is allowed, but the document has not been\n     * modified, the server SHOULD respond with this status code. The 304 response MUST NOT contain a message-body,\n     * and thus is always terminated by the first empty line after the header fields.\n     * <p>\n     * The response MUST include the following header fields:\n     * <ul>\n     * <li>Date, unless its omission is required by section 14.18.1\n     * If a clockless origin server obeys these rules, and proxies and clients add their own Date to any\n     * response received without one (as already specified by [RFC 2068], section 14.19), caches will operate\n     * correctly.\n     * </li>\n     * <li>ETag and/or Content-Location, if the header would have been sent in a 200 response to the same request</li>\n     * <li>Expires, Cache-Control, and/or Vary, if the field-value might differ from that sent in any previous\n     * response for the same variant</li>\n     * </ul>\n     * <p>\n     * If the conditional GET used a strong cache validator (see section 13.3.3), the response SHOULD NOT include\n     * other entity-headers. Otherwise (i.e., the conditional GET used a weak validator), the response MUST NOT\n     * include other entity-headers; this prevents inconsistencies between cached entity-bodies and updated headers.\n     * <p>\n     * If a 304 response indicates an entity not currently cached, then the cache MUST disregard the response\n     * and repeat the request without the conditional.\n     * <p>\n     * If a cache uses a received 304 response to update a cache entry, the cache MUST update the entry to\n     * reflect any new field values given in the response.\n     ",
      "vertexLabel": "EnumConstant NOT_MODIFIED"
    },
    {
      "vertexName": "Method ActionFuture<PendingClusterTasksResponse> pendingClusterTasks(PendingClusterTasksRequest request)  (ClusterAdminClient.java)",
      "children": [
        {
          "name": "Method void pendingClusterTasks(PendingClusterTasksRequest request, ActionListener<PendingClusterTasksResponse> listener)  (ClusterAdminClient.java)"
        }
      ],
      "comment": "\n     * Returns a list of the pending cluster tasks, that are scheduled to be executed. This includes operations\n     * that update the cluster state (for example, a create index operation)\n     ",
      "vertexLabel": "ActionFuture<PendingClusterTasksResponse> pendingClusterTasks()"
    },
    {
      "vertexName": "Method private ShardRouting removeRelocationSource(ShardRouting shard)  (RoutingNodes.java)",
      "comment": "\n     * Removes relocation source of an initializing non-primary shard. This allows the replica shard to continue recovery from\n     * the primary even though its non-primary relocation source has failed.\n     ",
      "vertexLabel": "ShardRouting removeRelocationSource()"
    },
    {
      "vertexName": "Method public ScriptException(String message, Throwable cause, List<String> scriptStack, String script, String lang)  (ScriptException.java)",
      "children": [
        {
          "name": "Class ScriptException  (ScriptException.java)"
        }
      ],
      "comment": "\n     * Create a new ScriptException.\n     * @param message A short and simple summary of what happened, such as \"compile error\".\n     *                Must not be {@code null}.\n     * @param cause The underlying cause of the exception. Must not be {@code null}.\n     * @param scriptStack An implementation-specific \"stacktrace\" for the error in the script.\n     *                Must not be {@code null}, but can be empty (though this should be avoided if possible).\n     * @param script Identifier for which script failed. Must not be {@code null}.\n     * @param lang Scripting engine language, such as \"painless\". Must not be {@code null}.\n     * @throws NullPointerException if any parameters are {@code null}.\n     ",
      "vertexLabel": "ScriptException()"
    },
    {
      "vertexName": "Class BigFloatArray  (BigFloatArray.java)",
      "children": [
        {
          "name": "Class BigByteArray  (BigByteArray.java)"
        }
      ],
      "comment": "\n * Float array abstraction able to support more than 2B values. This implementation slices data into fixed-sized blocks of\n * configurable length.\n ",
      "vertexLabel": "Class BigFloatArray"
    },
    {
      "vertexName": "Method public MultiMatchQueryBuilder maxExpansions(int maxExpansions)  (MultiMatchQueryBuilder.java)",
      "children": [
        {
          "name": "Method public MatchQueryBuilder maxExpansions(int maxExpansions)  (MatchQueryBuilder.java)"
        }
      ],
      "comment": "\n     * When using fuzzy or prefix type query, the number of term expansions to use. Defaults to unbounded\n     * so its recommended to set it to a reasonable value for faster execution.\n     ",
      "vertexLabel": "MultiMatchQueryBuilder maxExpansions()"
    },
    {
      "vertexName": "Class ReindexRequest  (ReindexRequest.java)",
      "children": [
        {
          "name": "Class UpdateByQueryRequest  (UpdateByQueryRequest.java)"
        }
      ],
      "comment": "\n * Request to reindex some documents from one index to another. This implements CompositeIndicesRequest but in a misleading way. Rather than\n * returning all the subrequests that it will make it tries to return a representative set of subrequests. This is best-effort for a bunch\n * of reasons, not least of which that scripts are allowed to change the destination request in drastic ways, including changing the index\n * to which documents are written.\n ",
      "vertexLabel": "Class ReindexRequest"
    },
    {
      "vertexName": "Method public UpdateRequest upsert(XContentBuilder source)  (UpdateRequest.java)",
      "comment": "\n     * Sets the doc source of the update request to be used when the document does not exists.\n     ",
      "vertexLabel": "UpdateRequest upsert()"
    },
    {
      "vertexName": "Method private static ByteSizeValue thresholdBytesFromWatermark(String watermark, String settingName, boolean lenient)  (DiskThresholdSettings.java)",
      "children": [
        {
          "name": "Method private static double thresholdPercentageFromWatermark(String watermark, boolean lenient)  (DiskThresholdSettings.java)"
        }
      ],
      "comment": "\n     * Attempts to parse the watermark into a {@link ByteSizeValue}, returning zero bytes if it can not be parsed and the specified lenient\n     * parameter is true, otherwise throwing an {@link ElasticsearchParseException}.\n     *\n     * @param watermark the watermark to parse as a byte size\n     * @param settingName the name of the setting\n     * @param lenient true if lenient parsing should be applied\n     * @return the parsed byte size value\n     ",
      "vertexLabel": "ByteSizeValue thresholdBytesFromWatermark()"
    },
    {
      "vertexName": "Method public int getPreFilterShardSize()  (SearchRequest.java)",
      "children": [
        {
          "name": "Method public void setPreFilterShardSize(int preFilterShardSize)  (SearchRequest.java)"
        }
      ],
      "comment": "\n     * Returns a threshold that enforces a pre-filter roundtrip to pre-filter search shards based on query rewriting if the number of shards\n     * the search request expands to exceeds the threshold. This filter roundtrip can limit the number of shards significantly if for\n     * instance a shard can not match any documents based on it's rewrite method ie. if date filters are mandatory to match but the shard\n     * bounds and the query are disjoint. The default is {@code 128}\n     ",
      "vertexLabel": "int getPreFilterShardSize()"
    },
    {
      "vertexName": "Method ActionFuture<SearchResponse> searchScroll(SearchScrollRequest request)  (Client.java)",
      "children": [
        {
          "name": "Method SearchScrollRequestBuilder prepareSearchScroll(String scrollId)  (Client.java)"
        }
      ],
      "comment": "\n     * A search scroll request to continue searching a previous scrollable search request.\n     *\n     * @param request The search scroll request\n     * @return The result future\n     * @see Requests#searchScrollRequest(String)\n     ",
      "vertexLabel": "ActionFuture<SearchResponse> searchScroll()"
    },
    {
      "vertexName": "Method public QueryStringQueryParser(QueryShardContext context, boolean lenient)  (QueryStringQueryParser.java)",
      "children": [
        {
          "name": "Method public QueryStringQueryParser(QueryShardContext context, String defaultField, boolean lenient)  (QueryStringQueryParser.java)"
        }
      ],
      "comment": "\n     * Defaults to all queryiable fields extracted from the mapping for query terms\n     * @param context The query shard context\n     * @param lenient If set to `true` will cause format based failures (like providing text to a numeric field) to be ignored.\n     ",
      "vertexLabel": "QueryStringQueryParser()"
    },
    {
      "vertexName": "Method public static boolean terminate(ThreadPool pool, long timeout, TimeUnit timeUnit)  (ThreadPool.java)",
      "comment": "\n     * Returns <code>true</code> if the given pool was terminated successfully. If the termination timed out,\n     * the service is <code>null</code> this method will return <code>false</code>.\n     ",
      "vertexLabel": "boolean terminate()"
    },
    {
      "vertexName": "Method public PipelineAggregationSpec(ParseField name, Writeable.Reader<? extends PipelineAggregationBuilder> builderReader, Writeable.Reader<? extends PipelineAggregator> aggregatorReader, PipelineAggregator.Parser parser)  (SearchPlugin.java)",
      "children": [
        {
          "name": "Method public AggregationSpec(ParseField name, Writeable.Reader<? extends AggregationBuilder> reader, Aggregator.Parser parser)  (SearchPlugin.java)"
        }
      ],
      "comment": "\n         * Specification of a {@link PipelineAggregator}.\n         *\n         * @param name holds the names by which this aggregation might be parsed. The {@link ParseField#getPreferredName()} is special as it\n         *        is the name by under which the readers are registered. So it is the name that the {@link PipelineAggregationBuilder} and\n         *        {@link PipelineAggregator} should return from {@link NamedWriteable#getWriteableName()}.\n         * @param builderReader the reader registered for this aggregation's builder. Typically a reference to a constructor that takes a\n         *        {@link StreamInput}\n         * @param aggregatorReader reads the {@link PipelineAggregator} from a stream\n         * @param parser reads the aggregation builder from XContent\n         ",
      "vertexLabel": "PipelineAggregationSpec()"
    },
    {
      "vertexName": "Method public int getMaxQueryTerms()  (XMoreLikeThis.java)",
      "children": [
        {
          "name": "Method public void setMaxQueryTerms(int maxQueryTerms)  (XMoreLikeThis.java)"
        }
      ],
      "comment": "\n     * Returns the maximum number of query terms that will be included in any generated query.\n     * The default is {@link #DEFAULT_MAX_QUERY_TERMS}.\n     *\n     * @return the maximum number of query terms that will be included in any generated query.\n     ",
      "vertexLabel": "int getMaxQueryTerms()"
    },
    {
      "vertexName": "Method RestoreContext(IndexShard shard, SnapshotId snapshotId, Version version, IndexId indexId, ShardId snapshotShardId, RecoveryState recoveryState)  (BlobStoreRepository.java)",
      "comment": "\n         * Constructs new restore context\n         *\n         * @param shard           shard to restore into\n         * @param snapshotId      snapshot id\n         * @param indexId         id of the index being restored\n         * @param snapshotShardId shard in the snapshot that data should be restored from\n         * @param recoveryState   recovery state to report progress\n         ",
      "vertexLabel": "RestoreContext()"
    },
    {
      "vertexName": "Method public CardinalityAggregationBuilder precisionThreshold(long precisionThreshold)  (CardinalityAggregationBuilder.java)",
      "comment": "\n     * Set a precision threshold. Higher values improve accuracy but also\n     * increase memory usage.\n     ",
      "vertexLabel": "CardinalityAggregationBuilder precisionThreshold()"
    },
    {
      "vertexName": "Method public RestoreSnapshotRequest renamePattern(String renamePattern)  (RestoreSnapshotRequest.java)",
      "comment": "\n     * Sets rename pattern that should be applied to restored indices.\n     * <p>\n     * Indices that match the rename pattern will be renamed according to {@link #renameReplacement(String)}. The\n     * rename pattern is applied according to the {@link java.util.regex.Matcher#appendReplacement(StringBuffer, String)}\n     * The request will fail if two or more indices will be renamed into the same name.\n     *\n     * @param renamePattern rename pattern\n     * @return this request\n     ",
      "vertexLabel": "RestoreSnapshotRequest renamePattern()"
    },
    {
      "vertexName": "Method public MatchQueryBuilder fuzzyTranspositions(boolean fuzzyTranspositions)  (MatchQueryBuilder.java)",
      "comment": "\n     * Sets whether transpositions are supported in fuzzy queries.<p>\n     * The default metric used by fuzzy queries to determine a match is the Damerau-Levenshtein\n     * distance formula which supports transpositions. Setting transposition to false will\n     * switch to classic Levenshtein distance.<br>\n     * If not set, Damerau-Levenshtein distance metric will be used.\n     ",
      "vertexLabel": "MatchQueryBuilder fuzzyTranspositions()"
    },
    {
      "vertexName": "Method public FunctionScoreQueryBuilder(FilterFunctionBuilder[] filterFunctionBuilders)  (FunctionScoreQueryBuilder.java)",
      "comment": "\n     * Creates a function_score query that executes the provided filters and functions on all documents\n     *\n     * @param filterFunctionBuilders the filters and functions\n     ",
      "vertexLabel": "FunctionScoreQueryBuilder()"
    },
    {
      "vertexName": "Method public static InjectionPoint forConstructorOf(TypeLiteral<?> type)  (InjectionPoint.java)",
      "comment": "\n     * Returns a new injection point for the injectable constructor of {@code type}.\n     *\n     * @param type a concrete type with exactly one constructor annotated {@literal @}{@link Inject},\n     *             or a no-arguments constructor that is not private.\n     * @throws ConfigurationException if there is no injectable constructor, more than one injectable\n     *                                constructor, or if parameters of the injectable constructor are malformed, such as a\n     *                                parameter with multiple binding annotations.\n     ",
      "vertexLabel": "InjectionPoint forConstructorOf()"
    },
    {
      "vertexName": "Method public Set<String> selectedFields()  (TermVectorsRequest.java)",
      "comment": "\n     * Return only term vectors for special selected fields. Returns for term\n     * vectors for all fields if selectedFields == null\n     ",
      "vertexLabel": "Set<String> selectedFields()"
    },
    {
      "vertexName": "Method public void setMaxWordLen(int maxWordLen)  (XMoreLikeThis.java)",
      "comment": "\n     * Sets the maximum word length above which words will be ignored.\n     *\n     * @param maxWordLen the maximum word length above which words will be ignored.\n     ",
      "vertexLabel": "void setMaxWordLen()"
    },
    {
      "vertexName": "Class BulkRequestBuilder  (BulkRequestBuilder.java)",
      "comment": "\n * A bulk request holds an ordered {@link IndexRequest}s and {@link DeleteRequest}s and allows to executes\n * it in a single batch.\n ",
      "vertexLabel": "Class BulkRequestBuilder"
    },
    {
      "vertexName": "Method IndexShardSnapshotStatus getShardSnapshotStatus(SnapshotId snapshotId, Version version, IndexId indexId, ShardId shardId)  (Repository.java)",
      "comment": "\n     * Retrieve shard snapshot status for the stored snapshot\n     *\n     * @param snapshotId snapshot id\n     * @param version    version of elasticsearch that created this snapshot\n     * @param indexId    the snapshotted index id for the shard to get status for\n     * @param shardId    shard id\n     * @return snapshot status\n     ",
      "vertexLabel": "IndexShardSnapshotStatus getShardSnapshotStatus()"
    },
    {
      "vertexName": "Method public SearchStats stats(String... groups)  (ShardSearchStats.java)",
      "children": [
        {
          "name": "Method IndexingStats stats(boolean isThrottled, long currentThrottleInMillis, String... types)  (InternalIndexingStats.java)"
        }
      ],
      "comment": "\n     * Returns the stats, including group specific stats. If the groups are null/0 length, then nothing\n     * is returned for them. If they are set, then only groups provided will be returned, or\n     * {@code _all} for all groups.\n     ",
      "vertexLabel": "SearchStats stats()"
    },
    {
      "vertexName": "Method Set<InjectionPoint> getInjectableMembers()  (ConstructorBinding.java)",
      "comment": "\n     * Returns all instance method and field injection points on {@code type}.\n     *\n     * @return a possibly empty set of injection points. The set has a specified iteration order. All\n     *         fields are returned and then all methods. Within the fields, supertype fields are returned\n     *         before subtype fields. Similarly, supertype methods are returned before subtype methods.\n     ",
      "vertexLabel": "Set<InjectionPoint> getInjectableMembers()"
    },
    {
      "vertexName": "Method public MatchQueryBuilder maxExpansions(int maxExpansions)  (MatchQueryBuilder.java)",
      "comment": "\n     * When using fuzzy or prefix type query, the number of term expansions to use.\n     ",
      "vertexLabel": "MatchQueryBuilder maxExpansions()"
    },
    {
      "vertexName": "Method public synchronized void addSettingsUpdateConsumer(Setting<A> a, Setting<B> b, BiConsumer<A, B> consumer, BiConsumer<A, B> validator)  (AbstractScopedSettings.java)",
      "comment": "\n     * Adds a settings consumer that accepts the values for two settings. The consumer is only notified if one or both settings change\n     * and if the provided validator succeeded.\n     * <p>\n     * Note: Only settings registered in {@link SettingsModule} can be changed dynamically.\n     * </p>\n     * This method registers a compound updater that is useful if two settings are depending on each other.\n     * The consumer is always provided with both values even if only one of the two changes.\n     ",
      "vertexLabel": "synchronized void addSettingsUpdateConsumer()"
    },
    {
      "vertexName": "Method public static AllocationId finishRelocation(AllocationId allocationId)  (AllocationId.java)",
      "children": [
        {
          "name": "Method public static AllocationId cancelRelocation(AllocationId allocationId)  (AllocationId.java)"
        }
      ],
      "comment": "\n     * Creates a new allocation id finalizing a relocation.\n     * <p>\n     * Note that this is expected to be called on the allocation id\n     * of the *target* shard and thus it only needs to clear the relocating id.\n     ",
      "vertexLabel": "AllocationId finishRelocation()"
    },
    {
      "vertexName": "Method void onResponse(Task task, Response response)  (TaskListener.java)",
      "children": [
        {
          "name": "Method void onResponse(Response response)  (ActionListener.java)"
        },
        {
          "name": "Method void onFailure(Task task, Throwable e)  (TaskListener.java)"
        }
      ],
      "comment": "\n     * Handle task response. This response may constitute a failure or a success\n     * but it is up to the listener to make that decision.\n     *\n     * @param task\n     *            the task being executed. May be null if the action doesn't\n     *            create a task\n     * @param response\n     *            the response from the action that executed the task\n     ",
      "vertexLabel": "void onResponse()"
    },
    {
      "vertexName": "Method public Index concreteSingleIndex(ClusterState state, IndicesRequest request)  (IndexNameExpressionResolver.java)",
      "children": [
        {
          "name": "Method public Index concreteWriteIndex(ClusterState state, IndicesRequest request)  (IndexNameExpressionResolver.java)"
        }
      ],
      "comment": "\n     * Utility method that allows to resolve an index expression to its corresponding single concrete index.\n     * Callers should make sure they provide proper {@link org.elasticsearch.action.support.IndicesOptions}\n     * that require a single index as a result. The indices resolution must in fact return a single index when\n     * using this method, an {@link IllegalArgumentException} gets thrown otherwise.\n     *\n     * @param state             the cluster state containing all the data to resolve to expression to a concrete index\n     * @param request           The request that defines how the an alias or an index need to be resolved to a concrete index\n     *                          and the expression that can be resolved to an alias or an index name.\n     * @throws IllegalArgumentException if the index resolution lead to more than one index\n     * @return the concrete index obtained as a result of the index resolution\n     ",
      "vertexLabel": "Index concreteSingleIndex()"
    },
    {
      "vertexName": "Method public QueryStringQueryParser(QueryShardContext context, Map<String, Float> fieldsAndWeights)  (QueryStringQueryParser.java)",
      "comment": "\n     * @param context The query shard context\n     * @param fieldsAndWeights The default fields and weights expansion for query terms\n     ",
      "vertexLabel": "QueryStringQueryParser()"
    },
    {
      "vertexName": "Method public NodeUsage(DiscoveryNode node, long timestamp, long sinceTime, Map<String, Long> restUsage)  (NodeUsage.java)",
      "children": [
        {
          "name": "Method public Map<String, Long> getRestUsage()  (NodeUsage.java)"
        }
      ],
      "comment": "\n     * @param node\n     *            the node these statistics were collected from\n     * @param timestamp\n     *            the timestamp for when these statistics were collected\n     * @param sinceTime\n     *            the timestamp for when the collection of these statistics\n     *            started\n     * @param restUsage\n     *            a map containing the counts of the number of times each REST\n     *            endpoint has been called\n     ",
      "vertexLabel": "NodeUsage()"
    },
    {
      "vertexName": "Method public T lookup(String name, XContentLocation xContentLocation, DeprecationHandler deprecationHandler)  (ParseFieldRegistry.java)",
      "comment": "\n     * Lookup a value from the registry by name while checking that the name matches the ParseField.\n     *\n     * @param name The name of the thing to look up.\n     * @return The value being looked up. Never null.\n     * @throws ParsingException if the named thing isn't in the registry or the name was deprecated and deprecated names aren't supported.\n     ",
      "vertexLabel": "T lookup()"
    },
    {
      "vertexName": "Method public String getLocalNodeId()  (NodeClient.java)",
      "children": [
        {
          "name": "Field localNodeId  (NodeClient.java)"
        }
      ],
      "comment": "\n     * The id of the local {@link DiscoveryNode}. Useful for generating task ids from tasks returned by\n     * {@link #executeLocally(Action, ActionRequest, TaskListener)}.\n     ",
      "vertexLabel": "String getLocalNodeId()"
    },
    {
      "vertexName": "Method long phase2(final long startingSeqNo, long requiredSeqNoRangeStart, long endingSeqNo, final Translog.Snapshot snapshot, final long maxSeenAutoIdTimestamp, final long maxSeqNoOfUpdatesOrDeletes) throws IOException  (RecoverySourceHandler.java)",
      "comment": "\n     * Perform phase two of the recovery process.\n     * <p>\n     * Phase two uses a snapshot of the current translog *without* acquiring the write lock (however, the translog snapshot is\n     * point-in-time view of the translog). It then sends each translog operation to the target node so it can be replayed into the new\n     * shard.\n     *\n     * @param startingSeqNo              the sequence number to start recovery from, or {@link SequenceNumbers#UNASSIGNED_SEQ_NO} if all\n     *                                   ops should be sent\n     * @param requiredSeqNoRangeStart    the lower sequence number of the required range (ending with endingSeqNo)\n     * @param endingSeqNo                the highest sequence number that should be sent\n     * @param snapshot                   a snapshot of the translog\n     * @param maxSeenAutoIdTimestamp     the max auto_id_timestamp of append-only requests on the primary\n     * @param maxSeqNoOfUpdatesOrDeletes the max seq_no of updates or deletes on the primary after these operations were executed on it.\n     * @return the local checkpoint on the target\n     ",
      "vertexLabel": "long phase2()"
    },
    {
      "vertexName": "Method public abstract T readBlob(BlobContainer blobContainer, String blobName) throws IOException  (BlobStoreFormat.java)",
      "comment": "\n     * Reads and parses the blob with given blob name.\n     *\n     * @param blobContainer blob container\n     * @param blobName blob name\n     * @return parsed blob object\n     ",
      "vertexLabel": "abstract T readBlob()"
    },
    {
      "vertexName": "Method static void check(final BootstrapContext context, final boolean enforceLimits, final List<BootstrapCheck> checks) throws NodeValidationException  (BootstrapChecks.java)",
      "children": [
        {
          "name": "Method static void check(final BootstrapContext context, final BoundTransportAddress boundTransportAddress, List<BootstrapCheck> additionalChecks) throws NodeValidationException  (BootstrapChecks.java)"
        }
      ],
      "comment": "\n     * Executes the provided checks and fails the node if {@code enforceLimits} is {@code true}, otherwise logs warnings. If the system\n     * property {@code es.enforce.bootstrap.checks} is set to {@code true} then the bootstrap checks will be enforced regardless of whether\n     * or not the transport protocol is bound to a non-loopback interface.\n     *\n     * @param context        the current node boostrap context\n     * @param enforceLimits {@code true} if the checks should be enforced or otherwise warned\n     * @param checks        the checks to execute\n     ",
      "vertexLabel": "void check()"
    },
    {
      "vertexName": "Method long getNumDocUpdates()  (InternalEngine.java)",
      "comment": "\n     * Returns the number of documents have been updated since this engine was opened.\n     * This count does not include the updates from the existing segments before opening engine.\n     ",
      "vertexLabel": "long getNumDocUpdates()"
    },
    {
      "vertexName": "Method public abstract boolean advanceExact(int doc) throws IOException  (GeoPointValues.java)",
      "children": [
        {
          "name": "Method public abstract boolean advanceExact(int doc) throws IOException  (SortedBinaryDocValues.java)"
        }
      ],
      "comment": "\n     * Advance this instance to the given document id\n     * @return true if there is a value for this document\n     ",
      "vertexLabel": "abstract boolean advanceExact()"
    },
    {
      "vertexName": "Method public void incomingRequest(final HttpRequest httpRequest, final HttpChannel httpChannel)  (AbstractHttpServerTransport.java)",
      "comment": "\n     * This method handles an incoming http request.\n     *\n     * @param httpRequest that is incoming\n     * @param httpChannel that received the http request\n     ",
      "vertexLabel": "void incomingRequest()"
    },
    {
      "vertexName": "Method public String[] getDocTypes()  (UpdateByQueryRequest.java)",
      "children": [
        {
          "name": "Method public String[] getDocTypes()  (DeleteByQueryRequest.java)"
        }
      ],
      "comment": "\n     * Gets the document types on which this request would be executed. Returns an empty array if all\n     * types are to be processed.\n     ",
      "vertexLabel": "String[] getDocTypes()"
    },
    {
      "vertexName": "Method public static int copy(Reader in, Writer out) throws IOException  (Streams.java)",
      "children": [
        {
          "name": "Method public static String copyToString(Reader in) throws IOException  (Streams.java)"
        },
        {
          "name": "Method public static void copy(String in, Writer out) throws IOException  (Streams.java)"
        }
      ],
      "comment": "\n     * Copy the contents of the given Reader to the given Writer.\n     * Closes both when done.\n     *\n     * @param in  the Reader to copy from\n     * @param out the Writer to copy to\n     * @return the number of characters copied\n     * @throws IOException in case of I/O errors\n     ",
      "vertexLabel": "int copy()"
    },
    {
      "vertexName": "Method public Builder put(String setting, float value)  (Settings.java)",
      "children": [
        {
          "name": "Method public Builder put(String setting, int value)  (Settings.java)"
        }
      ],
      "comment": "\n         * Sets the setting with the provided setting key and the float value.\n         *\n         * @param setting The setting key\n         * @param value   The float value\n         * @return The builder\n         ",
      "vertexLabel": "Builder put()"
    },
    {
      "vertexName": "Method public void updateLocalCheckpointForShard(final String allocationId, final long checkpoint)  (IndexShard.java)",
      "children": [
        {
          "name": "Method public void markAllocationIdAsInSync(final String allocationId, final long localCheckpoint) throws InterruptedException  (IndexShard.java)"
        }
      ],
      "comment": "\n     * Notifies the service to update the local checkpoint for the shard with the provided allocation ID. See\n     * {@link ReplicationTracker#updateLocalCheckpoint(String, long)} for\n     * details.\n     *\n     * @param allocationId the allocation ID of the shard to update the local checkpoint for\n     * @param checkpoint   the local checkpoint for the shard\n     ",
      "vertexLabel": "void updateLocalCheckpointForShard()"
    },
    {
      "vertexName": "Method public SearchRequestBuilder setRequestCache(Boolean requestCache)  (SearchRequestBuilder.java)",
      "children": [
        {
          "name": "Method public SearchRequest requestCache(Boolean requestCache)  (SearchRequest.java)"
        }
      ],
      "comment": "\n     * Sets if this request should use the request cache or not, assuming that it can (for\n     * example, if \"now\" is used, it will never be cached). By default (not set, or null,\n     * will default to the index level setting if request cache is enabled or not).\n     ",
      "vertexLabel": "SearchRequestBuilder setRequestCache()"
    },
    {
      "vertexName": "Method Query toQuery(QueryShardContext context) throws IOException  (QueryBuilder.java)",
      "comment": "\n     * Converts this QueryBuilder to a lucene {@link Query}.\n     * Returns {@code null} if this query should be ignored in the context of\n     * parent queries.\n     *\n     * @param context additional information needed to construct the queries\n     * @return the {@link Query} or {@code null} if this query should be ignored upstream\n     ",
      "vertexLabel": "Query toQuery()"
    },
    {
      "vertexName": "Method public static OverriddenModuleBuilder override(Iterable<? extends Module> modules)  (Modules.java)",
      "children": [
        {
          "name": "Method public static OverriddenModuleBuilder override(Module... modules)  (Modules.java)"
        }
      ],
      "comment": "\n     * Returns a builder that creates a module that overlays override modules over the given\n     * modules. If a key is bound in both sets of modules, only the binding from the override modules\n     * is kept. This can be used to replace the bindings of a production module with test bindings:\n     * <pre>\n     * Module functionalTestModule\n     *     = Modules.override(getProductionModules()).with(getTestModules());\n     * </pre>\n     * <p>\n     * Prefer to write smaller modules that can be reused and tested without overrides.\n     *\n     * @param modules the modules whose bindings are open to be overridden\n     ",
      "vertexLabel": "OverriddenModuleBuilder override()"
    },
    {
      "vertexName": "Method public static MapBinder<K, V> newMapBinder(Binder binder, Class<K> keyType, Class<V> valueType)  (MapBinder.java)",
      "children": [
        {
          "name": "Method public static MapBinder<K, V> newMapBinder(Binder binder, TypeLiteral<K> keyType, TypeLiteral<V> valueType)  (MapBinder.java)"
        }
      ],
      "comment": "\n     * Returns a new mapbinder that collects entries of {@code keyType}/{@code valueType} in a\n     * {@link Map} that is itself bound with no binding annotation.\n     ",
      "vertexLabel": "MapBinder<K, V> newMapBinder()"
    },
    {
      "vertexName": "Method public Builder updateNumberOfReplicas(final int numberOfReplicas, final String[] indices)  (RoutingTable.java)",
      "comment": "\n         * Update the number of replicas for the specified indices.\n         *\n         * @param numberOfReplicas the number of replicas\n         * @param indices          the indices to update the number of replicas for\n         * @return the builder\n         ",
      "vertexLabel": "Builder updateNumberOfReplicas()"
    },
    {
      "vertexName": "Method public abstract boolean advanceExact(int doc) throws IOException  (SortedBinaryDocValues.java)",
      "comment": "\n     * Advance this instance to the given document id\n     * @return true if there is a value for this document\n     ",
      "vertexLabel": "abstract boolean advanceExact()"
    },
    {
      "vertexName": "Method public MovAvgPipelineAggregationBuilder modelBuilder(MovAvgModelBuilder model)  (MovAvgPipelineAggregationBuilder.java)",
      "children": [
        {
          "name": "Method public MovAvgModel model()  (MovAvgPipelineAggregationBuilder.java)"
        }
      ],
      "comment": "\n     * Sets a MovAvgModel for the Moving Average. The model is used to\n     * define what type of moving average you want to use on the series\n     *\n     * @param model\n     *            A MovAvgModel which has been prepopulated with settings\n     ",
      "vertexLabel": "MovAvgPipelineAggregationBuilder modelBuilder()"
    },
    {
      "vertexName": "Method public void deprecated(String msg, Object... params)  (DeprecationLogger.java)",
      "comment": "\n     * Logs a deprecation message, adding a formatted warning message as a response header on the thread context.\n     ",
      "vertexLabel": "void deprecated()"
    },
    {
      "vertexName": "Method protected abstract ShardsIterator shards(ClusterState clusterState, Request request, String[] concreteIndices)  (TransportBroadcastByNodeAction.java)",
      "children": [
        {
          "name": "Method protected abstract ClusterBlockException checkRequestBlock(ClusterState state, Request request, String[] concreteIndices)  (TransportBroadcastByNodeAction.java)"
        }
      ],
      "comment": "\n     * Determines the shards on which this operation will be executed on. The operation is executed once per shard.\n     *\n     * @param clusterState    the cluster state\n     * @param request         the underlying request\n     * @param concreteIndices the concrete indices on which to execute the operation\n     * @return the shards on which to execute the operation\n     ",
      "vertexLabel": "abstract ShardsIterator shards()"
    },
    {
      "vertexName": "Method public IndexRequestBuilder setRouting(String routing)  (IndexRequestBuilder.java)",
      "children": [
        {
          "name": "Method public GetRequest routing(String routing)  (GetRequest.java)"
        }
      ],
      "comment": "\n     * Controls the shard routing of the request. Using this value to hash the shard\n     * and not the id.\n     ",
      "vertexLabel": "IndexRequestBuilder setRouting()"
    },
    {
      "vertexName": "Method public int getBatchedReduceSize()  (SearchRequest.java)",
      "children": [
        {
          "name": "Method public void setBatchedReduceSize(int batchedReduceSize)  (SearchRequest.java)"
        }
      ],
      "comment": "\n     * Returns the number of shard results that should be reduced at once on the coordinating node. This value should be used as a\n     * protection mechanism to reduce the memory overhead per search request if the potential number of shards in the request can be large.\n     ",
      "vertexLabel": "int getBatchedReduceSize()"
    },
    {
      "vertexName": "Method public IndexRequestBuilder setSource(String source, XContentType xContentType)  (IndexRequestBuilder.java)",
      "children": [
        {
          "name": "Method public IndexRequest source(String source, XContentType xContentType)  (IndexRequest.java)"
        }
      ],
      "comment": "\n     * Sets the document source to index.\n     * <p>\n     * Note, its preferable to either set it using {@link #setSource(org.elasticsearch.common.xcontent.XContentBuilder)}\n     * or using the {@link #setSource(byte[], XContentType)}.\n     ",
      "vertexLabel": "IndexRequestBuilder setSource()"
    },
    {
      "vertexName": "Method public static ShardPath loadShardPath(Logger logger, NodeEnvironment env, ShardId shardId, IndexSettings indexSettings) throws IOException  (ShardPath.java)",
      "comment": "\n     * This method walks through the nodes shard paths to find the data and state path for the given shard. If multiple\n     * directories with a valid shard state exist the one with the highest version will be used.\n     * <b>Note:</b> this method resolves custom data locations for the shard.\n     ",
      "vertexLabel": "ShardPath loadShardPath()"
    },
    {
      "vertexName": "Method public abstract String explainConflictForReads(long currentVersion, long expectedVersion)  (VersionType.java)",
      "children": [
        {
          "name": "Method public abstract boolean isVersionConflictForReads(long currentVersion, long expectedVersion)  (VersionType.java)"
        }
      ],
      "comment": "\n     * Returns a human readable explanation for a version conflict on read.\n     *\n     * Note that this method is only called if {@link #isVersionConflictForReads(long, long)} returns true;\n     *\n     * @param currentVersion  the current version for the document\n     * @param expectedVersion the version specified for the read operation\n     ",
      "vertexLabel": "abstract String explainConflictForReads()"
    },
    {
      "vertexName": "Method private CreateIndexRequest mapping(String type, BytesReference source, XContentType xContentType)  (CreateIndexRequest.java)",
      "children": [
        {
          "name": "Method public CreateIndexRequest mapping(String type, String source, XContentType xContentType)  (CreateIndexRequest.java)"
        }
      ],
      "comment": "\n     * Adds mapping that will be added when the index gets created.\n     *\n     * @param type   The mapping type\n     * @param source The mapping source\n     * @param xContentType the content type of the mapping source\n     ",
      "vertexLabel": "CreateIndexRequest mapping()"
    },
    {
      "vertexName": "Method void nodesHotThreads(NodesHotThreadsRequest request, ActionListener<NodesHotThreadsResponse> listener)  (ClusterAdminClient.java)",
      "comment": "\n     * Returns top N hot-threads samples per node. The hot-threads are only sampled\n     * for the node ids specified in the request.\n     ",
      "vertexLabel": "void nodesHotThreads()"
    },
    {
      "vertexName": "Method public TopHitsAggregationBuilder fetchSource(@Nullable String[] includes, @Nullable String[] excludes)  (TopHitsAggregationBuilder.java)",
      "children": [
        {
          "name": "Method public SearchRequestBuilder setFetchSource(@Nullable String[] includes, @Nullable String[] excludes)  (SearchRequestBuilder.java)"
        }
      ],
      "comment": "\n     * Indicate that _source should be returned with every hit, with an\n     * \"include\" and/or \"exclude\" set which can include simple wildcard\n     * elements.\n     *\n     * @param includes\n     *            An optional list of include (optionally wildcarded)\n     *            pattern to filter the returned _source\n     * @param excludes\n     *            An optional list of exclude (optionally wildcarded)\n     *            pattern to filter the returned _source\n     ",
      "vertexLabel": "TopHitsAggregationBuilder fetchSource()"
    },
    {
      "vertexName": "Method public RestoreSnapshotRequestBuilder setIndexSettings(Settings.Builder settings)  (RestoreSnapshotRequestBuilder.java)",
      "children": [
        {
          "name": "Method public RestoreSnapshotRequestBuilder setIndexSettings(Settings settings)  (RestoreSnapshotRequestBuilder.java)"
        }
      ],
      "comment": "\n     * Sets index settings that should be added or replaced during restore\n     *\n     * @param settings index settings\n     * @return this builder\n     ",
      "vertexLabel": "RestoreSnapshotRequestBuilder setIndexSettings()"
    },
    {
      "vertexName": "EnumConstant PROXY_AUTHENTICATION  (RestStatus.java)",
      "comment": "\n     * This code is similar to 401 (Unauthorized), but indicates that the client must first authenticate itself with\n     * the proxy. The proxy MUST return a Proxy-Authenticate header field (section 14.33) containing a challenge\n     * applicable to the proxy for the requested resource. The client MAY repeat the request with a suitable\n     * Proxy-Authorization header field (section 14.34). HTTP access authentication is explained in\n     * \"HTTP Authentication: Basic and Digest Access Authentication\" [43].\n     ",
      "vertexLabel": "EnumConstant PROXY_AUTHENTICATION"
    },
    {
      "vertexName": "Method public abstract double execute(double weight, ScriptedSimilarity.Query query, ScriptedSimilarity.Field field, ScriptedSimilarity.Term term, ScriptedSimilarity.Doc doc)  (SimilarityScript.java)",
      "children": [
        {
          "name": "Method public abstract double execute(ScriptedSimilarity.Query query, ScriptedSimilarity.Field field, ScriptedSimilarity.Term term)  (SimilarityWeightScript.java)"
        }
      ],
      "comment": " Compute the score.\n     * @param weight weight computed by the {@link SimilarityWeightScript} if any, or 1.\n     * @param query  scoring factors that come from the query\n     * @param field  field-level statistics\n     * @param term   term-level statistics\n     * @param doc    per-document statistics\n     ",
      "vertexLabel": "abstract double execute()"
    },
    {
      "vertexName": "Method public static OpenIndexRequest openIndexRequest(String index)  (Requests.java)",
      "comment": "\n     * Creates an open index request.\n     *\n     * @param index The index to open\n     * @return The delete index request\n     * @see org.elasticsearch.client.IndicesAdminClient#open(org.elasticsearch.action.admin.indices.open.OpenIndexRequest)\n     ",
      "vertexLabel": "OpenIndexRequest openIndexRequest()"
    },
    {
      "vertexName": "Method public static String toString(ToXContent toXContent, boolean pretty, boolean human)  (Strings.java)",
      "children": [
        {
          "name": "Method public static String toString(ToXContent toXContent)  (Strings.java)"
        }
      ],
      "comment": "\n     * Return a {@link String} that is the json representation of the provided {@link ToXContent}.\n     * Wraps the output into an anonymous object if needed. Allows to control whether the outputted\n     * json needs to be pretty printed and human readable.\n     *\n     ",
      "vertexLabel": "String toString()"
    },
    {
      "vertexName": "Method public SliceQuery(String field, int id, int max)  (SliceQuery.java)",
      "comment": "\n     * @param field The name of the field\n     * @param id    The id of the slice\n     * @param max   The maximum number of slices\n     ",
      "vertexLabel": "SliceQuery()"
    },
    {
      "vertexName": "Method public DateHistogramAggregationBuilder keyed(boolean keyed)  (DateHistogramAggregationBuilder.java)",
      "comment": " Set whether to return buckets as a hash or as an array, and return the\n     *  builder so that calls can be chained. ",
      "vertexLabel": "DateHistogramAggregationBuilder keyed()"
    },
    {
      "vertexName": "Method Provider<T> getProvider(Class<T> type)  (Injector.java)",
      "children": [
        {
          "name": "Method Provider<T> getProvider(Key<T> key)  (TypeEncounter.java)"
        }
      ],
      "comment": "\n     * Returns the provider used to obtain instances for the given type. When feasible, avoid\n     * using this method, in favor of having Guice inject your dependencies ahead of time.\n     *\n     * @throws ConfigurationException if this injector cannot find or create the provider.\n     * @see Binder#getProvider(Class) for an alternative that offers up front error detection\n     ",
      "vertexLabel": "Provider<T> getProvider()"
    },
    {
      "vertexName": "Class DisMaxQueryBuilder  (DisMaxQueryBuilder.java)",
      "comment": "\n * A query that generates the union of documents produced by its sub-queries, and that scores each document\n * with the maximum score for that document as produced by any sub-query, plus a tie breaking increment for any\n * additional matching sub-queries.\n ",
      "vertexLabel": "Class DisMaxQueryBuilder"
    },
    {
      "vertexName": "Method public TopHitsAggregationBuilder docValueField(String docValueField)  (TopHitsAggregationBuilder.java)",
      "children": [
        {
          "name": "Method public TopHitsAggregationBuilder docValueField(String docValueField, String format)  (TopHitsAggregationBuilder.java)"
        }
      ],
      "comment": "\n     * Adds a field to load from doc values and return as part of\n     * the search request.\n     ",
      "vertexLabel": "TopHitsAggregationBuilder docValueField()"
    },
    {
      "vertexName": "Method void remove(K key, Consumer<CompletableFuture<Entry<K, V>>> onRemoval)  (Cache.java)",
      "comment": "\n         * remove an entry from the segment\n         *\n         * @param key       the key of the entry to remove from the cache\n         * @param onRemoval a callback for the removed entry\n         ",
      "vertexLabel": "void remove()"
    },
    {
      "vertexName": "Method public String[] storedFields()  (GetRequest.java)",
      "children": [
        {
          "name": "Method public GetRequest storedFields(String... fields)  (GetRequest.java)"
        }
      ],
      "comment": "\n     * Explicitly specify the stored fields that will be returned. By default, the {@code _source}\n     * field will be returned.\n     ",
      "vertexLabel": "String[] storedFields()"
    },
    {
      "vertexName": "Method public static GeoDistanceSortBuilder geoDistanceSort(String fieldName, double lat, double lon)  (SortBuilders.java)",
      "children": [
        {
          "name": "Method public GeoDistanceSortBuilder(String fieldName, GeoPoint... points)  (GeoDistanceSortBuilder.java)"
        }
      ],
      "comment": "\n     * A geo distance based sort.\n     *\n     * @param fieldName The geo point like field name.\n     * @param lat Latitude of the point to create the range distance facets from.\n     * @param lon Longitude of the point to create the range distance facets from.\n     *\n     ",
      "vertexLabel": "GeoDistanceSortBuilder geoDistanceSort()"
    },
    {
      "vertexName": "Method public VType getOrDefault(KType key, VType defaultValue)  (ImmutableOpenMap.java)",
      "comment": "\n     * @return Returns the value associated with the given key or the provided default value if the\n     * key is not associated with any value.\n     ",
      "vertexLabel": "VType getOrDefault()"
    },
    {
      "vertexName": "Method public IndexRequest source(String source, XContentType xContentType)  (IndexRequest.java)",
      "comment": "\n     * Sets the document source to index.\n     *\n     * Note, its preferable to either set it using {@link #source(org.elasticsearch.common.xcontent.XContentBuilder)}\n     * or using the {@link #source(byte[], XContentType)}.\n     ",
      "vertexLabel": "IndexRequest source()"
    },
    {
      "vertexName": "Method public UpdateRequest upsert(IndexRequest upsertRequest)  (UpdateRequest.java)",
      "comment": "\n     * Sets the index request to be used if the document does not exists. Otherwise, a {@link org.elasticsearch.index.engine.DocumentMissingException}\n     * is thrown.\n     ",
      "vertexLabel": "UpdateRequest upsert()"
    },
    {
      "vertexName": "Method public ShardLock shardLock(final ShardId shardId, long lockTimeoutMS) throws ShardLockObtainFailedException  (NodeEnvironment.java)",
      "comment": "\n     * Tries to lock the given shards ID. A shard lock is required to perform any kind of\n     * write operation on a shards data directory like deleting files, creating a new index writer\n     * or recover from a different shard instance into it. If the shard lock can not be acquired\n     * a {@link ShardLockObtainFailedException} is thrown\n     * @param shardId the shard ID to lock\n     * @param lockTimeoutMS the lock timeout in milliseconds\n     * @return the shard lock. Call {@link ShardLock#close()} to release the lock\n     ",
      "vertexLabel": "ShardLock shardLock()"
    },
    {
      "vertexName": "Method public DateRangeAggregationBuilder addUnboundedFrom(String key, DateTime from)  (DateRangeAggregationBuilder.java)",
      "children": [
        {
          "name": "Method public DateRangeAggregationBuilder addUnboundedFrom(String key, String from)  (DateRangeAggregationBuilder.java)"
        }
      ],
      "comment": "\n     * Add a new range with no upper bound.\n     *\n     * @param key\n     *            the key to use for this range in the response\n     * @param from\n     *            the lower bound on the distances, inclusive\n     ",
      "vertexLabel": "DateRangeAggregationBuilder addUnboundedFrom()"
    },
    {
      "vertexName": "Method public static AllocateUnassignedDecision delayed(long remainingDelay, long totalDelay, @Nullable List<NodeAllocationResult> decisions)  (AllocateUnassignedDecision.java)",
      "children": [
        {
          "name": "Method public static AllocateUnassignedDecision no(AllocationStatus allocationStatus, @Nullable List<NodeAllocationResult> decisions)  (AllocateUnassignedDecision.java)"
        }
      ],
      "comment": "\n     * Returns a NO decision for a delayed shard allocation on a replica shard, with the individual node-level\n     * decisions that comprised the final NO decision, if in explain mode.  Instances created with this\n     * method will return {@link AllocationStatus#DELAYED_ALLOCATION} for {@link #getAllocationStatus()}.\n     ",
      "vertexLabel": "AllocateUnassignedDecision delayed()"
    },
    {
      "vertexName": "Method public CreateSnapshotRequestBuilder setIndices(String... indices)  (CreateSnapshotRequestBuilder.java)",
      "children": [
        {
          "name": "Method public CreateSnapshotRequest indices(String... indices)  (CreateSnapshotRequest.java)"
        }
      ],
      "comment": "\n     * Sets a list of indices that should be included into the snapshot\n     * <p>\n     * The list of indices supports multi-index syntax. For example: \"+test*\" ,\"-test42\" will index all indices with\n     * prefix \"test\" except index \"test42\". Aliases are supported. An empty list or {\"_all\"} will snapshot all open\n     * indices in the cluster.\n     *\n     * @return this builder\n     ",
      "vertexLabel": "CreateSnapshotRequestBuilder setIndices()"
    },
    {
      "vertexName": "Method public UpdateRequestBuilder setUpsert(byte[] source, XContentType xContentType)  (UpdateRequestBuilder.java)",
      "children": [
        {
          "name": "Method public UpdateRequest upsert(byte[] source, XContentType xContentType)  (UpdateRequest.java)"
        }
      ],
      "comment": "\n     * Sets the doc source of the update request to be used when the document does not exists.\n     ",
      "vertexLabel": "UpdateRequestBuilder setUpsert()"
    },
    {
      "vertexName": "Method private static CoordinateNode parseCoordinates(XContentParser parser, boolean ignoreZValue) throws IOException  (GeoJsonParser.java)",
      "children": [
        {
          "name": "Method static GeometryCollectionBuilder parseGeometries(XContentParser parser, GeoShapeFieldMapper mapper) throws IOException  (GeoJsonParser.java)"
        }
      ],
      "comment": "\n     * Recursive method which parses the arrays of coordinates used to define\n     * Shapes\n     *\n     * @param parser\n     *            Parser that will be read from\n     * @return CoordinateNode representing the start of the coordinate tree\n     * @throws IOException\n     *             Thrown if an error occurs while reading from the\n     *             XContentParser\n     ",
      "vertexLabel": "CoordinateNode parseCoordinates()"
    },
    {
      "vertexName": "Method public CreateIndexRequestBuilder addMapping(String type, Object... source)  (CreateIndexRequestBuilder.java)",
      "children": [
        {
          "name": "Method public CreateIndexRequest mapping(String type, Object... source)  (CreateIndexRequest.java)"
        }
      ],
      "comment": "\n     * A specialized simplified mapping source method, takes the form of simple properties definition:\n     * (\"field1\", \"type=string,store=true\").\n     ",
      "vertexLabel": "CreateIndexRequestBuilder addMapping()"
    },
    {
      "vertexName": "Method ActionFuture<TermVectorsResponse> termVector(TermVectorsRequest request)  (Client.java)",
      "children": [
        {
          "name": "Method ActionFuture<TermVectorsResponse> termVectors(TermVectorsRequest request)  (Client.java)"
        }
      ],
      "comment": "\n     * An action that returns the term vectors for a specific document.\n     *\n     * @param request The term vector request\n     * @return The response future\n     ",
      "vertexLabel": "ActionFuture<TermVectorsResponse> termVector()"
    },
    {
      "vertexName": "Field gamma  (HoltWintersModel.java)",
      "children": [
        {
          "name": "Field beta  (HoltLinearModel.java)"
        }
      ],
      "comment": "\n     * Controls smoothing of seasonality.\n     * Gamma = 1 retains no memory of past values\n     * (e.g. random walk), while alpha = 0 retains infinite memory of past values (e.g.\n     * mean of the series).\n     ",
      "vertexLabel": "Field gamma"
    },
    {
      "vertexName": "Method T getInstance(Key<T> key)  (Injector.java)",
      "children": [
        {
          "name": "Method Provider<T> getProvider(Key<T> key)  (Injector.java)"
        }
      ],
      "comment": "\n     * Returns the appropriate instance for the given injection key; equivalent to {@code\n     * getProvider(key).get()}. When feasible, avoid using this method, in favor of having Guice\n     * inject your dependencies ahead of time.\n     *\n     * @throws ConfigurationException if this injector cannot find or create the provider.\n     * @throws ProvisionException     if there was a runtime failure while providing an instance.\n     ",
      "vertexLabel": "T getInstance()"
    },
    {
      "vertexName": "Method public static Setting<ByteSizeValue> memorySizeSetting(String key, Function<Settings, String> defaultValue, Property... properties)  (Setting.java)",
      "children": [
        {
          "name": "Method public static Setting<ByteSizeValue> memorySizeSetting(String key, ByteSizeValue defaultValue, Property... properties)  (Setting.java)"
        }
      ],
      "comment": "\n     * Creates a setting which specifies a memory size. This can either be\n     * specified as an absolute bytes value or as a percentage of the heap\n     * memory.\n     *\n     * @param key the key for the setting\n     * @param defaultValue a function that supplies the default value for this setting\n     * @param properties properties properties for this setting like scope, filtering...\n     * @return the setting object\n     ",
      "vertexLabel": "Setting<ByteSizeValue> memorySizeSetting()"
    },
    {
      "vertexName": "Method public MoreLikeThisQueryBuilder maxQueryTerms(int maxQueryTerms)  (MoreLikeThisQueryBuilder.java)",
      "comment": "\n     * Sets the maximum number of query terms that will be included in any generated query.\n     * Defaults to {@code 25}.\n     ",
      "vertexLabel": "MoreLikeThisQueryBuilder maxQueryTerms()"
    },
    {
      "vertexName": "Method public GeoDistanceSortBuilder(String fieldName, String... geohashes)  (GeoDistanceSortBuilder.java)",
      "children": [
        {
          "name": "Method public GeoDistanceSortBuilder(String fieldName, GeoPoint... points)  (GeoDistanceSortBuilder.java)"
        }
      ],
      "comment": "\n     * Constructs a new distance based sort on a geo point like field.\n     *\n     * @param fieldName The geo point like field name.\n     * @param geohashes The points to create the range distance facets from.\n     ",
      "vertexLabel": "GeoDistanceSortBuilder()"
    },
    {
      "vertexName": "Method public String getAllocationId()  (AllocateUnassignedDecision.java)",
      "children": [
        {
          "name": "Method public DiscoveryNode getTargetNode()  (AbstractAllocationDecision.java)"
        }
      ],
      "comment": "\n     * Gets the allocation id for the existing shard copy that the allocator is assigning the shard to.\n     * This method returns a non-null value iff {@link #getTargetNode()} returns a non-null value\n     * and the node on which the shard is assigned already has a shard copy with an in-sync allocation id\n     * that we can re-use.  If {@link #isDecisionTaken()} returns {@code false}, then invoking this method\n     * will throw an {@code IllegalStateException}.\n     ",
      "vertexLabel": "String getAllocationId()"
    },
    {
      "vertexName": "Method public ClusterSearchShardsRequest preference(String preference)  (ClusterSearchShardsRequest.java)",
      "children": [
        {
          "name": "Method public SearchRequest preference(String preference)  (SearchRequest.java)"
        }
      ],
      "comment": "\n     * Sets the preference to execute the search. Defaults to randomize across shards. Can be set to\n     * {@code _local} to prefer local shards or a custom value, which guarantees that the same order\n     * will be used across different requests.\n     ",
      "vertexLabel": "ClusterSearchShardsRequest preference()"
    },
    {
      "vertexName": "Method public NodesStatsRequest(String... nodesIds)  (NodesStatsRequest.java)",
      "comment": "\n     * Get stats from nodes based on the nodes ids specified. If none are passed, stats\n     * for all nodes will be returned.\n     ",
      "vertexLabel": "NodesStatsRequest()"
    },
    {
      "vertexName": "Method void requestInjection(Object instance)  (Binder.java)",
      "comment": "\n     * Upon successful creation, the {@link Injector} will inject instance fields\n     * and methods of the given object.\n     *\n     * @param instance for which members will be injected\n     * @since 2.0\n     ",
      "vertexLabel": "void requestInjection()"
    },
    {
      "vertexName": "Method abstract int compareCurrentWithAfter()  (SingleDimensionValuesSource.java)",
      "children": [
        {
          "name": "Method abstract void copyCurrent(int slot)  (SingleDimensionValuesSource.java)"
        }
      ],
      "comment": "\n     * The current value is filled by a {@link LeafBucketCollector} that visits all the\n     * values of each document. This method compares this current value with the after value\n     * set on this source and should only be used in the context of a collection.\n     * See {@link #getLeafCollector}.\n     ",
      "vertexLabel": "abstract int compareCurrentWithAfter()"
    },
    {
      "vertexName": "Method public Provider<T> getProvider()  (ProviderLookup.java)",
      "comment": "\n     * Returns the looked up provider. The result is not valid until this lookup has been initialized,\n     * which usually happens when the injector is created. The provider will throw an {@code\n     * IllegalStateException} if you try to use it beforehand.\n     ",
      "vertexLabel": "Provider<T> getProvider()"
    },
    {
      "vertexName": "Method AggregationComparator(String path, boolean asc)  (InternalOrder.java)",
      "children": [
        {
          "name": "Method Aggregation(String path, boolean asc)  (InternalOrder.java)"
        }
      ],
      "comment": "\n             * Create a new {@link Bucket} ordering strategy to sort by a sub-aggregation.\n             *\n             * @param path path to the sub-aggregation to sort on.\n             * @param asc  direction to sort by: {@code true} for ascending, {@code false} for descending.\n             * @see AggregationPath\n             ",
      "vertexLabel": "AggregationComparator()"
    },
    {
      "vertexName": "Method public MatchPhraseQueryBuilder zeroTermsQuery(ZeroTermsQuery zeroTermsQuery)  (MatchPhraseQueryBuilder.java)",
      "comment": "\n     * Sets query to use in case no query terms are available, e.g. after analysis removed them.\n     * Defaults to {@link ZeroTermsQuery#NONE}, but can be set to\n     * {@link ZeroTermsQuery#ALL} instead.\n     ",
      "vertexLabel": "MatchPhraseQueryBuilder zeroTermsQuery()"
    },
    {
      "vertexName": "Method public void updateGlobalCheckpointOnReplica(final long globalCheckpoint, final String reason)  (IndexShard.java)",
      "children": [
        {
          "name": "Method public synchronized void updateGlobalCheckpointOnReplica(final long globalCheckpoint, final String reason)  (ReplicationTracker.java)"
        }
      ],
      "comment": "\n     * Updates the global checkpoint on a replica shard after it has been updated by the primary.\n     *\n     * @param globalCheckpoint the global checkpoint\n     * @param reason           the reason the global checkpoint was updated\n     ",
      "vertexLabel": "void updateGlobalCheckpointOnReplica()"
    },
    {
      "vertexName": "Enum Rebalance  (EnableAllocationDecider.java)",
      "comment": "\n     * Rebalance values or rather their string representation to be used used with\n     * {@link EnableAllocationDecider#CLUSTER_ROUTING_REBALANCE_ENABLE_SETTING} /\n     * {@link EnableAllocationDecider#INDEX_ROUTING_REBALANCE_ENABLE_SETTING}\n     * via cluster / index settings.\n     ",
      "vertexLabel": "Enum Rebalance"
    },
    {
      "vertexName": "Method public static TermsQueryBuilder termsQuery(String name, long... values)  (QueryBuilders.java)",
      "children": [
        {
          "name": "Method public static TermsQueryBuilder termsQuery(String name, String... values)  (QueryBuilders.java)"
        }
      ],
      "comment": "\n     * A filer for a field based on several terms matching on any of them.\n     *\n     * @param name   The field name\n     * @param values The terms\n     ",
      "vertexLabel": "TermsQueryBuilder termsQuery()"
    },
    {
      "vertexName": "Method public static double stdDev(double[] values, double avg)  (MovingFunctions.java)",
      "children": [
        {
          "name": "Method public static double unweightedAvg(double[] values)  (MovingFunctions.java)"
        }
      ],
      "comment": "\n     * Calculate a standard deviation over the values using the provided average.\n     *\n     * Only finite values are averaged.  NaN or null are ignored.\n     * If all values are missing/null/NaN, the return value will be NaN.\n     * The average is based on the count of non-null, non-NaN values.\n     ",
      "vertexLabel": "double stdDev()"
    },
    {
      "vertexName": "Method public void addHeader(String key, List<String> value)  (ElasticsearchException.java)",
      "comment": "\n     * Adds a new header with the given key.\n     * This method will replace existing header if a header with the same key already exists\n     ",
      "vertexLabel": "void addHeader()"
    },
    {
      "vertexName": "Method public MultiSearchRequestBuilder add(SearchRequestBuilder request)  (MultiSearchRequestBuilder.java)",
      "children": [
        {
          "name": "Method public MultiSearchRequest add(SearchRequestBuilder request)  (MultiSearchRequest.java)"
        }
      ],
      "comment": "\n     * Add a search request to execute. Note, the order is important, the search response will be returned in the\n     * same order as the search requests.\n     ",
      "vertexLabel": "MultiSearchRequestBuilder add()"
    },
    {
      "vertexName": "Method public DeleteIndexRequestBuilder setIndicesOptions(IndicesOptions options)  (DeleteIndexRequestBuilder.java)",
      "children": [
        {
          "name": "Method public Builder setIndicesOptions(IndicesOptions options)  (BaseAliasesRequestBuilder.java)"
        }
      ],
      "comment": "\n     * Specifies what type of requested indices to ignore and wildcard indices expressions.\n     * <p>\n     * For example indices that don't exist.\n     ",
      "vertexLabel": "DeleteIndexRequestBuilder setIndicesOptions()"
    },
    {
      "vertexName": "Method public final void onModule(NetworkModule module)  (Plugin.java)",
      "children": [
        {
          "name": "Method public final void onModule(ActionModule module)  (Plugin.java)"
        }
      ],
      "comment": "\n     * Old-style network extension point. {@code @Deprecated} and {@code final} to act as a signpost for plugin authors upgrading\n     * from 2.x.\n     *\n     * @deprecated implement {@link NetworkPlugin} instead\n     ",
      "vertexLabel": "final void onModule()"
    },
    {
      "vertexName": "Method T actionGet(TimeValue timeout)  (ActionFuture.java)",
      "children": [
        {
          "name": "Method T actionGet(String timeout)  (ActionFuture.java)"
        }
      ],
      "comment": "\n     * Similar to {@link #get(long, java.util.concurrent.TimeUnit)}, just catching the {@link InterruptedException} and throwing\n     * an {@link IllegalStateException} instead. Also catches\n     * {@link java.util.concurrent.ExecutionException} and throws the actual cause instead.\n     ",
      "vertexLabel": "T actionGet()"
    },
    {
      "vertexName": "Method public SearchRequestBuilder storedFields(String... fields)  (SearchRequestBuilder.java)",
      "children": [
        {
          "name": "Method public SearchRequestBuilder addStoredField(String field)  (SearchRequestBuilder.java)"
        },
        {
          "name": "Method public TopHitsAggregationBuilder storedFields(List<String> fields)  (TopHitsAggregationBuilder.java)"
        }
      ],
      "comment": "\n     * Adds stored fields to load and return (note, it must be stored) as part of the search request.\n     * To disable the stored fields entirely (source and metadata fields) use {@code storedField(\"_none_\")}.\n     ",
      "vertexLabel": "SearchRequestBuilder storedFields()"
    },
    {
      "vertexName": "Method void putMapping(PutMappingRequest request, ActionListener<AcknowledgedResponse> listener)  (IndicesAdminClient.java)",
      "children": [
        {
          "name": "Method ActionFuture<AcknowledgedResponse> putMapping(PutMappingRequest request)  (IndicesAdminClient.java)"
        },
        {
          "name": "Method void delete(DeleteIndexRequest request, ActionListener<AcknowledgedResponse> listener)  (IndicesAdminClient.java)"
        }
      ],
      "comment": "\n     * Add mapping definition for a type into one or more indices.\n     *\n     * @param request  The create mapping request\n     * @param listener A listener to be notified with a result\n     * @see org.elasticsearch.client.Requests#putMappingRequest(String...)\n     ",
      "vertexLabel": "void putMapping()"
    },
    {
      "vertexName": "Method public OpenIndexRequestBuilder setWaitForActiveShards(ActiveShardCount waitForActiveShards)  (OpenIndexRequestBuilder.java)",
      "children": [
        {
          "name": "Method public OpenIndexRequest waitForActiveShards(ActiveShardCount waitForActiveShards)  (OpenIndexRequest.java)"
        }
      ],
      "comment": "\n     * Sets the number of shard copies that should be active for indices opening to return.\n     * Defaults to {@link ActiveShardCount#DEFAULT}, which will wait for one shard copy\n     * (the primary) to become active. Set this value to {@link ActiveShardCount#ALL} to\n     * wait for all shards (primary and all replicas) to be active before returning.\n     * Otherwise, use {@link ActiveShardCount#from(int)} to set this value to any\n     * non-negative integer, up to the number of copies per shard (number of replicas + 1),\n     * to wait for the desired amount of shard copies to become active before returning.\n     * Indices opening will only wait up until the timeout value for the number of shard copies\n     * to be active before returning.  Check {@link OpenIndexResponse#isShardsAcknowledged()} to\n     * determine if the requisite shard copies were all started before returning or timing out.\n     *\n     * @param waitForActiveShards number of active shard copies to wait on\n     ",
      "vertexLabel": "OpenIndexRequestBuilder setWaitForActiveShards()"
    },
    {
      "vertexName": "Field MAX_DOCVALUE_FIELDS_SEARCH_SETTING  (IndexSettings.java)",
      "children": [
        {
          "name": "Field MAX_SCRIPT_FIELDS_SETTING  (IndexSettings.java)"
        }
      ],
      "comment": "\n     * Index setting describing the maximum value of allowed `docvalue_fields`that can be retrieved\n     * per search request. The default maximum of 100 is defensive for the reason that retrieving\n     * doc values might incur a per-field per-document seek.\n     ",
      "vertexLabel": "Field MAX_DOCVALUE_FIELDS_SEARCH_SETTING"
    },
    {
      "vertexName": "Method static ShapeBuilder parse(XContentParser parser, GeoShapeFieldMapper shapeMapper) throws IOException  (ShapeParser.java)",
      "children": [
        {
          "name": "Method static ShapeBuilder parse(XContentParser parser) throws IOException  (ShapeParser.java)"
        }
      ],
      "comment": "\n     * Create a new {@link ShapeBuilder} from {@link XContent}\n     * @param parser parser to read the GeoShape from\n     * @param shapeMapper document field mapper reference required for spatial parameters relevant\n     *                     to the shape construction process (e.g., orientation)\n     *                     todo: refactor to place build specific parameters in the SpatialContext\n     * @return {@link ShapeBuilder} read from the parser or null\n     *          if the parsers current token has been <code>null</code>\n     * @throws IOException if the input could not be read\n     ",
      "vertexLabel": "ShapeBuilder parse()"
    },
    {
      "vertexName": "Method public FuzzyQueryBuilder(String fieldName, boolean value)  (FuzzyQueryBuilder.java)",
      "children": [
        {
          "name": "Method public FuzzyQueryBuilder(String fieldName, String value)  (FuzzyQueryBuilder.java)"
        }
      ],
      "comment": "\n     * Constructs a new fuzzy query.\n     *\n     * @param fieldName  The name of the field\n     * @param value The value of the text\n     ",
      "vertexLabel": "FuzzyQueryBuilder()"
    },
    {
      "vertexName": "Method public InternalSingleBucketAggregation create(InternalAggregations subAggregations)  (InternalSingleBucketAggregation.java)",
      "children": [
        {
          "name": "Method public abstract A create(List<B> buckets)  (InternalMultiBucketAggregation.java)"
        }
      ],
      "comment": "\n     * Create a new copy of this {@link Aggregation} with the same settings as\n     * this {@link Aggregation} and contains the provided sub-aggregations.\n     *\n     * @param subAggregations\n     *            the buckets to use in the new {@link Aggregation}\n     * @return the new {@link Aggregation}\n     ",
      "vertexLabel": "InternalSingleBucketAggregation create()"
    },
    {
      "vertexName": "Method public static String readStringOrIntProperty(String processorType, String processorTag, Map<String, Object> configuration, String propertyName, String defaultValue)  (ConfigurationUtils.java)",
      "children": [
        {
          "name": "Method public static String readStringProperty(String processorType, String processorTag, Map<String, Object> configuration, String propertyName, String defaultValue)  (ConfigurationUtils.java)"
        }
      ],
      "comment": "\n     * Returns and removes the specified property from the specified configuration map.\n     *\n     * If the property value isn't of type string or int a {@link ElasticsearchParseException} is thrown.\n     * If the property is missing and no default value has been specified a {@link ElasticsearchParseException} is thrown\n     ",
      "vertexLabel": "String readStringOrIntProperty()"
    },
    {
      "vertexName": "Class AbstractSortedSetDocValues  (AbstractSortedSetDocValues.java)",
      "children": [
        {
          "name": "Class AbstractBinaryDocValues  (AbstractBinaryDocValues.java)"
        }
      ],
      "comment": "\n * Base implementation that throws an {@link IOException} for the\n * {@link DocIdSetIterator} APIs. This impl is safe to use for sorting and\n * aggregations, which only use {@link #advanceExact(int)} and\n * {@link #getValueCount()} and {@link #nextOrd()} and {@link #lookupOrd(long)}.\n ",
      "vertexLabel": "Class AbstractSortedSetDocValues"
    },
    {
      "vertexName": "Method public AllocateReplicaAllocationCommand(String index, int shardId, String node)  (AllocateReplicaAllocationCommand.java)",
      "comment": "\n     * Creates a new {@link AllocateReplicaAllocationCommand}\n     *\n     * @param index          index of the shard to assign\n     * @param shardId        id of the shard to assign\n     * @param node           node id of the node to assign the shard to\n     ",
      "vertexLabel": "AllocateReplicaAllocationCommand()"
    },
    {
      "vertexName": "Method public static BucketOrder compound(List<BucketOrder> orders)  (BucketOrder.java)",
      "children": [
        {
          "name": "Method CompoundOrder(List<BucketOrder> compoundOrder)  (InternalOrder.java)"
        }
      ],
      "comment": "\n     * Creates a bucket ordering strategy which sorts buckets based on multiple criteria. A tie-breaker may be added to\n     * avoid non-deterministic ordering.\n     *\n     * @param orders a list of {@link BucketOrder} objects to sort on, in order of priority.\n     ",
      "vertexLabel": "BucketOrder compound()"
    },
    {
      "vertexName": "Method void setMergeResults(boolean mergeResults)  (FieldCapabilitiesRequest.java)",
      "children": [
        {
          "name": "Method boolean isMergeResults()  (FieldCapabilitiesRequest.java)"
        }
      ],
      "comment": "\n     * If set to <code>true</code> the response will contain only a merged view of the per index field capabilities.\n     * Otherwise only unmerged per index field capabilities are returned.\n     *\n     * Note that when using the high-level REST client, results are always merged (this flag is always considered 'true').\n     ",
      "vertexLabel": "void setMergeResults()"
    },
    {
      "vertexName": "Field REST_EXCEPTION_SKIP_CAUSE  (ElasticsearchException.java)",
      "comment": "\n     * Passed in the {@link Params} of {@link #generateThrowableXContent(XContentBuilder, Params, Throwable)}\n     * to control if the {@code caused_by} element should render. Unlike most parameters to {@code toXContent} methods this parameter is\n     * internal only and not available as a URL parameter.\n     ",
      "vertexLabel": "Field REST_EXCEPTION_SKIP_CAUSE"
    },
    {
      "vertexName": "Method public CommonTermsQueryBuilder highFreqMinimumShouldMatch(String highFreqMinimumShouldMatch)  (CommonTermsQueryBuilder.java)",
      "children": [
        {
          "name": "Method public CommonTermsQueryBuilder lowFreqMinimumShouldMatch(String lowFreqMinimumShouldMatch)  (CommonTermsQueryBuilder.java)"
        }
      ],
      "comment": "\n     * Sets the minimum number of high frequent query terms that need to match in order to\n     * produce a hit when there are no low frequent terms.\n     ",
      "vertexLabel": "CommonTermsQueryBuilder highFreqMinimumShouldMatch()"
    },
    {
      "vertexName": "Method protected Key(Class<? extends Annotation> annotationType)  (Key.java)",
      "children": [
        {
          "name": "Method protected Key()  (Key.java)"
        }
      ],
      "comment": "\n     * Constructs a new key. Derives the type from this class's type parameter.\n     * <p>\n     * Clients create an empty anonymous subclass. Doing so embeds the type\n     * parameter in the anonymous class's type hierarchy so we can reconstitute it\n     * at runtime despite erasure.\n     * <p>\n     * Example usage for a binding of type {@code Foo} annotated with\n     * {@code @Bar}:\n     * <p>\n     * {@code new Key<Foo>(Bar.class) {}}.\n     ",
      "vertexLabel": "Key()"
    },
    {
      "vertexName": "Method MembersInjector<T> getMembersInjector(Class<T> type)  (Injector.java)",
      "children": [
        {
          "name": "Method MembersInjector<T> getMembersInjector(TypeLiteral<T> typeLiteral)  (Injector.java)"
        },
        {
          "name": "Method Provider<T> getProvider(Class<T> type)  (Injector.java)"
        }
      ],
      "comment": "\n     * Returns the members injector used to inject dependencies into methods and fields on instances\n     * of the given type {@code T}. When feasible, use {@link Binder#getMembersInjector(TypeLiteral)}\n     * instead to get increased up front error detection.\n     *\n     * @param type type to get members injector for\n     * @see Binder#getMembersInjector(Class) for an alternative that offers up front error\n     *      detection\n     * @since 2.0\n     ",
      "vertexLabel": "MembersInjector<T> getMembersInjector()"
    },
    {
      "vertexName": "Class InjectionRequest  (InjectionRequest.java)",
      "comment": "\n * A request to inject the instance fields and methods of an instance. Requests are created\n * explicitly in a module using {@link org.elasticsearch.common.inject.Binder#requestInjection(Object)\n * requestInjection()} statements:\n * <pre>\n *     requestInjection(serviceInstance);</pre>\n *\n * @author mikeward@google.com (Mike Ward)\n * @since 2.0\n ",
      "vertexLabel": "Class InjectionRequest"
    },
    {
      "vertexName": "Method public static ScriptSortBuilder fromXContent(XContentParser parser, String elementName)  (ScriptSortBuilder.java)",
      "children": [
        {
          "name": "Method public static FieldSortBuilder fromXContent(XContentParser parser, String fieldName) throws IOException  (FieldSortBuilder.java)"
        }
      ],
      "comment": "\n     * Creates a new {@link ScriptSortBuilder} from the query held by the {@link XContentParser} in\n     * {@link org.elasticsearch.common.xcontent.XContent} format.\n     *\n     * @param parser the input parser. The state on the parser contained in this context will be changed as a side effect of this\n     *        method call\n     * @param elementName in some sort syntax variations the field name precedes the xContent object that specifies further parameters, e.g.\n     *        in '{ \"foo\": { \"order\" : \"asc\"} }'. When parsing the inner object, the field name can be passed in via this argument\n     ",
      "vertexLabel": "ScriptSortBuilder fromXContent()"
    },
    {
      "vertexName": "Method public abstract LinkedBindingBuilder<V> addBinding(K key)  (MapBinder.java)",
      "comment": "\n     * Returns a binding builder used to add a new entry in the map. Each\n     * key must be distinct (and non-null). Bound providers will be evaluated each\n     * time the map is injected.\n     * <p>\n     * It is an error to call this method without also calling one of the\n     * {@code to} methods on the returned binding builder.\n     * <p>\n     * Scoping elements independently is supported. Use the {@code in} method\n     * to specify a binding scope.\n     ",
      "vertexLabel": "abstract LinkedBindingBuilder<V> addBinding()"
    },
    {
      "vertexName": "Method public synchronized void markAllocationIdAsInSync(final String allocationId, final long localCheckpoint) throws InterruptedException  (ReplicationTracker.java)",
      "children": [
        {
          "name": "Method public void markAllocationIdAsInSync(final String allocationId, final long localCheckpoint) throws InterruptedException  (IndexShard.java)"
        }
      ],
      "comment": "\n     * Marks the shard with the provided allocation ID as in-sync with the primary shard. This method will block until the local checkpoint\n     * on the specified shard advances above the current global checkpoint.\n     *\n     * @param allocationId    the allocation ID of the shard to mark as in-sync\n     * @param localCheckpoint the current local checkpoint on the shard\n     ",
      "vertexLabel": "synchronized void markAllocationIdAsInSync()"
    },
    {
      "vertexName": "Method public static Matcher<AnnotatedElement> annotatedWith(final Annotation annotation)  (Matchers.java)",
      "children": [
        {
          "name": "Method public static Matcher<AnnotatedElement> annotatedWith(final Class<? extends Annotation> annotationType)  (Matchers.java)"
        }
      ],
      "comment": "\n     * Returns a matcher which matches elements (methods, classes, etc.)\n     * with a given annotation.\n     ",
      "vertexLabel": "Matcher<AnnotatedElement> annotatedWith()"
    },
    {
      "vertexName": "Method public static BucketOrder aggregation(String path, boolean asc)  (BucketOrder.java)",
      "children": [
        {
          "name": "Method Aggregation(String path, boolean asc)  (InternalOrder.java)"
        },
        {
          "name": "Method public static BucketOrder count(boolean asc)  (BucketOrder.java)"
        }
      ],
      "comment": "\n     * Creates a bucket ordering strategy which sorts buckets based on a single-valued sub-aggregation.\n     *\n     * @param path path to the sub-aggregation to sort on.\n     * @param asc  direction to sort by: {@code true} for ascending, {@code false} for descending.\n     * @see AggregationPath\n     ",
      "vertexLabel": "BucketOrder aggregation()"
    },
    {
      "vertexName": "Method public boolean ignoreUnmapped()  (GeoBoundingBoxQueryBuilder.java)",
      "children": [
        {
          "name": "Method public boolean ignoreUnmapped()  (NestedQueryBuilder.java)"
        }
      ],
      "comment": "\n     * Gets whether the query builder will ignore unmapped fields (and run a\n     * {@link MatchNoDocsQuery} in place of this query) or throw an exception if\n     * the field is unmapped.\n     ",
      "vertexLabel": "boolean ignoreUnmapped()"
    },
    {
      "vertexName": "Method public String[] getDocTypes()  (DeleteByQueryRequest.java)",
      "comment": "\n     * Gets the document types on which this request would be executed. Returns an empty array if all\n     * types are to be processed.\n     ",
      "vertexLabel": "String[] getDocTypes()"
    },
    {
      "vertexName": "Method static ClusterStateTaskConfig build(Priority priority, TimeValue timeout)  (ClusterStateTaskConfig.java)",
      "children": [
        {
          "name": "Method static ClusterStateTaskConfig build(Priority priority)  (ClusterStateTaskConfig.java)"
        }
      ],
      "comment": "\n     * Build a cluster state update task configuration with the\n     * specified {@link Priority} and timeout.\n     *\n     * @param priority the priority for the associated cluster state\n     *                 update task\n     * @param timeout  the timeout for the associated cluster state\n     *                 update task\n     * @return the result cluster state update task configuration\n     ",
      "vertexLabel": "ClusterStateTaskConfig build()"
    },
    {
      "vertexName": "Method public void writeAtomic(T obj, BlobContainer blobContainer, String name) throws IOException  (ChecksumBlobStoreFormat.java)",
      "children": [
        {
          "name": "Method public void write(T obj, BlobContainer blobContainer, String name) throws IOException  (ChecksumBlobStoreFormat.java)"
        }
      ],
      "comment": "\n     * Writes blob in atomic manner with resolving the blob name using {@link #blobName} method.\n     * <p>\n     * The blob will be compressed and checksum will be written if required.\n     *\n     * Atomic move might be very inefficient on some repositories. It also cannot override existing files.\n     *\n     * @param obj           object to be serialized\n     * @param blobContainer blob container\n     * @param name          blob name\n     ",
      "vertexLabel": "void writeAtomic()"
    },
    {
      "vertexName": "Method public PutIndexTemplateRequest mapping(String type, Map<String, Object> source)  (PutIndexTemplateRequest.java)",
      "children": [
        {
          "name": "Method public CreateIndexRequest mapping(String type, XContentBuilder source)  (CreateIndexRequest.java)"
        }
      ],
      "comment": "\n     * Adds mapping that will be added when the index gets created.\n     *\n     * @param type   The mapping type\n     * @param source The mapping source\n     ",
      "vertexLabel": "PutIndexTemplateRequest mapping()"
    },
    {
      "vertexName": "EnumConstant CLOSED  (IndicesClusterStateService.java)",
      "children": [
        {
          "name": "EnumConstant FAILURE  (IndicesClusterStateService.java)"
        }
      ],
      "comment": "\n             * The index have been closed. The index should be removed and all associated resources released. Persistent parts of the index\n             * like the shards files, state and transaction logs are kept around in the case of a disaster recovery.\n             ",
      "vertexLabel": "EnumConstant CLOSED"
    },
    {
      "vertexName": "Method public ObjectLookupContainer<KType> keys()  (ImmutableOpenMap.java)",
      "comment": "\n     * Returns a specialized view of the keys of this associated container.\n     * The view additionally implements {@link ObjectLookupContainer}.\n     ",
      "vertexLabel": "ObjectLookupContainer<KType> keys()"
    },
    {
      "vertexName": "Method public TermsQueryBuilder(String fieldName, String... values)  (TermsQueryBuilder.java)",
      "comment": "\n     * A filter for a field based on several terms matching on any of them.\n     *\n     * @param fieldName The field name\n     * @param values The terms\n     ",
      "vertexLabel": "TermsQueryBuilder()"
    },
    {
      "vertexName": "Method public final void addValidationError(String error)  (ValidationException.java)",
      "comment": "\n     * Add a new validation error to the accumulating validation errors\n     * @param error the error to add\n     ",
      "vertexLabel": "final void addValidationError()"
    },
    {
      "vertexName": "Method public List<BootstrapCheck> getBootstrapChecks()  (Plugin.java)",
      "children": [
        {
          "name": "Class BootstrapChecks  (BootstrapChecks.java)"
        }
      ],
      "comment": "\n     * Returns a list of checks that are enforced when a node starts up once a node has the transport protocol bound to a non-loopback\n     * interface. In this case we assume the node is running in production and all bootstrap checks must pass. This allows plugins\n     * to provide a better out of the box experience by pre-configuring otherwise (in production) mandatory settings or to enforce certain\n     * configurations like OS settings or 3rd party resources.\n     ",
      "vertexLabel": "List<BootstrapCheck> getBootstrapChecks()"
    },
    {
      "vertexName": "Method public NestedAggregationBuilder(String name, String path)  (NestedAggregationBuilder.java)",
      "children": [
        {
          "name": "Method public ReverseNestedAggregationBuilder path(String path)  (ReverseNestedAggregationBuilder.java)"
        }
      ],
      "comment": "\n     * @param name\n     *            the name of this aggregation\n     * @param path\n     *            the path to use for this nested aggregation. The path must\n     *            match the path to a nested object in the mappings.\n     ",
      "vertexLabel": "NestedAggregationBuilder()"
    },
    {
      "vertexName": "Method public void waitForPersistentTaskCondition(final String taskId, final Predicate<PersistentTask<?>> predicate, @Nullable final TimeValue timeout, final WaitForPersistentTaskListener<?> listener)  (PersistentTasksService.java)",
      "children": [
        {
          "name": "Method public void waitForPersistentTask(final Predicate<PersistentTasksCustomMetaData.PersistentTask<?>> predicate, @Nullable final TimeValue timeout, final PersistentTasksService.WaitForPersistentTaskListener<?> listener)  (AllocatedPersistentTask.java)"
        }
      ],
      "comment": "\n     * Waits for a given persistent task to comply with a given predicate, then call back the listener accordingly.\n     *\n     * @param taskId the persistent task id\n     * @param predicate the persistent task predicate to evaluate\n     * @param timeout a timeout for waiting\n     * @param listener the callback listener\n     ",
      "vertexLabel": "void waitForPersistentTaskCondition()"
    },
    {
      "vertexName": "Method void onCache(ShardId shardId, Accountable accountable)  (BitsetFilterCache.java)",
      "comment": "\n         * Called for each cached bitset on the cache event.\n         * @param shardId the shard id the bitset was cached for. This can be <code>null</code>\n         * @param accountable the bitsets ram representation\n         ",
      "vertexLabel": "void onCache()"
    },
    {
      "vertexName": "Method public static Optional<String> checkShardLimit(int newShards, ClusterState state, DeprecationLogger deprecationLogger)  (IndicesService.java)",
      "children": [
        {
          "name": "Method static Optional<String> checkShardLimit(Settings settings, ClusterState clusterState, DeprecationLogger deprecationLogger)  (MetaDataCreateIndexService.java)"
        }
      ],
      "comment": "\n     * Checks to see if an operation can be performed without taking the cluster over the cluster-wide shard limit. Adds a deprecation\n     * warning or returns an error message as appropriate\n     *\n     * @param newShards         The number of shards to be added by this operation\n     * @param state             The current cluster state\n     * @param deprecationLogger The logger to use for deprecation warnings\n     * @return If present, an error message to be given as the reason for failing\n     * an operation. If empty, a sign that the operation is valid.\n     ",
      "vertexLabel": "Optional<String> checkShardLimit()"
    },
    {
      "vertexName": "Method public static void normalizePoint(GeoPoint point, boolean normLat, boolean normLon)  (GeoUtils.java)",
      "children": [
        {
          "name": "Method public static void normalizePoint(GeoPoint point)  (GeoUtils.java)"
        }
      ],
      "comment": "\n     * Normalize the geo {@code Point} for the given coordinates to lie within\n     * their respective normalized ranges.\n     * <p>\n     * You can control which coordinate gets normalized with the two flags.\n     * <p>\n     * Note: A shift of 180&deg; is applied in the longitude if necessary,\n     * in order to normalize properly the latitude.\n     * If normalizing latitude but not longitude, it is assumed that\n     * the longitude is in the form x+k*360, with x in ]-180;180],\n     * and k is meaningful to the application.\n     * Therefore x will be adjusted while keeping k preserved.\n     *\n     * @param point   The point to normalize in-place.\n     * @param normLat Whether to normalize latitude or leave it as is.\n     * @param normLon Whether to normalize longitude.\n     ",
      "vertexLabel": "void normalizePoint()"
    },
    {
      "vertexName": "Method public CircleBuilder radius(double radius, DistanceUnit unit)  (CircleBuilder.java)",
      "comment": "\n     * Set the radius of the circle\n     * @param radius value of the circles radius\n     * @param unit unit of the radius value (see {@link DistanceUnit})\n     * @return this\n     ",
      "vertexLabel": "CircleBuilder radius()"
    },
    {
      "vertexName": "Method public FuzzyQueryBuilder(String fieldName, String value)  (FuzzyQueryBuilder.java)",
      "comment": "\n     * Constructs a new fuzzy query.\n     *\n     * @param fieldName  The name of the field\n     * @param value The value of the text\n     ",
      "vertexLabel": "FuzzyQueryBuilder()"
    },
    {
      "vertexName": "EnumConstant FETCHING_SHARD_DATA  (UnassignedInfo.java)",
      "comment": "\n         * Waiting on getting shard data from all nodes before making a decision about where to allocate the shard\n         ",
      "vertexLabel": "EnumConstant FETCHING_SHARD_DATA"
    },
    {
      "vertexName": "Method public TermSuggestionBuilder minWordLength(int minWordLength)  (TermSuggestionBuilder.java)",
      "children": [
        {
          "name": "Method public DirectCandidateGeneratorBuilder minWordLength(int minWordLength)  (DirectCandidateGeneratorBuilder.java)"
        }
      ],
      "comment": "\n     * The minimum length a suggest text term must have in order to be\n     * corrected. Defaults to {@code 4}.\n     ",
      "vertexLabel": "TermSuggestionBuilder minWordLength()"
    },
    {
      "vertexName": "Method private synchronized boolean markAsFailed(String details, Exception reason)  (PublishClusterStateAction.java)",
      "comment": "\n         * tries marking the publishing as failed, if a decision wasn't made yet\n         *\n         * @return true if the publishing was failed and the cluster state is *not* committed\n         *",
      "vertexLabel": "synchronized boolean markAsFailed()"
    },
    {
      "vertexName": "Method public GeoShapeQueryBuilder(String fieldName, ShapeBuilder shape)  (GeoShapeQueryBuilder.java)",
      "comment": "\n     * Creates a new GeoShapeQueryBuilder whose Query will be against the given\n     * field name using the given Shape\n     *\n     * @param fieldName\n     *            Name of the field that will be queried\n     * @param shape\n     *            Shape used in the Query\n     ",
      "vertexLabel": "GeoShapeQueryBuilder()"
    },
    {
      "vertexName": "Method public Closeable acquireRetentionLockForPeerRecovery()  (IndexShard.java)",
      "children": [
        {
          "name": "Method public abstract Closeable acquireRetentionLockForPeerRecovery()  (Engine.java)"
        }
      ],
      "comment": "\n     * Acquires a lock on the translog files and Lucene soft-deleted documents to prevent them from being trimmed\n     ",
      "vertexLabel": "Closeable acquireRetentionLockForPeerRecovery()"
    },
    {
      "vertexName": "Class AbstractSortedNumericDocValues  (AbstractSortedNumericDocValues.java)",
      "children": [
        {
          "name": "Class AbstractBinaryDocValues  (AbstractBinaryDocValues.java)"
        }
      ],
      "comment": "\n * Base implementation that throws an {@link IOException} for the\n * {@link DocIdSetIterator} APIs. This impl is safe to use for sorting and\n * aggregations, which only use {@link #advanceExact(int)} and\n * {@link #docValueCount()} and {@link #nextValue()}.\n ",
      "vertexLabel": "Class AbstractSortedNumericDocValues"
    },
    {
      "vertexName": "Method public final void onModule(SearchModule module)  (Plugin.java)",
      "children": [
        {
          "name": "Method public final void onModule(ActionModule module)  (Plugin.java)"
        }
      ],
      "comment": "\n     * Old-style search extension point. {@code @Deprecated} and {@code final} to act as a signpost for plugin authors upgrading\n     * from 2.x.\n     *\n     * @deprecated implement {@link SearchPlugin} instead\n     ",
      "vertexLabel": "final void onModule()"
    },
    {
      "vertexName": "Method public static Set<InjectionPoint> forInstanceMethodsAndFields(TypeLiteral<?> type)  (InjectionPoint.java)",
      "children": [
        {
          "name": "Method public static Set<InjectionPoint> forStaticMethodsAndFields(TypeLiteral type)  (InjectionPoint.java)"
        }
      ],
      "comment": "\n     * Returns all instance method and field injection points on {@code type}.\n     *\n     * @return a possibly empty set of injection points. The set has a specified iteration order. All\n     *         fields are returned and then all methods. Within the fields, supertype fields are returned\n     *         before subtype fields. Similarly, supertype methods are returned before subtype methods.\n     * @throws ConfigurationException if there is a malformed injection point on {@code type}, such as\n     *                                a field with multiple binding annotations. The exception's {@link\n     *                                ConfigurationException#getPartialValue() partial value} is a {@code Set<InjectionPoint>}\n     *                                of the valid injection points.\n     ",
      "vertexLabel": "Set<InjectionPoint> forInstancesAndFields()"
    },
    {
      "vertexName": "Method public DateRangeAggregationBuilder addUnboundedTo(String key, String to)  (DateRangeAggregationBuilder.java)",
      "comment": "\n     * Add a new range with no lower bound.\n     *\n     * @param key\n     *            the key to use for this range in the response\n     * @param to\n     *            the upper bound on the dates, exclusive\n     ",
      "vertexLabel": "DateRangeAggregationBuilder addUnboundedTo()"
    },
    {
      "vertexName": "Method public CreateIndexRequestBuilder setWaitForActiveShards(ActiveShardCount waitForActiveShards)  (CreateIndexRequestBuilder.java)",
      "children": [
        {
          "name": "Method public CreateIndexRequest waitForActiveShards(ActiveShardCount waitForActiveShards)  (CreateIndexRequest.java)"
        }
      ],
      "comment": "\n     * Sets the number of shard copies that should be active for index creation to return.\n     * Defaults to {@link ActiveShardCount#DEFAULT}, which will wait for one shard copy\n     * (the primary) to become active. Set this value to {@link ActiveShardCount#ALL} to\n     * wait for all shards (primary and all replicas) to be active before returning.\n     * Otherwise, use {@link ActiveShardCount#from(int)} to set this value to any\n     * non-negative integer, up to the number of copies per shard (number of replicas + 1),\n     * to wait for the desired amount of shard copies to become active before returning.\n     * Index creation will only wait up until the timeout value for the number of shard copies\n     * to be active before returning.  Check {@link CreateIndexResponse#isShardsAcknowledged()} to\n     * determine if the requisite shard copies were all started before returning or timing out.\n     *\n     * @param waitForActiveShards number of active shard copies to wait on\n     ",
      "vertexLabel": "CreateIndexRequestBuilder setWaitForActiveShards()"
    },
    {
      "vertexName": "Method static void closeChannel(C channel, boolean blocking)  (CloseableChannel.java)",
      "comment": "\n     * Closes the channel.\n     *\n     * @param channel  to close\n     * @param blocking indicates if we should block on channel close\n     ",
      "vertexLabel": "void closeChannel()"
    },
    {
      "vertexName": "Method T get(IndexSettings indexSettings, Environment environment, String name, Settings settings) throws IOException  (AnalysisModule.java)",
      "comment": "\n         * Creates a new analysis provider.\n         *\n         * @param indexSettings the index settings for the index this provider is created for\n         * @param environment   the nodes environment to load resources from persistent storage\n         * @param name          the name of the analysis component\n         * @param settings      the component specific settings without context prefixes\n         * @return a new provider instance\n         * @throws IOException if an {@link IOException} occurs\n         ",
      "vertexLabel": "T get()"
    },
    {
      "vertexName": "Method public static WildcardQueryBuilder wildcardQuery(String name, String query)  (QueryBuilders.java)",
      "children": [
        {
          "name": "Class WildcardQueryBuilder  (WildcardQueryBuilder.java)"
        }
      ],
      "comment": "\n     * Implements the wildcard search query. Supported wildcards are {@code *}, which\n     * matches any character sequence (including the empty one), and {@code ?},\n     * which matches any single character. Note this query can be slow, as it\n     * needs to iterate over many terms. In order to prevent extremely slow WildcardQueries,\n     * a Wildcard term should not start with one of the wildcards {@code *} or\n     * {@code ?}.\n     *\n     * @param name  The field name\n     * @param query The wildcard query string\n     ",
      "vertexLabel": "WildcardQueryBuilder wildcardQuery()"
    },
    {
      "vertexName": "Method public static ConnectionProfile buildSingleChannelProfile(TransportRequestOptions.Type channelType, boolean compressionEnabled)  (ConnectionProfile.java)",
      "comment": "\n     * Builds a connection profile that is dedicated to a single channel type. Allows passing compression\n     * settings.\n     ",
      "vertexLabel": "ConnectionProfile buildSingleChannelProfile()"
    },
    {
      "vertexName": "Interface BindingScopingVisitor  (BindingScopingVisitor.java)",
      "children": [
        {
          "name": "Interface ElementVisitor  (ElementVisitor.java)"
        }
      ],
      "comment": "\n * Visits each of the strategies used to scope an injection.\n *\n * @param <V> any type to be returned by the visit method. Use {@link Void} with\n *            {@code return null} if no return type is needed.\n * @since 2.0\n ",
      "vertexLabel": "Interface BindingScopingVisitor"
    },
    {
      "vertexName": "Method public static PreConfiguredTokenizer elasticsearchVersion(String name, Function<org.elasticsearch.Version, Tokenizer> create, @Nullable Function<Version, TokenFilterFactory> multiTermComponent)  (PreConfiguredTokenizer.java)",
      "children": [
        {
          "name": "Method public static PreConfiguredTokenizer luceneVersion(String name, Function<org.apache.lucene.util.Version, Tokenizer> create, @Nullable Function<org.apache.lucene.util.Version, TokenFilterFactory> multiTermComponent)  (PreConfiguredTokenizer.java)"
        }
      ],
      "comment": "\n     * Create a pre-configured tokenizer that may vary based on the Elasticsearch version.\n     * \n     * @param name the name of the tokenizer in the api\n     * @param create builds the tokenizer\n     * @param multiTermComponent null if this tokenizer shouldn't be used for multi-term queries, otherwise a supplier for the\n     *        {@link TokenFilterFactory} that stands in for this tokenizer in multi-term queries.\n     ",
      "vertexLabel": "PreConfiguredTokenizer elasticsearchVersion()"
    },
    {
      "vertexName": "Method public boolean clearCaches(boolean queryCache, boolean fieldDataCache, String... fields)  (IndexService.java)",
      "comment": "\n     * Clears the caches for the given shard id if the shard is still allocated on this node\n     ",
      "vertexLabel": "boolean clearCaches()"
    },
    {
      "vertexName": "Method public static Set<ShardId> selectShrinkShards(int shardId, IndexMetaData sourceIndexMetadata, int numTargetShards)  (IndexMetaData.java)",
      "children": [
        {
          "name": "Method public static ShardId selectSplitShard(int shardId, IndexMetaData sourceIndexMetadata, int numTargetShards)  (IndexMetaData.java)"
        }
      ],
      "comment": "\n     * Returns the source shard ids to shrink into the given shard id.\n     * @param shardId the id of the target shard to shrink to\n     * @param sourceIndexMetadata the source index metadata\n     * @param numTargetShards the total number of shards in the target index\n     * @return a set of shard IDs to shrink into the given shard ID.\n     ",
      "vertexLabel": "Set<ShardId> selectShrinkShards()"
    },
    {
      "vertexName": "Method public GetSnapshotsRequestBuilder setVerbose(boolean verbose)  (GetSnapshotsRequestBuilder.java)",
      "children": [
        {
          "name": "Method public GetSnapshotsRequest verbose(boolean verbose)  (GetSnapshotsRequest.java)"
        }
      ],
      "comment": "\n     * Set to {@code false} to only show the snapshot names and the indices they contain.\n     * This is useful when the snapshots belong to a cloud-based repository where each\n     * blob read is a concern (cost wise and performance wise), as the snapshot names and\n     * indices they contain can be retrieved from a single index blob in the repository,\n     * whereas the rest of the information requires reading a snapshot metadata file for\n     * each snapshot requested.  Defaults to {@code true}, which returns all information\n     * about each requested snapshot.\n     ",
      "vertexLabel": "GetSnapshotsRequestBuilder setVerbose()"
    },
    {
      "vertexName": "Method public long getTotal()  (BulkByScrollTask.java)",
      "children": [
        {
          "name": "Field total  (WorkerBulkByScrollTaskState.java)"
        }
      ],
      "comment": "\n         * The total number of documents this request will process. 0 means we don't yet know or, possibly, there are actually 0 documents\n         * to process. Its ok that these have the same meaning because any request with 0 actual documents should be quite short lived.\n         ",
      "vertexLabel": "long getTotal()"
    },
    {
      "vertexName": "Method private void handleUnsupportedHttpMethod(RestRequest request, RestChannel channel, Set<RestRequest.Method> validMethodSet)  (RestController.java)",
      "children": [
        {
          "name": "Method private void handleOptionsRequest(RestRequest request, RestChannel channel, Set<RestRequest.Method> validMethodSet)  (RestController.java)"
        }
      ],
      "comment": "\n     * Handle requests to a valid REST endpoint using an unsupported HTTP\n     * method. A 405 HTTP response code is returned, and the response 'Allow'\n     * header includes a list of valid HTTP methods for the endpoint (see\n     * <a href=\"https://tools.ietf.org/html/rfc2616#section-10.4.6\">HTTP/1.1 -\n     * 10.4.6 - 405 Method Not Allowed</a>).\n     ",
      "vertexLabel": "void handleUnsupportedHttp()"
    },
    {
      "vertexName": "Method private static Normalization parseNormalization(Settings settings)  (SimilarityProviders.java)",
      "children": [
        {
          "name": "Method private static Lambda parseLambda(Settings settings)  (SimilarityProviders.java)"
        }
      ],
      "comment": "\n     * Parses the given Settings and creates the appropriate {@link Normalization}\n     *\n     * @param settings Settings to parse\n     * @return {@link Normalization} referred to in the Settings\n     ",
      "vertexLabel": "Normalization parseNormalization()"
    },
    {
      "vertexName": "Method public SearchRequest allowPartialSearchResults(boolean allowPartialSearchResults)  (SearchRequest.java)",
      "comment": "\n     * Sets if this request should allow partial results. (If method is not called,\n     * will default to the cluster level setting).\n     ",
      "vertexLabel": "SearchRequest allowPartialSearchResults()"
    },
    {
      "vertexName": "Method private void addTermFrequencies(Map<String, Int> termFreqMap, Terms vector, @Nullable String fieldName) throws IOException  (XMoreLikeThis.java)",
      "children": [
        {
          "name": "Method private void addTermFrequencies(Map<String, Int> termFreqMap, Terms vector) throws IOException  (XMoreLikeThis.java)"
        }
      ],
      "comment": "\n     * Adds terms and frequencies found in vector into the Map termFreqMap\n     *\n     * @param termFreqMap a Map of terms and their frequencies\n     * @param vector List of terms and their frequencies for a doc/field\n     * @param fieldName Optional field name of the terms for skip terms\n     ",
      "vertexLabel": "void addTermFrequencies()"
    },
    {
      "vertexName": "Method public static byte[] floatToBytes(float val)  (Numbers.java)",
      "children": [
        {
          "name": "Method public static byte[] longToBytes(long val)  (Numbers.java)"
        }
      ],
      "comment": "\n     * Converts a float to a byte array.\n     *\n     * @param val The float to convert to a byte array\n     * @return The byte array converted\n     ",
      "vertexLabel": "byte[] floatToBytes()"
    },
    {
      "vertexName": "Method public InternalSearchResponse merge(boolean ignoreFrom, ReducedQueryPhase reducedQueryPhase, Collection<? extends SearchPhaseResult> fetchResults, IntFunction<SearchPhaseResult> resultsLookup)  (SearchPhaseController.java)",
      "comment": "\n     * Enriches search hits and completion suggestion hits from <code>sortedDocs</code> using <code>fetchResultsArr</code>,\n     * merges suggestions, aggregations and profile results\n     *\n     * Expects sortedDocs to have top search docs across all shards, optionally followed by top suggest docs for each named\n     * completion suggestion ordered by suggestion name\n     ",
      "vertexLabel": "InternalSearchResponse merge()"
    },
    {
      "vertexName": "Method public long getStartTime()  (Task.java)",
      "children": [
        {
          "name": "Field startTime  (Task.java)"
        }
      ],
      "comment": "\n     * Returns the task's start time as a wall clock time since epoch ({@link System#currentTimeMillis()} style).\n     ",
      "vertexLabel": "long getStartTime()"
    },
    {
      "vertexName": "Method public BoolQueryBuilder must(QueryBuilder queryBuilder)  (BoolQueryBuilder.java)",
      "comment": "\n     * Adds a query that <b>must</b> appear in the matching documents and will\n     * contribute to scoring. No {@code null} value allowed.\n     ",
      "vertexLabel": "BoolQueryBuilder must()"
    },
    {
      "vertexName": "Method public AllocateEmptyPrimaryAllocationCommand(String index, int shardId, String node, boolean acceptDataLoss)  (AllocateEmptyPrimaryAllocationCommand.java)",
      "children": [
        {
          "name": "Method public AllocateReplicaAllocationCommand(String index, int shardId, String node)  (AllocateReplicaAllocationCommand.java)"
        }
      ],
      "comment": "\n     * Creates a new {@link AllocateEmptyPrimaryAllocationCommand}\n     *\n     * @param shardId        {@link ShardId} of the shard to assign\n     * @param node           node id of the node to assign the shard to\n     * @param acceptDataLoss whether the user agrees to data loss\n     ",
      "vertexLabel": "AllocateEmptyPrimaryAllocationCommand()"
    },
    {
      "vertexName": "Method public CreateIndexRequest waitForActiveShards(final int waitForActiveShards)  (CreateIndexRequest.java)",
      "comment": "\n     * A shortcut for {@link #waitForActiveShards(ActiveShardCount)} where the numerical\n     * shard count is passed in, instead of having to first call {@link ActiveShardCount#from(int)}\n     * to get the ActiveShardCount.\n     ",
      "vertexLabel": "CreateIndexRequest waitForActiveShards()"
    },
    {
      "vertexName": "Method ActionFuture<Response> execute(Action<Response> action, Request request)  (ElasticsearchClient.java)",
      "children": [
        {
          "name": "Method void execute(Action<Response> action, Request request, ActionListener<Response> listener)  (ElasticsearchClient.java)"
        }
      ],
      "comment": "\n     * Executes a generic action, denoted by an {@link org.elasticsearch.action.Action}.\n     *\n     * @param action           The action type to execute.\n     * @param request          The action request.\n     * @param <Request>        The request type.\n     * @param <Response>       the response type.\n     * @return A future allowing to get back the response.\n     ",
      "vertexLabel": "ActionFuture<Response> execute()"
    },
    {
      "vertexName": "Method public static DeleteRequest deleteRequest(String index)  (Requests.java)",
      "comment": "\n     * Creates a delete request against a specific index. Note the {@link DeleteRequest#type(String)} and\n     * {@link DeleteRequest#id(String)} must be set.\n     *\n     * @param index The index name to delete from\n     * @return The delete request\n     * @see org.elasticsearch.client.Client#delete(org.elasticsearch.action.delete.DeleteRequest)\n     ",
      "vertexLabel": "DeleteRequest deleteRequest()"
    },
    {
      "vertexName": "Method public static double geoHashCellWidth(int level)  (GeoUtils.java)",
      "children": [
        {
          "name": "Method public static double geoHashCellSize(int level)  (GeoUtils.java)"
        }
      ],
      "comment": "\n     * Calculate the width (in meters) of geohash cells at a specific level\n     * @param level geohash level must be greater or equal to zero\n     * @return the width of cells at level in meters\n     ",
      "vertexLabel": "double geoHashCellWidth()"
    },
    {
      "vertexName": "Method public SignificantTermsAggregationBuilder minDocCount(long minDocCount)  (SignificantTermsAggregationBuilder.java)",
      "children": [
        {
          "name": "Method public TermsAggregationBuilder minDocCount(long minDocCount)  (TermsAggregationBuilder.java)"
        }
      ],
      "comment": "\n     * Set the minimum document count terms should have in order to appear in\n     * the response.\n     ",
      "vertexLabel": "SignificantTermsAggregationBuilder minDocCount()"
    },
    {
      "vertexName": "Method PendingClusterTasksRequestBuilder preparePendingClusterTasks()  (ClusterAdminClient.java)",
      "children": [
        {
          "name": "Method void pendingClusterTasks(PendingClusterTasksRequest request, ActionListener<PendingClusterTasksResponse> listener)  (ClusterAdminClient.java)"
        }
      ],
      "comment": "\n     * Returns a list of the pending cluster tasks, that are scheduled to be executed. This includes operations\n     * that update the cluster state (for example, a create index operation)\n     ",
      "vertexLabel": "PendingClusterTasksRequestBuilder preparePendingClusterTasks()"
    },
    {
      "vertexName": "Method void addCloseListener(ActionListener<Void> listener)  (CloseableChannel.java)",
      "comment": "\n     * Adds a listener that will be executed when the channel is closed. If the channel is still open when\n     * this listener is added, the listener will be executed by the thread that eventually closes the\n     * channel. If the channel is already closed when the listener is added the listener will immediately be\n     * executed by the thread that is attempting to add the listener.\n     *\n     * @param listener to be executed\n     ",
      "vertexLabel": "void addCloseListener()"
    },
    {
      "vertexName": "Method public boolean dryRun()  (ClusterRerouteRequest.java)",
      "comment": "\n     * Returns the current dry run flag which allows to run the commands without actually applying them,\n     * just to get back the resulting cluster state back.\n     ",
      "vertexLabel": "boolean dryRun()"
    },
    {
      "vertexName": "Method public UpdateRequestBuilder setUpsert(Map<String, Object> source)  (UpdateRequestBuilder.java)",
      "children": [
        {
          "name": "Method public UpdateRequest upsert(byte[] source, XContentType xContentType)  (UpdateRequest.java)"
        }
      ],
      "comment": "\n     * Sets the doc source of the update request to be used when the document does not exists.\n     ",
      "vertexLabel": "UpdateRequestBuilder setUpsert()"
    },
    {
      "vertexName": "Method public TermSuggestionBuilder stringDistance(StringDistanceImpl stringDistance)  (TermSuggestionBuilder.java)",
      "children": [
        {
          "name": "Method public DirectCandidateGeneratorBuilder stringDistance(String stringDistance)  (DirectCandidateGeneratorBuilder.java)"
        }
      ],
      "comment": "\n     * Sets what string distance implementation to use for comparing how similar\n     * suggested terms are. Five possible values can be specified:\n     * <ol>\n     * <li><code>internal</code> - This is the default and is based on\n     * <code>damerau_levenshtein</code>, but highly optimized for comparing\n     * string distance for terms inside the index.\n     * <li><code>damerau_levenshtein</code> - String distance algorithm based on\n     * Damerau-Levenshtein algorithm.\n     * <li><code>levenshtein</code> - String distance algorithm based on\n     * Levenshtein edit distance algorithm.\n     * <li><code>jaro_winkler</code> - String distance algorithm based on\n     * Jaro-Winkler algorithm.\n     * <li><code>ngram</code> - String distance algorithm based on character\n     * n-grams.\n     * </ol>\n     ",
      "vertexLabel": "TermSuggestionBuilder stringDistance()"
    },
    {
      "vertexName": "Method public static SortedBinaryDocValues toString(final SortedNumericDocValues values)  (FieldData.java)",
      "children": [
        {
          "name": "Method public static SortedBinaryDocValues toString(final SortedSetDocValues values)  (FieldData.java)"
        }
      ],
      "comment": "\n     * Return a {@link String} representation of the provided values. That is\n     * typically used for scripts or for the `map` execution mode of terms aggs.\n     * NOTE: this is very slow!\n     ",
      "vertexLabel": "SortedBinaryDocValues toString()"
    },
    {
      "vertexName": "Method List<String> readProcSelfCgroup() throws IOException  (OsProbe.java)",
      "children": [
        {
          "name": "Method private Map<String, String> getControlGroups() throws IOException  (OsProbe.java)"
        }
      ],
      "comment": "\n     * The lines from {@code /proc/self/cgroup}. This file represents the control groups to which the Elasticsearch process belongs. Each\n     * line in this file represents a control group hierarchy of the form\n     * <p>\n     * {@code \\d+:([^:,]+(?:,[^:,]+)?):(/.*)}\n     * <p>\n     * with the first field representing the hierarchy ID, the second field representing a comma-separated list of the subsystems bound to\n     * the hierarchy, and the last field representing the control group.\n     *\n     * @return the lines from {@code /proc/self/cgroup}\n     * @throws IOException if an I/O exception occurs reading {@code /proc/self/cgroup}\n     ",
      "vertexLabel": "List<String> readProcSelfCgroup()"
    },
    {
      "vertexName": "Method public final void onModule(AnalysisModule module)  (Plugin.java)",
      "children": [
        {
          "name": "Method public final void onModule(NetworkModule module)  (Plugin.java)"
        }
      ],
      "comment": "\n     * Old-style analysis extension point. {@code @Deprecated} and {@code final} to act as a signpost for plugin authors upgrading\n     * from 2.x.\n     *\n     * @deprecated implement {@link AnalysisPlugin} instead\n     ",
      "vertexLabel": "final void onModule()"
    },
    {
      "vertexName": "Interface AnalysisPlugin  (AnalysisPlugin.java)",
      "children": [
        {
          "name": "Interface DiscoveryPlugin  (DiscoveryPlugin.java)"
        }
      ],
      "comment": "\n * An additional extension point for {@link Plugin}s that extends Elasticsearch's analysis functionality. To add an additional\n * {@link TokenFilter} just implement the interface and implement the {@link #getTokenFilters()} method:\n *\n * <pre>{@code\n * public class AnalysisPhoneticPlugin extends Plugin implements AnalysisPlugin {\n *     &#64;Override\n *     public Map<String, AnalysisProvider<TokenFilterFactory>> getTokenFilters() {\n *         return singletonMap(\"phonetic\", PhoneticTokenFilterFactory::new);\n *     }\n * }\n * }</pre>\n *\n * Elasticsearch doesn't have any automatic mechanism to share these components between indexes. If any component is heavy enough to warrant\n * such sharing then it is the Plugin's responsibility to do it in their {@link AnalysisProvider} implementation. We recommend against doing\n * this unless absolutely necessary because it can be difficult to get the caching right given things like behavior changes across versions.\n ",
      "vertexLabel": "Interface AnalysisPlugin"
    },
    {
      "vertexName": "Method public TermsAggregationBuilder shardSize(int shardSize)  (TermsAggregationBuilder.java)",
      "comment": "\n     * Sets the shard_size - indicating the number of term buckets each shard\n     * will return to the coordinating node (the node that coordinates the\n     * search execution). The higher the shard size is, the more accurate the\n     * results are.\n     ",
      "vertexLabel": "TermsAggregationBuilder shardSize()"
    },
    {
      "vertexName": "Method public IndicesAliasesRequestBuilder addAlias(String index, String alias, Map<String, Object> filter)  (IndicesAliasesRequestBuilder.java)",
      "comment": "\n     * Adds an alias to the index.\n     *\n     * @param index  The indices\n     * @param alias  The alias\n     * @param filter The filter\n     ",
      "vertexLabel": "IndicesAliasesRequestBuilder addAlias()"
    },
    {
      "vertexName": "Method public RestoreSnapshotRequestBuilder setIgnoreIndexSettings(List<String> ignoreIndexSettings)  (RestoreSnapshotRequestBuilder.java)",
      "children": [
        {
          "name": "Method public RestoreSnapshotRequest ignoreIndexSettings(List<String> ignoreIndexSettings)  (RestoreSnapshotRequest.java)"
        }
      ],
      "comment": "\n     * Sets the list of index settings and index settings groups that shouldn't be restored from snapshot\n     ",
      "vertexLabel": "RestoreSnapshotRequestBuilder setIgnoreIndexSettings()"
    },
    {
      "vertexName": "Method protected boolean serializeTargetValueType()  (MultiValuesSourceAggregationBuilder.java)",
      "comment": "\n     * Should this builder serialize its targetValueType? Defaults to false. All subclasses that override this to true\n     * should use the three argument read constructor rather than the four argument version.\n     ",
      "vertexLabel": "boolean serializeTargetValueType()"
    },
    {
      "vertexName": "Method protected final AnnotatedElementBuilder expose(Class<?> type)  (PrivateModule.java)",
      "comment": "\n     * Makes a binding for {@code type} available to other modules and the injector. Use {@link\n     * AnnotatedElementBuilder#annotatedWith(Class) annotatedWith()} to expose {@code type} with a\n     * binding annotation.\n     ",
      "vertexLabel": "final AnnotatedElementBuilder expose()"
    },
    {
      "vertexName": "Method public GetRequestBuilder setRefresh(boolean refresh)  (GetRequestBuilder.java)",
      "children": [
        {
          "name": "Method public GetRequest refresh(boolean refresh)  (GetRequest.java)"
        }
      ],
      "comment": "\n     * Should a refresh be executed before this get operation causing the operation to\n     * return the latest value. Note, heavy get should not set this to {@code true}. Defaults\n     * to {@code false}.\n     ",
      "vertexLabel": "GetRequestBuilder setRefresh()"
    },
    {
      "vertexName": "Method ActionFuture<NodesHotThreadsResponse> nodesHotThreads(NodesHotThreadsRequest request)  (ClusterAdminClient.java)",
      "children": [
        {
          "name": "Method void nodesHotThreads(NodesHotThreadsRequest request, ActionListener<NodesHotThreadsResponse> listener)  (ClusterAdminClient.java)"
        }
      ],
      "comment": "\n     * Returns top N hot-threads samples per node. The hot-threads are only\n     * sampled for the node ids specified in the request.\n     *\n     ",
      "vertexLabel": "ActionFuture<NodesHotThreadsResponse> nodesHotThreads()"
    },
    {
      "vertexName": "Method public CreateSnapshotRequest settings(Map<String, Object> source)  (CreateSnapshotRequest.java)",
      "children": [
        {
          "name": "Method public RestoreSnapshotRequest settings(Map<String, Object> source)  (RestoreSnapshotRequest.java)"
        }
      ],
      "comment": "\n     * Sets repository-specific snapshot settings.\n     * <p>\n     * See repository documentation for more information.\n     *\n     * @param source repository-specific snapshot settings\n     * @return this request\n     ",
      "vertexLabel": "CreateSnapshotRequest settings()"
    },
    {
      "vertexName": "Method public void invalidate(K key)  (Cache.java)",
      "comment": "\n     * Invalidate the association for the specified key. A removal notification will be issued for invalidated\n     * entries with {@link org.elasticsearch.common.cache.RemovalNotification.RemovalReason} INVALIDATED.\n     *\n     * @param key the key whose mapping is to be invalidated from the cache\n     ",
      "vertexLabel": "void invalidate()"
    },
    {
      "vertexName": "Method ActionFuture<SyncedFlushResponse> syncedFlush(SyncedFlushRequest request)  (IndicesAdminClient.java)",
      "children": [
        {
          "name": "Method SyncedFlushRequestBuilder prepareSyncedFlush(String... indices)  (IndicesAdminClient.java)"
        }
      ],
      "comment": "\n     * Explicitly sync flush one or more indices (write sync id to shards for faster recovery).\n     *\n     * @param request The sync flush request\n     * @return A result future\n     * @see org.elasticsearch.client.Requests#syncedFlushRequest(String...)\n     ",
      "vertexLabel": "ActionFuture<SyncedFlushResponse> syncedFlush()"
    },
    {
      "vertexName": "Method FixedExecutorBuilder(final Settings settings, final String name, final int size, final int queueSize)  (FixedExecutorBuilder.java)",
      "children": [
        {
          "name": "Method public FixedExecutorBuilder(final Settings settings, final String name, final int size, final int queueSize, final String prefix)  (FixedExecutorBuilder.java)"
        }
      ],
      "comment": "\n     * Construct a fixed executor builder; the settings will have the key prefix \"thread_pool.\" followed by the executor name.\n     *\n     * @param settings  the node-level settings\n     * @param name      the name of the executor\n     * @param size      the fixed number of threads\n     * @param queueSize the size of the backing queue, -1 for unbounded\n     ",
      "vertexLabel": "FixedExecutorBuilder()"
    },
    {
      "vertexName": "Method AnnotatedElementBuilder expose(Class<?> type)  (PrivateBinder.java)",
      "children": [
        {
          "name": "Method AnnotatedElementBuilder expose(TypeLiteral<?> type)  (PrivateBinder.java)"
        }
      ],
      "comment": "\n     * Makes a binding for {@code type} available to the enclosing environment. Use {@link\n     * org.elasticsearch.common.inject.binder.AnnotatedElementBuilder#annotatedWith(Class) annotatedWith()} to expose {@code type} with a\n     * binding annotation.\n     ",
      "vertexLabel": "AnnotatedElementBuilder expose()"
    },
    {
      "vertexName": "Class ForceMergeRequestBuilder  (ForceMergeRequestBuilder.java)",
      "children": [
        {
          "name": "Method public int maxNumSegments()  (ForceMergeRequest.java)"
        }
      ],
      "comment": "\n * A request to force merge one or more indices. In order to force merge all\n * indices, pass an empty array or {@code null} for the indices.\n * {@link #setMaxNumSegments(int)} allows to control the number of segments to force\n * merge down to. By default, will cause the force merge process to merge down\n * to half the configured number of segments.\n ",
      "vertexLabel": "Class ForceMergeRequestBuilder"
    },
    {
      "vertexName": "Method public boolean autoGenerateSynonymsPhraseQuery()  (SimpleQueryStringBuilder.java)",
      "children": [
        {
          "name": "Method public boolean autoGenerateSynonymsPhraseQuery()  (MatchQueryBuilder.java)"
        }
      ],
      "comment": "\n     * Whether phrase queries should be automatically generated for multi terms synonyms.\n     * Defaults to {@code true}.\n     ",
      "vertexLabel": "boolean autoGenerateSynonymsPhraseQuery()"
    },
    {
      "vertexName": "Method public static Injector createInjector(Stage stage, Module... modules)  (Guice.java)",
      "children": [
        {
          "name": "Method public static Injector createInjector(Iterable<? extends Module> modules)  (Guice.java)"
        }
      ],
      "comment": "\n     * Creates an injector for the given set of modules, in a given development\n     * stage.\n     *\n     * @throws CreationException if one or more errors occur during Injector\n     *                           creation\n     ",
      "vertexLabel": "Injector createInjector()"
    },
    {
      "vertexName": "Method public static CloseIndexRequest closeIndexRequest(String index)  (Requests.java)",
      "children": [
        {
          "name": "Method public static OpenIndexRequest openIndexRequest(String index)  (Requests.java)"
        }
      ],
      "comment": "\n     * Creates a close index request.\n     *\n     * @param index The index to close\n     * @return The delete index request\n     * @see org.elasticsearch.client.IndicesAdminClient#close(org.elasticsearch.action.admin.indices.close.CloseIndexRequest)\n     ",
      "vertexLabel": "CloseIndexRequest closeIndexRequest()"
    },
    {
      "vertexName": "Method public abstract void trimUnreferencedTranslogFiles() throws EngineException  (Engine.java)",
      "comment": "\n     * checks and removes translog files that no longer need to be retained. See\n     * {@link org.elasticsearch.index.translog.TranslogDeletionPolicy} for details\n     ",
      "vertexLabel": "abstract void trimUnreferencedTranslogFiles()"
    },
    {
      "vertexName": "Class BestBucketsDeferringCollector  (BestBucketsDeferringCollector.java)",
      "children": [
        {
          "name": "Class MergingBucketsDeferringCollector  (MergingBucketsDeferringCollector.java)"
        }
      ],
      "comment": "\n * A specialization of {@link DeferringBucketCollector} that collects all\n * matches and then is able to replay a given subset of buckets which represent\n * the survivors from a pruning process performed by the aggregator that owns\n * this collector.\n ",
      "vertexLabel": "Class BestBucketsDeferringCollector"
    },
    {
      "vertexName": "Method Provider<T> getProvider(Class<T> type)  (TypeEncounter.java)",
      "children": [
        {
          "name": "Method Provider<T> getProvider(Key<T> key)  (TypeEncounter.java)"
        }
      ],
      "comment": "\n     * Returns the provider used to obtain instances for the given injection type. The returned\n     * provider will not be valid until the injetor has been created. The provider will throw an\n     * {@code IllegalStateException} if you try to use it beforehand.\n     ",
      "vertexLabel": "Provider<T> getProvider()"
    },
    {
      "vertexName": "Method public UpdateRequestBuilder setDoc(XContentType xContentType, Object... source)  (UpdateRequestBuilder.java)",
      "children": [
        {
          "name": "Method public UpdateRequest doc(Object... source)  (UpdateRequest.java)"
        }
      ],
      "comment": "\n     * Sets the doc to use for updates when a script is not specified, the doc provided\n     * is a field and value pairs.\n     ",
      "vertexLabel": "UpdateRequestBuilder setDoc()"
    },
    {
      "vertexName": "Method public Float getAsFloat(String setting, Float defaultValue)  (Settings.java)",
      "children": [
        {
          "name": "Method public Integer getAsInt(String setting, Integer defaultValue)  (Settings.java)"
        }
      ],
      "comment": "\n     * Returns the setting value (as float) associated with the setting key. If it does not exists,\n     * returns the default value provided.\n     ",
      "vertexLabel": "Float getAsFloat()"
    },
    {
      "vertexName": "Method void upgrade(UpgradeRequest request, ActionListener<UpgradeResponse> listener)  (IndicesAdminClient.java)",
      "comment": "\n     * Explicitly upgrade one or more indices\n     *\n     * @param request  The upgrade request\n     * @param listener A listener to be notified with a result\n     * @see org.elasticsearch.client.Requests#upgradeRequest(String...)\n     ",
      "vertexLabel": "void upgrade()"
    },
    {
      "vertexName": "Method public double[] next(Collection<Double> values, int numForecasts)  (HoltWintersModel.java)",
      "comment": "\n     * Calculate a doubly exponential weighted moving average\n     *\n     * @param values Collection of values to calculate avg for\n     * @param numForecasts number of forecasts into the future to return\n     *\n     * @return       Returns a Double containing the moving avg for the window\n     ",
      "vertexLabel": "double[] next()"
    },
    {
      "vertexName": "Method public static Multibinder<T> newSetBinder(Binder binder, Class<T> type)  (Multibinder.java)",
      "children": [
        {
          "name": "Method public static Multibinder<T> newSetBinder(Binder binder, TypeLiteral<T> type)  (Multibinder.java)"
        }
      ],
      "comment": "\n     * Returns a new multibinder that collects instances of {@code type} in a {@link Set} that is\n     * itself bound with no binding annotation.\n     ",
      "vertexLabel": "Multibinder<T> newSetBinder()"
    },
    {
      "vertexName": "Method public SnapshotRequest includeGlobalState(boolean includeGlobalState)  (SnapshotsService.java)",
      "children": [
        {
          "name": "Method public CreateSnapshotRequest includeGlobalState(boolean includeGlobalState)  (CreateSnapshotRequest.java)"
        }
      ],
      "comment": "\n         * Set to true if global state should be stored as part of the snapshot\n         *\n         * @param includeGlobalState true if global state should be stored as part of the snapshot\n         * @return this request\n         ",
      "vertexLabel": "SnapshotRequest includeGlobalState()"
    },
    {
      "vertexName": "Method public synchronized boolean awaitClose(long timeout, TimeUnit unit) throws InterruptedException  (BulkProcessor.java)",
      "children": [
        {
          "name": "Method public void close()  (BulkProcessor.java)"
        }
      ],
      "comment": "\n     * Closes the processor. If flushing by time is enabled, then it's shutdown. Any remaining bulk actions are flushed.\n     * <p>\n     * If concurrent requests are not enabled, returns {@code true} immediately.\n     * If concurrent requests are enabled, waits for up to the specified timeout for all bulk requests to complete then returns {@code true}\n     * If the specified waiting time elapses before all bulk requests complete, {@code false} is returned.\n     *\n     * @param timeout The maximum time to wait for the bulk requests to complete\n     * @param unit    The time unit of the {@code timeout} argument\n     * @return {@code true} if all bulk requests completed and {@code false} if the waiting time elapsed before all the bulk requests\n     * completed\n     * @throws InterruptedException If the current thread is interrupted\n     ",
      "vertexLabel": "synchronized boolean awaitClose()"
    },
    {
      "vertexName": "Method public SuggesterSpec(String name, Writeable.Reader<T> builderReader, CheckedFunction<XContentParser, T, IOException> builderParser, Writeable.Reader<? extends Suggest.Suggestion> suggestionReader)  (SearchPlugin.java)",
      "children": [
        {
          "name": "Method public QuerySpec(String name, Writeable.Reader<T> reader, QueryParser<T> parser)  (SearchPlugin.java)"
        }
      ],
      "comment": "\n         * Specification of custom {@link Suggester}.\n         *\n         * @param name the name by which this suggester might be parsed or deserialized. Make sure that the query builder and Suggestion\n         *        response reader return this name for {@link NamedWriteable#getWriteableName()}.\n         * @param builderReader the reader registered for this suggester's builder. Typically a reference to a constructor that takes a\n         *        {@link StreamInput}\n         * @param builderParser a parser that reads the suggester's builder from xcontent\n         * @param suggestionReader the reader registered for this suggester's Suggestion response. Typically a reference to a constructor\n         *        that takes a {@link StreamInput}\n         ",
      "vertexLabel": "SuggesterSpec()"
    },
    {
      "vertexName": "EnumConstant DELETED  (IndicesClusterStateService.java)",
      "comment": "\n             * The index is deleted. Persistent parts of the index  like the shards files, state and transaction logs are removed once\n             * all resources are released.\n             ",
      "vertexLabel": "EnumConstant DELETED"
    },
    {
      "vertexName": "Method public void remoteShardFailed(final ShardId shardId, String allocationId, long primaryTerm, boolean markAsStale, final String message, @Nullable final Exception failure, Listener listener)  (ShardStateAction.java)",
      "children": [
        {
          "name": "Method public void localShardFailed(final ShardRouting shardRouting, final String message, @Nullable final Exception failure, Listener listener)  (ShardStateAction.java)"
        }
      ],
      "comment": "\n     * Send a shard failed request to the master node to update the cluster state with the failure of a shard on another node. This means\n     * that the shard should be failed because a write made it into the primary but was not replicated to this shard copy. If the shard\n     * does not exist anymore but still has an entry in the in-sync set, remove its allocation id from the in-sync set.\n     *\n     * @param shardId            shard id of the shard to fail\n     * @param allocationId       allocation id of the shard to fail\n     * @param primaryTerm        the primary term associated with the primary shard that is failing the shard. Must be strictly positive.\n     * @param markAsStale        whether or not to mark a failing shard as stale (eg. removing from in-sync set) when failing the shard.\n     * @param message            the reason for the failure\n     * @param failure            the underlying cause of the failure\n     * @param listener           callback upon completion of the request\n     ",
      "vertexLabel": "void remoteShardFailed()"
    },
    {
      "vertexName": "Method public static Map<String, Float> resolveMappingField(QueryShardContext context, String fieldOrPattern, float weight, boolean acceptAllTypes, boolean acceptMetadataField, String fieldSuffix)  (QueryParserHelper.java)",
      "children": [
        {
          "name": "Method public static Map<String, Float> resolveMappingFields(QueryShardContext context, Map<String, Float> fieldsAndWeights, String fieldSuffix)  (QueryParserHelper.java)"
        },
        {
          "name": "Method public static Map<String, Float> resolveMappingField(QueryShardContext context, String fieldOrPattern, float weight, boolean acceptAllTypes, boolean acceptMetadataField)  (QueryParserHelper.java)"
        }
      ],
      "comment": "\n     * Resolves the provided pattern or field name from the {@link QueryShardContext} and return a map of\n     * the expanded fields with their original boost.\n     * @param context The context of the query\n     * @param fieldOrPattern The field name or the pattern to resolve\n     * @param weight The weight for the field\n     * @param acceptAllTypes Whether all field type should be added when a pattern is expanded.\n     *                       If false, only searchable field types are added.\n     * @param acceptMetadataField Whether metadata fields should be added when a pattern is expanded.\n     * @param fieldSuffix The suffix name to add to the expanded field names if a mapping exists for that name.\n     *                    The original name of the field is kept if adding the suffix to the field name does not point to a valid field\n     *                    in the mapping.\n     ",
      "vertexLabel": "Map<String, Float> resolveMappingField()"
    },
    {
      "vertexName": "Class ElasticsearchDirectoryReader  (ElasticsearchDirectoryReader.java)",
      "children": [
        {
          "name": "Class ElasticsearchLeafReader  (ElasticsearchLeafReader.java)"
        }
      ],
      "comment": "\n * A {@link org.apache.lucene.index.FilterDirectoryReader} that exposes\n * Elasticsearch internal per shard / index information like the shard ID.\n ",
      "vertexLabel": "Class ElasticsearchDirectoryReader"
    },
    {
      "vertexName": "Method public GetRequestBuilder setRouting(String routing)  (GetRequestBuilder.java)",
      "children": [
        {
          "name": "Method public GetRequest routing(String routing)  (GetRequest.java)"
        }
      ],
      "comment": "\n     * Controls the shard routing of the request. Using this value to hash the shard\n     * and not the id.\n     ",
      "vertexLabel": "GetRequestBuilder setRouting()"
    },
    {
      "vertexName": "Field INDEX_TRANSLOG_RETENTION_SIZE_SETTING  (IndexSettings.java)",
      "comment": "\n     * Controls how many translog files that are no longer needed for persistence reasons\n     * will be kept around before being deleted. Keeping more files is useful to increase\n     * the chance of ops based recoveries.\n     *",
      "vertexLabel": "Field INDEX_TRANSLOG_RETENTION_SIZE_SETTING"
    },
    {
      "vertexName": "Method public NumericDocValues select(final SortedNumericDocValues values)  (MultiValueMode.java)",
      "children": [
        {
          "name": "Method public BinaryDocValues select(final SortedBinaryDocValues values, final BytesRef missingValue)  (MultiValueMode.java)"
        }
      ],
      "comment": "\n     * Return a {@link NumericDocValues} instance that can be used to sort documents\n     * with this mode and the provided values. When a document has no value,\n     * <code>missingValue</code> is returned.\n     *\n     * Allowed Modes: SUM, AVG, MEDIAN, MIN, MAX\n     ",
      "vertexLabel": "NumericDocValues select()"
    },
    {
      "vertexName": "Method public static InjectionPoint forConstructorOf(Class<?> type)  (InjectionPoint.java)",
      "children": [
        {
          "name": "Method public static InjectionPoint forConstructorOf(TypeLiteral<?> type)  (InjectionPoint.java)"
        }
      ],
      "comment": "\n     * Returns a new injection point for the injectable constructor of {@code type}.\n     *\n     * @param type a concrete type with exactly one constructor annotated {@literal @}{@link Inject},\n     *             or a no-arguments constructor that is not private.\n     * @throws ConfigurationException if there is no injectable constructor, more than one injectable\n     *                                constructor, or if parameters of the injectable constructor are malformed, such as a\n     *                                parameter with multiple binding annotations.\n     ",
      "vertexLabel": "InjectionPoint forConstructorOf()"
    },
    {
      "vertexName": "Class ProviderLookup  (ProviderLookup.java)",
      "comment": "\n * A lookup of the provider for a type. Lookups are created explicitly in a module using\n * {@link org.elasticsearch.common.inject.Binder#getProvider(Class) getProvider()} statements:\n * <pre>\n *     Provider&lt;PaymentService&gt; paymentServiceProvider\n *         = getProvider(PaymentService.class);</pre>\n *\n * @author jessewilson@google.com (Jesse Wilson)\n * @since 2.0\n ",
      "vertexLabel": "Class ProviderLookup"
    },
    {
      "vertexName": "Method public void afterLoad(TermsEnum termsEnum, long actualUsed)  (PagedBytesIndexFieldData.java)",
      "children": [
        {
          "name": "Method void afterLoad(TermsEnum termsEnum, long actualUsed)  (AbstractIndexFieldData.java)"
        }
      ],
      "comment": "\n         * Adjust the circuit breaker now that terms have been loaded, getting\n         * the actual used either from the parameter (if estimation worked for\n         * the entire set), or from the TermsEnum if it has been wrapped in a\n         * RamAccountingTermsEnum.\n         *\n         * @param termsEnum  terms that were loaded\n         * @param actualUsed actual field data memory usage\n         ",
      "vertexLabel": "void afterLoad()"
    },
    {
      "vertexName": "Method public CreateIndexRequest mapping(String type, Object... source)  (CreateIndexRequest.java)",
      "comment": "\n     * A specialized simplified mapping source method, takes the form of simple properties definition:\n     * (\"field1\", \"type=string,store=true\").\n     ",
      "vertexLabel": "CreateIndexRequest mapping()"
    },
    {
      "vertexName": "Method public static String toString(ToXContent toXContent)  (Strings.java)",
      "comment": "\n     * Return a {@link String} that is the json representation of the provided {@link ToXContent}.\n     * Wraps the output into an anonymous object if needed. The content is not pretty-printed\n     * nor human readable.\n     ",
      "vertexLabel": "String toString()"
    },
    {
      "vertexName": "Method public static QueryValidationException addValidationErrors(List<String> validationErrors, QueryValidationException validationException)  (QueryValidationException.java)",
      "comment": "\n     * Helper method than can be used to add error messages to an existing {@link QueryValidationException}.\n     * When passing {@code null} as the initial exception, a new exception is created.\n     * @param validationErrors the error messages to add to an initial exception\n     * @param validationException an initial exception. Can be {@code null}, in which case a new exception is created.\n     * @return a {@link QueryValidationException} with added validation error message\n     ",
      "vertexLabel": "QueryValidationException addValidationErrors()"
    },
    {
      "vertexName": "Method boolean recoverFromStore(final IndexShard indexShard)  (StoreRecovery.java)",
      "children": [
        {
          "name": "Method boolean recoverFromRepository(final IndexShard indexShard, Repository repository)  (StoreRecovery.java)"
        }
      ],
      "comment": "\n     * Recovers a shard from it's local file system store. This method required pre-knowledge about if the shard should\n     * exist on disk ie. has been previously allocated or if the shard is a brand new allocation without pre-existing index\n     * files / transaction logs. This\n     * @param indexShard the index shard instance to recovery the shard into\n     * @return  <code>true</code> if the shard has been recovered successfully, <code>false</code> if the recovery\n     * has been ignored due to a concurrent modification of if the clusters state has changed due to async updates.\n     * @see Store\n     ",
      "vertexLabel": "boolean recoverFromStore()"
    },
    {
      "vertexName": "Method public static BucketOrder compound(BucketOrder... orders)  (BucketOrder.java)",
      "children": [
        {
          "name": "Method public static BucketOrder compound(List<BucketOrder> orders)  (BucketOrder.java)"
        }
      ],
      "comment": "\n     * Creates a bucket ordering strategy which sorts buckets based on multiple criteria. A tie-breaker may be added to\n     * avoid non-deterministic ordering.\n     *\n     * @param orders a list of {@link BucketOrder} parameters to sort on, in order of priority.\n     ",
      "vertexLabel": "BucketOrder compound()"
    },
    {
      "vertexName": "Class AbstractNumericDocValues  (AbstractNumericDocValues.java)",
      "children": [
        {
          "name": "Class AbstractSortedDocValues  (AbstractSortedDocValues.java)"
        }
      ],
      "comment": "\n * Base implementation that throws an {@link IOException} for the\n * {@link DocIdSetIterator} APIs. This impl is safe to use for sorting and\n * aggregations, which only use {@link #advanceExact(int)} and\n * {@link #longValue()}.\n ",
      "vertexLabel": "Class AbstractNumericDocValues"
    },
    {
      "vertexName": "Method public DateRangeAggregationBuilder addRange(String key, String from, String to)  (DateRangeAggregationBuilder.java)",
      "children": [
        {
          "name": "Method public DateRangeAggregationBuilder addUnboundedTo(String key, String to)  (DateRangeAggregationBuilder.java)"
        }
      ],
      "comment": "\n     * Add a new range to this aggregation.\n     *\n     * @param key\n     *            the key to use for this range in the response\n     * @param from\n     *            the lower bound on the dates, inclusive\n     * @param to\n     *            the upper bound on the dates, exclusive\n     ",
      "vertexLabel": "DateRangeAggregationBuilder addRange()"
    },
    {
      "vertexName": "Method public static Set<InjectionPoint> forInstanceMethodsAndFields(Class<?> type)  (InjectionPoint.java)",
      "children": [
        {
          "name": "Method public static Set<InjectionPoint> forInstanceMethodsAndFields(TypeLiteral<?> type)  (InjectionPoint.java)"
        }
      ],
      "comment": "\n     * Returns all instance method and field injection points on {@code type}.\n     *\n     * @return a possibly empty set of injection points. The set has a specified iteration order. All\n     *         fields are returned and then all methods. Within the fields, supertype fields are returned\n     *         before subtype fields. Similarly, supertype methods are returned before subtype methods.\n     * @throws ConfigurationException if there is a malformed injection point on {@code type}, such as\n     *                                a field with multiple binding annotations. The exception's {@link\n     *                                ConfigurationException#getPartialValue() partial value} is a {@code Set<InjectionPoint>}\n     *                                of the valid injection points.\n     ",
      "vertexLabel": "Set<InjectionPoint> forInstancesAndFields()"
    },
    {
      "vertexName": "Method public StopWatch start() throws IllegalStateException  (StopWatch.java)",
      "comment": "\n     * Start an unnamed task. The results are undefined if {@link #stop()}\n     * or timing methods are called without invoking this method.\n     *\n     * @see #stop()\n     ",
      "vertexLabel": "StopWatch start()"
    },
    {
      "vertexName": "Method public ClusterAllocationExplainRequest setCurrentNode(String currentNodeId)  (ClusterAllocationExplainRequest.java)",
      "comment": "\n     * Requests the explain API to explain an already assigned replica shard currently allocated to\n     * the given node.\n     ",
      "vertexLabel": "ClusterAllocationExplainRequest setCurrentNode()"
    },
    {
      "vertexName": "Method V visit(ConvertedConstantBinding<? extends T> binding)  (BindingTargetVisitor.java)",
      "children": [
        {
          "name": "Interface ConvertedConstantBinding  (ConvertedConstantBinding.java)"
        }
      ],
      "comment": "\n     * Visit a binding created from converting a bound instance to a new type. The source binding\n     * has the same binding annotation but a different type. This target is found only on injector\n     * bindings.\n     ",
      "vertexLabel": "V visit()"
    },
    {
      "vertexName": "Method void sendResponse(HttpResponse response, ActionListener<Void> listener)  (HttpChannel.java)",
      "children": [
        {
          "name": "Method void sendMessage(BytesReference reference, ActionListener<Void> listener)  (TcpChannel.java)"
        }
      ],
      "comment": "\n     * Sends an http response to the channel. The listener will be executed once the send process has been\n     * completed.\n     *\n     * @param response to send to channel\n     * @param listener to execute upon send completion\n     ",
      "vertexLabel": "void sendResponse()"
    },
    {
      "vertexName": "Method T get(Environment environment, String name) throws IOException  (AnalysisModule.java)",
      "children": [
        {
          "name": "Method T get(IndexSettings indexSettings, Environment environment, String name, Settings settings) throws IOException  (AnalysisModule.java)"
        }
      ],
      "comment": "\n         * Creates a new global scope analysis provider without index specific settings not settings for the provider itself.\n         * This can be used to get a default instance of an analysis factory without binding to an index.\n         *\n         * @param environment the nodes environment to load resources from persistent storage\n         * @param name        the name of the analysis component\n         * @return a new provider instance\n         * @throws IOException              if an {@link IOException} occurs\n         * @throws IllegalArgumentException if the provider requires analysis settings ie. if {@link #requiresAnalysisSettings()} returns\n         *                                  <code>true</code>\n         ",
      "vertexLabel": "T get()"
    },
    {
      "vertexName": "Method void postIndex(ShardId shardId, Engine.Index index, Engine.IndexResult result)  (IndexingOperationListener.java)",
      "comment": "\n     * Called after the indexing operation occurred. Note that this is\n     * also called when indexing a document did not succeed due to document\n     * related failures. See {@link #postIndex(ShardId, Engine.Index, Exception)}\n     * for engine level failures\n     ",
      "vertexLabel": "void postIndex()"
    },
    {
      "vertexName": "Method public MultiMatchQueryBuilder cutoffFrequency(float cutoff)  (MultiMatchQueryBuilder.java)",
      "children": [
        {
          "name": "Method public MatchQueryBuilder cutoffFrequency(float cutoff)  (MatchQueryBuilder.java)"
        }
      ],
      "comment": "\n     * Set a cutoff value in [0..1] (or absolute number &gt;=1) representing the\n     * maximum threshold of a terms document frequency to be considered a low\n     * frequency term.\n     ",
      "vertexLabel": "MultiMatchQueryBuilder cutoffFrequency()"
    },
    {
      "vertexName": "Method public DoubleArray newDoubleArray(long size, boolean clearOnResize)  (BigArrays.java)",
      "children": [
        {
          "name": "Method public FloatArray newFloatArray(long size, boolean clearOnResize)  (BigArrays.java)"
        }
      ],
      "comment": "\n     * Allocate a new {@link DoubleArray}.\n     * @param size          the initial length of the array\n     * @param clearOnResize whether values should be set to 0 on initialization and resize\n     ",
      "vertexLabel": "DoubleArray newDoubleArray()"
    },
    {
      "vertexName": "Method public static Setting<String> simpleString(String key, String defaultValue, Property... properties)  (Setting.java)",
      "comment": "\n     * Creates a new Setting instance with a String value\n     *\n     * @param key          the settings key for this setting.\n     * @param defaultValue the default String value.\n     * @param properties   properties for this setting like scope, filtering...\n     * @return the Setting Object\n     ",
      "vertexLabel": "Setting<String> simpleString()"
    },
    {
      "vertexName": "Method public Store.MetadataSnapshot snapshotStoreMetadata() throws IOException  (IndexShard.java)",
      "comment": "\n     * gets a {@link Store.MetadataSnapshot} for the current directory. This method is safe to call in all lifecycle of the index shard,\n     * without having to worry about the current state of the engine and concurrent flushes.\n     *\n     * @throws org.apache.lucene.index.IndexNotFoundException     if no index is found in the current directory\n     * @throws org.apache.lucene.index.CorruptIndexException      if the lucene index is corrupted. This can be caused by a checksum\n     *                                                            mismatch or an unexpected exception when opening the index reading the\n     *                                                            segments file.\n     * @throws org.apache.lucene.index.IndexFormatTooOldException if the lucene index is too old to be opened.\n     * @throws org.apache.lucene.index.IndexFormatTooNewException if the lucene index is too new to be opened.\n     * @throws java.io.FileNotFoundException                      if one or more files referenced by a commit are not present.\n     * @throws java.nio.file.NoSuchFileException                  if one or more files referenced by a commit are not present.\n     ",
      "vertexLabel": "Store.MetadataSnapshot snapshotStoreMetadata()"
    },
    {
      "vertexName": "Method public boolean shouldRollGeneration()  (Translog.java)",
      "children": [
        {
          "name": "Method public abstract boolean shouldRollTranslogGeneration()  (Engine.java)"
        }
      ],
      "comment": "\n     * Tests whether or not the translog generation should be rolled to a new generation. This test\n     * is based on the size of the current generation compared to the configured generation\n     * threshold size.\n     *\n     * @return {@code true} if the current generation should be rolled to a new generation\n     ",
      "vertexLabel": "boolean shouldRollGeneration()"
    },
    {
      "vertexName": "Method public DirectCandidateGeneratorBuilder maxEdits(Integer maxEdits)  (DirectCandidateGeneratorBuilder.java)",
      "comment": "\n     * Sets the maximum edit distance candidate suggestions can have in\n     * order to be considered as a suggestion. Can only be a value between 1\n     * and 2. Any other value result in an bad request error being thrown.\n     * Defaults to {@code 2}.\n     ",
      "vertexLabel": "DirectCandidateGeneratorBuilder maxEdits()"
    },
    {
      "vertexName": "Method public final void onModule(DiscoveryModule module)  (Plugin.java)",
      "children": [
        {
          "name": "Method public final void onModule(NetworkModule module)  (Plugin.java)"
        }
      ],
      "comment": "\n     * Old-style discovery extension point. {@code @Deprecated} and {@code final} to act as a signpost for plugin authors upgrading\n     * from 2.x.\n     *\n     * @deprecated implement {@link DiscoveryPlugin} instead\n     ",
      "vertexLabel": "final void onModule()"
    },
    {
      "vertexName": "Method public boolean isShardsAcknowledged()  (CreateIndexClusterStateUpdateResponse.java)",
      "comment": "\n     * Returns whether the requisite number of shard copies started before the completion of the operation.\n     ",
      "vertexLabel": "boolean isShardsAcknowledged()"
    },
    {
      "vertexName": "Method public static byte[] longToBytes(long val)  (Numbers.java)",
      "children": [
        {
          "name": "Method public static byte[] intToBytes(int val)  (Numbers.java)"
        }
      ],
      "comment": "\n     * Converts a long to a byte array.\n     *\n     * @param val The long to convert to a byte array\n     * @return The byte array converted\n     ",
      "vertexLabel": "byte[] longToBytes()"
    },
    {
      "vertexName": "Method public static NumericDoubleValues replaceMissing(NumericDoubleValues values, double missing)  (FieldData.java)",
      "children": [
        {
          "name": "Method public static NumericDocValues replaceMissing(NumericDocValues values, long missing)  (FieldData.java)"
        }
      ],
      "comment": "\n     * Return a {@link NumericDoubleValues} instance that has a value for every\n     * document, returns the same value as {@code values} if there is a value\n     * for the current document and {@code missing} otherwise.\n     ",
      "vertexLabel": "NumericDoubleValues replaceMissing()"
    },
    {
      "vertexName": "Method public Version getLargestNonClientNodeVersion()  (DiscoveryNodes.java)",
      "children": [
        {
          "name": "Method public Version getSmallestNonClientNodeVersion()  (DiscoveryNodes.java)"
        },
        {
          "name": "Method public Version getMaxNodeVersion()  (DiscoveryNodes.java)"
        }
      ],
      "comment": "\n     * Returns the version of the node with the youngest version in the cluster that is not a client node.\n     *\n     * If there are no non-client nodes, Version.CURRENT will be returned.\n     *\n     * @return the youngest version in the cluster\n     ",
      "vertexLabel": "Version getLargestNonClientNodeVersion()"
    },
    {
      "vertexName": "Method public static AffixSetting<T> prefixKeySetting(String prefix, Function<String, Setting<T>> delegateFactory)  (Setting.java)",
      "comment": "\n     * This setting type allows to validate settings that have the same type and a common prefix. For instance feature.${type}=[true|false]\n     * can easily be added with this setting. Yet, prefix key settings don't support updaters out of the box unless\n     * {@link #getConcreteSetting(String)} is used to pull the updater.\n     ",
      "vertexLabel": "AffixSetting<T> prefixKeySetting()"
    },
    {
      "vertexName": "Method static ActionListener<Response> wrap(CheckedConsumer<Response, ? extends Exception> onResponse, Consumer<Exception> onFailure)  (ActionListener.java)",
      "children": [
        {
          "name": "Method static ActionListener<Response> wrap(Runnable runnable)  (ActionListener.java)"
        }
      ],
      "comment": "\n     * Creates a listener that listens for a response (or failure) and executes the\n     * corresponding consumer when the response (or failure) is received.\n     *\n     * @param onResponse the checked consumer of the response, when the listener receives one\n     * @param onFailure the consumer of the failure, when the listener receives one\n     * @param <Response> the type of the response\n     * @return a listener that listens for responses and invokes the consumer when received\n     ",
      "vertexLabel": "ActionListener<Response> wrap()"
    },
    {
      "vertexName": "Method public PutIndexTemplateRequestBuilder addMapping(String type, Object... source)  (PutIndexTemplateRequestBuilder.java)",
      "children": [
        {
          "name": "Method public CreateIndexRequest mapping(String type, Object... source)  (CreateIndexRequest.java)"
        }
      ],
      "comment": "\n     * A specialized simplified mapping source method, takes the form of simple properties definition:\n     * (\"field1\", \"type=string,store=true\").\n     ",
      "vertexLabel": "PutIndexTemplateRequestBuilder addMapping()"
    },
    {
      "vertexName": "Method public final boolean tryIncRef()  (Store.java)",
      "children": [
        {
          "name": "Method public final void incRef()  (Store.java)"
        }
      ],
      "comment": "\n     * Tries to increment the refCount of this Store instance. This method will return {@code true} iff the refCount was\n     * incremented successfully otherwise {@code false}. RefCounts are used to determine when a\n     * Store can be closed safely, i.e. as soon as there are no more references. Be sure to always call a\n     * corresponding {@link #decRef}, in a finally clause; otherwise the store may never be closed.  Note that\n     * {@link #close} simply calls decRef(), which means that the Store will not really be closed until {@link\n     * #decRef} has been called for all outstanding references.\n     * <p>\n     * Note: Close can safely be called multiple times.\n     *\n     * @see #decRef()\n     * @see #incRef()\n     ",
      "vertexLabel": "final boolean tryIncRef()"
    },
    {
      "vertexName": "Method public void addIndexOperationListener(IndexingOperationListener listener)  (IndexModule.java)",
      "children": [
        {
          "name": "Method public void addIndexEventListener(IndexEventListener listener)  (IndexModule.java)"
        }
      ],
      "comment": "\n     * Adds an {@link IndexingOperationListener} for this index. All listeners added here\n     * are maintained for the entire index lifecycle on this node. Once an index is closed or deleted these\n     * listeners go out of scope.\n     * <p>\n     * Note: an index might be created on a node multiple times. For instance if the last shard from an index is\n     * relocated to another node the internal representation will be destroyed which includes the registered listeners.\n     * Once the node holds at least one shard of an index all modules are reloaded and listeners are registered again.\n     * Listeners can't be unregistered they will stay alive for the entire time the index is allocated on a node.\n     * </p>\n     ",
      "vertexLabel": "void addIndexOperationListener()"
    },
    {
      "vertexName": "Method void listTasks(ListTasksRequest request, ActionListener<ListTasksResponse> listener)  (ClusterAdminClient.java)",
      "comment": "\n     * List active tasks\n     *\n     * @param request  The nodes tasks request\n     * @param listener A listener to be notified with a result\n     * @see org.elasticsearch.client.Requests#listTasksRequest()\n     ",
      "vertexLabel": "void listTasks()"
    },
    {
      "vertexName": "Method public String getLang()  (Script.java)",
      "comment": "\n     * @return The language for this {@link Script} if the {@link ScriptType} is {@link ScriptType#INLINE}.\n     *         For {@link ScriptType#STORED} scripts this should be null, but can\n     *         be specified to access scripts stored as part of the stored scripts deprecated API.\n     ",
      "vertexLabel": "String getLang()"
    },
    {
      "vertexName": "Method public boolean detailed()  (RecoveryRequest.java)",
      "comment": "\n     * True if detailed flag is set, false otherwise. This value if false by default.\n     *\n     * @return  True if detailed flag is set, false otherwise\n     ",
      "vertexLabel": "boolean detailed()"
    },
    {
      "vertexName": "Method public GetRequestBuilder setFetchSource(@Nullable String[] includes, @Nullable String[] excludes)  (GetRequestBuilder.java)",
      "children": [
        {
          "name": "Method public ExplainRequestBuilder setFetchSource(@Nullable String[] includes, @Nullable String[] excludes)  (ExplainRequestBuilder.java)"
        }
      ],
      "comment": "\n     * Indicate that _source should be returned, with an \"include\" and/or \"exclude\" set which can include simple wildcard\n     * elements.\n     *\n     * @param includes An optional list of include (optionally wildcarded) pattern to filter the returned _source\n     * @param excludes An optional list of exclude (optionally wildcarded) pattern to filter the returned _source\n     ",
      "vertexLabel": "GetRequestBuilder setFetchSource()"
    },
    {
      "vertexName": "Method public final void onModule(ActionModule module)  (Plugin.java)",
      "comment": "\n     * Old-style action extension point. {@code @Deprecated} and {@code final} to act as a signpost for plugin authors upgrading\n     * from 2.x.\n     *\n     * @deprecated implement {@link ActionPlugin} instead\n     ",
      "vertexLabel": "final void onModule()"
    },
    {
      "vertexName": "Method public Set<String> changedCustomMetaDataSet()  (ClusterChangedEvent.java)",
      "children": [
        {
          "name": "Method public boolean metaDataChanged()  (ClusterChangedEvent.java)"
        }
      ],
      "comment": "\n     * Returns a set of custom meta data types when any custom metadata for the cluster has changed\n     * between the previous cluster state and the new cluster state. custom meta data types are\n     * returned iff they have been added, updated or removed between the previous and the current state\n     ",
      "vertexLabel": "Set<String> changedCustomMetaDataSet()"
    },
    {
      "vertexName": "Method Object getExposedSource(Key<?> key)  (PrivateElements.java)",
      "children": [
        {
          "name": "Method Object getSource()  (Element.java)"
        }
      ],
      "comment": "\n     * Returns an arbitrary object containing information about the \"place\" where this key was\n     * exposed. Used by Guice in the production of descriptive error messages.\n     * <p>\n     * Tools might specially handle types they know about; {@code StackTraceElement} is a good\n     * example. Tools should simply call {@code toString()} on the source object if the type is\n     * unfamiliar.\n     *\n     * @param key one of the keys exposed by this module.\n     ",
      "vertexLabel": "Object getExposedSource()"
    },
    {
      "vertexName": "Method public IndicesShardStoreRequestBuilder setShardStatuses(String... shardStatuses)  (IndicesShardStoreRequestBuilder.java)",
      "comment": "\n     * Set statuses to filter shards to get stores info on.\n     * @param shardStatuses acceptable values are \"green\", \"yellow\", \"red\" and \"all\"\n     * see {@link ClusterHealthStatus} for details\n     ",
      "vertexLabel": "IndicesShardStoreRequestBuilder setShardStatuses()"
    },
    {
      "vertexName": "Method public BinaryDocValues select(final SortedBinaryDocValues values, final BytesRef missingValue)  (MultiValueMode.java)",
      "children": [
        {
          "name": "Method public SortedDocValues select(final SortedSetDocValues values)  (MultiValueMode.java)"
        }
      ],
      "comment": "\n     * Return a {@link BinaryDocValues} instance that can be used to sort documents\n     * with this mode and the provided values. When a document has no value,\n     * <code>missingValue</code> is returned.\n     *\n     * Allowed Modes: MIN, MAX\n     ",
      "vertexLabel": "BinaryDocValues select()"
    },
    {
      "vertexName": "Method public void setType(MultiMatchQueryBuilder.Type type)  (QueryStringQueryParser.java)",
      "children": [
        {
          "name": "Method public QueryStringQueryBuilder type(MultiMatchQueryBuilder.Type type)  (QueryStringQueryBuilder.java)"
        }
      ],
      "comment": "\n     * @param type Sets how multiple fields should be combined to build textual part queries.\n     ",
      "vertexLabel": "void setType()"
    },
    {
      "vertexName": "Method public BaseTermQueryBuilder(String fieldName, boolean value)  (BaseTermQueryBuilder.java)",
      "children": [
        {
          "name": "Method public BaseTermQueryBuilder(String fieldName, float value)  (BaseTermQueryBuilder.java)"
        }
      ],
      "comment": "\n     * Constructs a new base term query.\n     *\n     * @param fieldName  The name of the field\n     * @param value The value of the term\n     ",
      "vertexLabel": "BaseTermQueryBuilder()"
    },
    {
      "vertexName": "Method public Script(ScriptType type, String lang, String idOrCode, Map<String, Object> params)  (Script.java)",
      "children": [
        {
          "name": "Method public String getLang()  (Script.java)"
        }
      ],
      "comment": "\n     * Constructor for a script that does not need to use compiler options.\n     * @param type     The {@link ScriptType}.\n     * @param lang     The language for this {@link Script} if the {@link ScriptType} is {@link ScriptType#INLINE}.\n     *                 For {@link ScriptType#STORED} scripts this should be null, but can\n     *                 be specified to access scripts stored as part of the stored scripts deprecated API.\n     * @param idOrCode The id for this {@link Script} if the {@link ScriptType} is {@link ScriptType#STORED}.\n     *                 The code for this {@link Script} if the {@link ScriptType} is {@link ScriptType#INLINE}.\n     * @param params   The user-defined params to be bound for script execution.\n     ",
      "vertexLabel": "Script()"
    },
    {
      "vertexName": "Method private static Lambda parseLambda(Settings settings)  (SimilarityProviders.java)",
      "comment": "\n     * Parses the given Settings and creates the appropriate {@link Lambda}\n     *\n     * @param settings Settings to parse\n     * @return {@link Normalization} referred to in the Settings\n     ",
      "vertexLabel": "Lambda parseLambda()"
    },
    {
      "vertexName": "Method public RestoreSnapshotRequest waitForCompletion(boolean waitForCompletion)  (RestoreSnapshotRequest.java)",
      "comment": "\n     * If this parameter is set to true the operation will wait for completion of restore process before returning.\n     *\n     * @param waitForCompletion if true the operation will wait for completion\n     * @return this request\n     ",
      "vertexLabel": "RestoreSnapshotRequest waitForCompletion()"
    },
    {
      "vertexName": "Method public static DisMaxQueryBuilder disMaxQuery()  (QueryBuilders.java)",
      "children": [
        {
          "name": "Class DisMaxQueryBuilder  (DisMaxQueryBuilder.java)"
        }
      ],
      "comment": "\n     * A query that generates the union of documents produced by its sub-queries, and that scores each document\n     * with the maximum score for that document as produced by any sub-query, plus a tie breaking increment for any\n     * additional matching sub-queries.\n     ",
      "vertexLabel": "DisMaxQueryBuilder disMaxQuery()"
    },
    {
      "vertexName": "Method public static BucketOrder count(boolean asc)  (BucketOrder.java)",
      "comment": "\n     * Creates a bucket ordering strategy that sorts buckets by their document counts (ascending or descending).\n     *\n     * @param asc direction to sort by: {@code true} for ascending, {@code false} for descending.\n     ",
      "vertexLabel": "BucketOrder count()"
    },
    {
      "vertexName": "Method private CollapsingTopDocsCollectorContext(CollapseContext collapseContext, @Nullable SortAndFormats sortAndFormats, int numHits, boolean trackMaxScore)  (TopDocsCollectorContext.java)",
      "comment": "\n         * Ctr\n         * @param collapseContext The collapsing context\n         * @param sortAndFormats The query sort\n         * @param numHits The number of collapsed top hits to retrieve.\n         * @param trackMaxScore True if max score should be tracked\n         ",
      "vertexLabel": "CollapsingTopDocsCollectorContext()"
    },
    {
      "vertexName": "Method public void removeField(String path)  (IngestDocument.java)",
      "comment": "\n     * Removes the field identified by the provided path.\n     * @param path the path of the field to be removed\n     * @throws IllegalArgumentException if the path is null, empty, invalid or if the field doesn't exist.\n     ",
      "vertexLabel": "void removeField()"
    },
    {
      "vertexName": "Method public void setWaitForActiveShards(ActiveShardCount waitForActiveShards)  (ResizeRequest.java)",
      "children": [
        {
          "name": "Method public CreateIndexRequest waitForActiveShards(ActiveShardCount waitForActiveShards)  (CreateIndexRequest.java)"
        }
      ],
      "comment": "\n     * Sets the number of shard copies that should be active for creation of the\n     * new shrunken index to return. Defaults to {@link ActiveShardCount#DEFAULT}, which will\n     * wait for one shard copy (the primary) to become active. Set this value to\n     * {@link ActiveShardCount#ALL} to wait for all shards (primary and all replicas) to be active\n     * before returning. Otherwise, use {@link ActiveShardCount#from(int)} to set this value to any\n     * non-negative integer, up to the number of copies per shard (number of replicas + 1),\n     * to wait for the desired amount of shard copies to become active before returning.\n     * Index creation will only wait up until the timeout value for the number of shard copies\n     * to be active before returning.  Check {@link ResizeResponse#isShardsAcknowledged()} to\n     * determine if the requisite shard copies were all started before returning or timing out.\n     *\n     * @param waitForActiveShards number of active shard copies to wait on\n     ",
      "vertexLabel": "void setWaitForActiveShards()"
    },
    {
      "vertexName": "Method public SearchRequest searchType(String searchType)  (SearchRequest.java)",
      "children": [
        {
          "name": "Method public static SearchType fromString(String searchType)  (SearchType.java)"
        }
      ],
      "comment": "\n     * The a string representation search type to execute, defaults to {@link SearchType#DEFAULT}. Can be\n     * one of \"dfs_query_then_fetch\"/\"dfsQueryThenFetch\", \"dfs_query_and_fetch\"/\"dfsQueryAndFetch\",\n     * \"query_then_fetch\"/\"queryThenFetch\", and \"query_and_fetch\"/\"queryAndFetch\".\n     ",
      "vertexLabel": "SearchRequest searchType()"
    },
    {
      "vertexName": "Method public CreateSnapshotRequestBuilder(ElasticsearchClient client, CreateSnapshotAction action, String repository, String snapshot)  (CreateSnapshotRequestBuilder.java)",
      "children": [
        {
          "name": "Method public RestoreSnapshotRequestBuilder(ElasticsearchClient client, RestoreSnapshotAction action, String repository, String name)  (RestoreSnapshotRequestBuilder.java)"
        }
      ],
      "comment": "\n     * Constructs a new create snapshot request builder with specified repository and snapshot names\n     ",
      "vertexLabel": "CreateSnapshotRequestBuilder()"
    },
    {
      "vertexName": "Method public UpdateRequest fetchSource(@Nullable String include, @Nullable String exclude)  (UpdateRequest.java)",
      "children": [
        {
          "name": "Method public SearchRequestBuilder setFetchSource(@Nullable String include, @Nullable String exclude)  (SearchRequestBuilder.java)"
        }
      ],
      "comment": "\n     * Indicate that _source should be returned with every hit, with an\n     * \"include\" and/or \"exclude\" set which can include simple wildcard\n     * elements.\n     *\n     * @param include\n     *            An optional include (optionally wildcarded) pattern to filter\n     *            the returned _source\n     * @param exclude\n     *            An optional exclude (optionally wildcarded) pattern to filter\n     *            the returned _source\n     ",
      "vertexLabel": "UpdateRequest fetchSource()"
    },
    {
      "vertexName": "Method public MovAvgPipelineAggregationBuilder predict(int predict)  (MovAvgPipelineAggregationBuilder.java)",
      "children": [
        {
          "name": "Method public int predict()  (MovAvgPipelineAggregationBuilder.java)"
        }
      ],
      "comment": "\n     * Sets the number of predictions that should be returned. Each\n     * prediction will be spaced at the intervals specified in the\n     * histogram. E.g \"predict: 2\" will return two new buckets at the end of\n     * the histogram with the predicted values.\n     *\n     * @param predict\n     *            Number of predictions to make\n     ",
      "vertexLabel": "MovAvgPipelineAggregationBuilder predict()"
    },
    {
      "vertexName": "Method public static CancelTasksRequest cancelTasksRequest()  (Requests.java)",
      "children": [
        {
          "name": "Method public static ListTasksRequest listTasksRequest()  (Requests.java)"
        }
      ],
      "comment": "\n     * Creates a nodes tasks request against one or more nodes. Pass {@code null} or an empty array for all nodes.\n     *\n     * @return The nodes tasks request\n     * @see org.elasticsearch.client.ClusterAdminClient#cancelTasks(CancelTasksRequest)\n     ",
      "vertexLabel": "CancelTasksRequest cancelTasksRequest()"
    },
    {
      "vertexName": "Method protected LeafOnly(StreamInput in, ValuesSourceType valuesSourceType) throws IOException  (ValuesSourceAggregationBuilder.java)",
      "children": [
        {
          "name": "Method protected ValuesSourceAggregationBuilder(StreamInput in, ValuesSourceType valuesSourceType) throws IOException  (ValuesSourceAggregationBuilder.java)"
        }
      ],
      "comment": "\n         * Read an aggregation from a stream that serializes its targetValueType. This should only be used by subclasses that override\n         * {@link #serializeTargetValueType()} to return true.\n         ",
      "vertexLabel": "LeafOnly()"
    },
    {
      "vertexName": "Method public static double[] holtWintersForecast(double[] values, double alpha, double beta, double gamma, int period, double padding, boolean multiplicative, int numForecasts)  (MovingFunctions.java)",
      "children": [
        {
          "name": "Method public static double[] holtForecast(double[] values, double alpha, double beta, int numForecasts)  (MovingFunctions.java)"
        }
      ],
      "comment": "\n     * Version of holt-winters that can \"forecast\", not exposed as a whitelisted function for moving_fn scripts, but\n     * here as compatibility/code sharing for existing moving_avg agg.  Can be removed when moving_avg is gone.\n     ",
      "vertexLabel": "double[] holtWintersForecast()"
    },
    {
      "vertexName": "Method public MoreLikeThisQueryBuilder maxDocFreq(int maxDocFreq)  (MoreLikeThisQueryBuilder.java)",
      "comment": "\n     * Set the maximum frequency in which words may still appear. Words that appear\n     * in more than this many docs will be ignored. Defaults to unbounded.\n     ",
      "vertexLabel": "MoreLikeThisQueryBuilder maxDocFreq()"
    },
    {
      "vertexName": "Method private SnapshotShardFailure(@Nullable String nodeId, ShardId shardId, String reason, RestStatus status)  (SnapshotShardFailure.java)",
      "children": [
        {
          "name": "Method public SnapshotShardFailure(@Nullable String nodeId, ShardId shardId, String reason)  (SnapshotShardFailure.java)"
        }
      ],
      "comment": "\n     * Constructs new snapshot shard failure object\n     *\n     * @param nodeId  node where failure occurred\n     * @param shardId shard id\n     * @param reason  failure reason\n     * @param status  rest status\n     ",
      "vertexLabel": "SnapshotShardFailure()"
    },
    {
      "vertexName": "Method public static GeoShapeQueryBuilder geoWithinQuery(String name, ShapeBuilder shape) throws IOException  (QueryBuilders.java)",
      "children": [
        {
          "name": "Method public static GeoShapeQueryBuilder geoIntersectionQuery(String name, ShapeBuilder shape) throws IOException  (QueryBuilders.java)"
        }
      ],
      "comment": "\n     * A filter to filter indexed shapes that are contained by a shape\n     *\n     * @param name  The shape field name\n     * @param shape Shape to use in the filter\n     ",
      "vertexLabel": "GeoShapeQueryBuilder geoWithinQuery()"
    },
    {
      "vertexName": "Method public static int geoHashLevelsForPrecision(double meters)  (GeoUtils.java)",
      "children": [
        {
          "name": "Method public static int quadTreeLevelsForPrecision(double meters)  (GeoUtils.java)"
        }
      ],
      "comment": "\n     * Calculate the number of levels needed for a specific precision. GeoHash\n     * cells will not exceed the specified size (diagonal) of the precision.\n     * @param meters Maximum size of cells in meters (must greater or equal to zero)\n     * @return levels need to achieve precision\n     ",
      "vertexLabel": "int geoHashLevelsForPrecision()"
    },
    {
      "vertexName": "Method public static boolean simpleMatch(String[] patterns, String str)  (Regex.java)",
      "children": [
        {
          "name": "Method public static boolean simpleMatch(String pattern, String str)  (Regex.java)"
        }
      ],
      "comment": "\n     * Match a String against the given patterns, supporting the following simple\n     * pattern styles: \"xxx*\", \"*xxx\", \"*xxx*\" and \"xxx*yyy\" matches (with an\n     * arbitrary number of pattern parts), as well as direct equality.\n     *\n     * @param patterns the patterns to match against\n     * @param str      the String to match\n     * @return whether the String matches any of the given patterns\n     ",
      "vertexLabel": "boolean simpleMatch()"
    },
    {
      "vertexName": "Method public static double holt(double[] values, double alpha, double beta)  (MovingFunctions.java)",
      "children": [
        {
          "name": "Method public static double ewma(double[] values, double alpha)  (MovingFunctions.java)"
        }
      ],
      "comment": "\n     * Calculate a doubly exponential weighted moving average\n     *\n     * Alpha controls the smoothing of the data.  Alpha = 1 retains no memory of past values\n     * (e.g. a random walk), while alpha = 0 retains infinite memory of past values (e.g.\n     * the series mean).  Useful values are somewhere in between.  Defaults to 0.5.\n     *\n     * Beta is equivalent to alpha, but controls the smoothing of the trend instead of the data\n     *\n     * Only finite values are averaged.  NaN or null are ignored.\n     * If all values are missing/null/NaN, the return value will be NaN\n     * The average is based on the count of non-null, non-NaN values.\n     *\n     * @param alpha A double between 0-1 inclusive, controls data smoothing\n     * @param beta a double between 0-1 inclusive, controls trend smoothing\n     ",
      "vertexLabel": "double holt()"
    },
    {
      "vertexName": "Method public SearchSourceBuilder fetchSource(@Nullable String[] includes, @Nullable String[] excludes)  (SearchSourceBuilder.java)",
      "children": [
        {
          "name": "Method public TopHitsAggregationBuilder fetchSource(@Nullable String[] includes, @Nullable String[] excludes)  (TopHitsAggregationBuilder.java)"
        }
      ],
      "comment": "\n     * Indicate that _source should be returned with every hit, with an\n     * \"include\" and/or \"exclude\" set which can include simple wildcard\n     * elements.\n     *\n     * @param includes\n     *            An optional list of include (optionally wildcarded) pattern to\n     *            filter the returned _source\n     * @param excludes\n     *            An optional list of exclude (optionally wildcarded) pattern to\n     *            filter the returned _source\n     ",
      "vertexLabel": "SearchSourceBuilder fetchSource()"
    },
    {
      "vertexName": "Method void injectMembers(T instance)  (MembersInjector.java)",
      "comment": "\n     * Injects dependencies into the fields and methods of {@code instance}. Ignores the presence or\n     * absence of an injectable constructor.\n     * <p>\n     * Whenever Guice creates an instance, it performs this injection automatically (after first\n     * performing constructor injection), so if you're able to let Guice create all your objects for\n     * you, you'll never need to use this method.\n     *\n     * @param instance to inject members on. May be {@code null}.\n     ",
      "vertexLabel": "void injectMembers()"
    },
    {
      "vertexName": "Method public static double geoHashCellSize(int level)  (GeoUtils.java)",
      "comment": "\n     * Calculate the size (in meters) of geohash cells at a specific level\n     * @param level geohash level must be greater or equal to zero\n     * @return the size of cells at level in meters\n     ",
      "vertexLabel": "double geoHashCellSize()"
    },
    {
      "vertexName": "Class RealMapBinder  (MapBinder.java)",
      "children": [
        {
          "name": "Class RealMultibinder  (Multibinder.java)"
        }
      ],
      "comment": "\n     * The actual mapbinder plays several roles:\n     * <p>\n     * As a MapBinder, it acts as a factory for LinkedBindingBuilders for\n     * each of the map's values. It delegates to a {@link Multibinder} of\n     * entries (keys to value providers).\n     * <p>\n     * As a Module, it installs the binding to the map itself, as well as to\n     * a corresponding map whose values are providers. It uses the entry set\n     * multibinder to construct the map and the provider map.\n     * <p>\n     * As a module, this implements equals() and hashcode() in order to trick\n     * Guice into executing its configure() method only once. That makes it so\n     * that multiple mapbinders can be created for the same target map, but\n     * only one is bound. Since the list of bindings is retrieved from the\n     * injector itself (and not the mapbinder), each mapbinder has access to\n     * all contributions from all equivalent mapbinders.\n     * <p>\n     * Rather than binding a single Map.Entry&lt;K, V&gt;, the map binder\n     * binds keys and values independently. This allows the values to be properly\n     * scoped.\n     * <p>\n     * We use a subclass to hide 'implements Module' from the public API.\n     ",
      "vertexLabel": "Class RealMapBinder"
    },
    {
      "vertexName": "Method public ClusterSearchShardsRequestBuilder setRouting(String routing)  (ClusterSearchShardsRequestBuilder.java)",
      "children": [
        {
          "name": "Method public SearchRequestBuilder setRouting(String routing)  (SearchRequestBuilder.java)"
        }
      ],
      "comment": "\n     * A comma separated list of routing values to control the shards the search will be executed on.\n     ",
      "vertexLabel": "ClusterSearchShardsRequestBuilder setRouting()"
    },
    {
      "vertexName": "Method public CreateSnapshotRequestBuilder setSettings(String source, XContentType xContentType)  (CreateSnapshotRequestBuilder.java)",
      "children": [
        {
          "name": "Method public CreateSnapshotRequest settings(String source, XContentType xContentType)  (CreateSnapshotRequest.java)"
        }
      ],
      "comment": "\n     * Sets repository-specific snapshot settings in YAML or JSON format\n     * <p>\n     * See repository documentation for more information.\n     *\n     * @param source repository-specific snapshot settings\n     * @param xContentType the content type of the source\n     * @return this builder\n     ",
      "vertexLabel": "CreateSnapshotRequestBuilder setSettings()"
    },
    {
      "vertexName": "Method protected DecayFunctionBuilder(String fieldName, Object origin, Object scale, Object offset, double decay)  (DecayFunctionBuilder.java)",
      "children": [
        {
          "name": "Method protected DecayFunctionBuilder(String fieldName, Object origin, Object scale, Object offset)  (DecayFunctionBuilder.java)"
        }
      ],
      "comment": "\n     * Convenience constructor that converts its parameters into json to parse on the data nodes.\n     ",
      "vertexLabel": "DecayFunctionBuilder()"
    },
    {
      "vertexName": "EnumConstant INTERNAL  (TermSuggestionBuilder.java)",
      "comment": " This is the default and is based on <code>damerau_levenshtein</code>, but highly optimized\n         * for comparing string distance for terms inside the index. ",
      "vertexLabel": "EnumConstant INTERNAL"
    },
    {
      "vertexName": "Method public void waitForPersistentTask(final Predicate<PersistentTasksCustomMetaData.PersistentTask<?>> predicate, @Nullable final TimeValue timeout, final PersistentTasksService.WaitForPersistentTaskListener<?> listener)  (AllocatedPersistentTask.java)",
      "children": [
        {
          "name": "Method public void waitForPersistentTasksCondition(final Predicate<PersistentTasksCustomMetaData> predicate, @Nullable final TimeValue timeout, final ActionListener<Boolean> listener)  (PersistentTasksService.java)"
        }
      ],
      "comment": "\n     * Waits for a given persistent task to comply with a given predicate, then call back the listener accordingly.\n     *\n     * @param predicate the persistent task predicate to evaluate\n     * @param timeout a timeout for waiting\n     * @param listener the callback listener\n     ",
      "vertexLabel": "void waitForPersistentTask()"
    },
    {
      "vertexName": "EnumConstant CREATED  (RestStatus.java)",
      "comment": "\n     * The request has been fulfilled and resulted in a new resource being created. The newly created resource can\n     * be referenced by the URI(s) returned in the entity of the response, with the most specific URI for the\n     * resource given by a Location header field. The response SHOULD include an entity containing a list of resource\n     * characteristics and location(s) from which the user or user agent can choose the one most appropriate. The\n     * entity format is specified by the media type given in the Content-Type header field. The origin server MUST\n     * create the resource before returning the 201 status code. If the action cannot be carried out immediately, the\n     * server SHOULD respond with 202 (Accepted) response instead.\n     * <p>\n     * A 201 response MAY contain an ETag response header field indicating the current value of the entity tag\n     * for the requested variant just created, see section 14.19.\n     ",
      "vertexLabel": "EnumConstant CREATED"
    },
    {
      "vertexName": "Method public DirectCandidateGeneratorBuilder sort(String sort)  (DirectCandidateGeneratorBuilder.java)",
      "comment": "\n     * Sets how to sort the suggest terms per suggest text token. Two\n     * possible values:\n     * <ol>\n     * <li><code>score</code> - Sort should first be based on score, then\n     * document frequency and then the term itself.\n     * <li><code>frequency</code> - Sort should first be based on document\n     * frequency, then score and then the term itself.\n     * </ol>\n     * <p>\n     * What the score is depends on the suggester being used.\n     ",
      "vertexLabel": "DirectCandidateGeneratorBuilder sort()"
    },
    {
      "vertexName": "Method public SizeValue getAsSize(String setting, SizeValue defaultValue) throws SettingsException  (Settings.java)",
      "children": [
        {
          "name": "Method public ByteSizeValue getAsBytesSize(String setting, ByteSizeValue defaultValue) throws SettingsException  (Settings.java)"
        }
      ],
      "comment": "\n     * Returns the setting value (as size) associated with the setting key. If it does not exists,\n     * returns the default value provided.\n     ",
      "vertexLabel": "SizeValue getAsSize()"
    },
    {
      "vertexName": "Method public SearchRequestBuilder addStoredField(String field)  (SearchRequestBuilder.java)",
      "comment": "\n     * Adds a stored field to load and return (note, it must be stored) as part of the search request.\n     ",
      "vertexLabel": "SearchRequestBuilder addStoredField()"
    },
    {
      "vertexName": "Method IndexRequestBuilder prepareIndex(String index, String type)  (Client.java)",
      "children": [
        {
          "name": "Method IndexRequestBuilder prepareIndex()  (Client.java)"
        }
      ],
      "comment": "\n     * Index a document associated with a given index and type.\n     * <p>\n     * The id is optional, if it is not provided, one will be generated automatically.\n     *\n     * @param index The index to index the document to\n     * @param type  The type to index the document to\n     ",
      "vertexLabel": "IndexRequestBuilder prepareIndex()"
    },
    {
      "vertexName": "Class SettingsBasedHostsProvider  (SettingsBasedHostsProvider.java)",
      "comment": "\n * An implementation of {@link UnicastHostsProvider} that reads hosts/ports\n * from the \"discovery.zen.ping.unicast.hosts\" node setting. If the port is\n * left off an entry, a default port of 9300 is assumed.\n *\n * An example unicast hosts setting might look as follows:\n * [67.81.244.10, 67.81.244.11:9305, 67.81.244.15:9400]\n ",
      "vertexLabel": "Class SettingsBasedHostsProvider"
    },
    {
      "vertexName": "Method public static BucketOrder readOrder(StreamInput in) throws IOException  (InternalOrder.java)",
      "comment": "\n         * Read a {@link BucketOrder} from a {@link StreamInput}.\n         *\n         * @param in stream with order data to read.\n         * @return order read from the stream\n         * @throws IOException on error reading from the stream.\n         ",
      "vertexLabel": "BucketOrder readOrder()"
    },
    {
      "vertexName": "EnumConstant MULTIPLE_CHOICES  (RestStatus.java)",
      "children": [
        {
          "name": "EnumConstant CREATED  (RestStatus.java)"
        }
      ],
      "comment": "\n     * The requested resource corresponds to any one of a set of representations, each with its own specific\n     * location, and agent-driven negotiation information (section 12) is being provided so that the user (or user\n     * agent) can select a preferred representation and redirect its request to that location.\n     * <p>\n     * Unless it was a HEAD request, the response SHOULD include an entity containing a list of resource\n     * characteristics and location(s) from which the user or user agent can choose the one most appropriate.\n     * The entity format is specified by the media type given in the Content-Type header field. Depending upon the\n     * format and the capabilities of the user agent, selection of the most appropriate choice MAY be performed\n     * automatically. However, this specification does not define any standard for such automatic selection.\n     * <p>\n     * If the server has a preferred choice of representation, it SHOULD include the specific URI for that\n     * representation in the Location field; user agents MAY use the Location field value for automatic redirection.\n     * This response is cacheable unless indicated otherwise.\n     ",
      "vertexLabel": "EnumConstant MULTIPLE_CHOICES"
    },
    {
      "vertexName": "Class BigObjectArray  (BigObjectArray.java)",
      "children": [
        {
          "name": "Class BigIntArray  (BigIntArray.java)"
        }
      ],
      "comment": "\n * Int array abstraction able to support more than 2B values. This implementation slices data into fixed-sized blocks of\n * configurable length.\n ",
      "vertexLabel": "Class BigObjectArray"
    },
    {
      "vertexName": "Method public RestoreSnapshotRequestBuilder setRenameReplacement(String renameReplacement)  (RestoreSnapshotRequestBuilder.java)",
      "children": [
        {
          "name": "Method public RestoreSnapshotRequest renameReplacement(String renameReplacement)  (RestoreSnapshotRequest.java)"
        }
      ],
      "comment": "\n     * Sets rename replacement\n     * <p>\n     * See {@link #setRenamePattern(String)} for more information.\n     *\n     * @param renameReplacement rename replacement\n     * @return this builder\n     ",
      "vertexLabel": "RestoreSnapshotRequestBuilder setRenameReplacement()"
    },
    {
      "vertexName": "Method public void clearIndexShardCache(ShardId shardId, boolean queryCache, boolean fieldDataCache, boolean requestCache, String... fields)  (IndicesService.java)",
      "children": [
        {
          "name": "Method public boolean clearCaches(boolean queryCache, boolean fieldDataCache, String... fields)  (IndexService.java)"
        }
      ],
      "comment": "\n     * Clears the caches for the given shard id if the shard is still allocated on this node\n     ",
      "vertexLabel": "void clearIndexShardCache()"
    },
    {
      "vertexName": "Method public static byte[] shortToBytes(int val)  (Numbers.java)",
      "children": [
        {
          "name": "Method public static byte[] intToBytes(int val)  (Numbers.java)"
        }
      ],
      "comment": "\n     * Converts an int to a byte array.\n     *\n     * @param val The int to convert to a byte array\n     * @return The byte array converted\n     ",
      "vertexLabel": "byte[] shortToBytes()"
    },
    {
      "vertexName": "Method void onAllNodesAcked(@Nullable Exception e)  (AckedClusterStateTaskListener.java)",
      "comment": "\n     * Called once all the nodes have acknowledged the cluster state update request. Must be\n     * very lightweight execution, since it gets executed on the cluster service thread.\n     *\n     * @param e optional error that might have been thrown\n     ",
      "vertexLabel": "void onAllNodesAcked()"
    },
    {
      "vertexName": "Method protected final AnnotatedElementBuilder expose(TypeLiteral<?> type)  (PrivateModule.java)",
      "children": [
        {
          "name": "Method protected final AnnotatedElementBuilder expose(Class<?> type)  (PrivateModule.java)"
        }
      ],
      "comment": "\n     * Makes a binding for {@code type} available to other modules and the injector. Use {@link\n     * AnnotatedElementBuilder#annotatedWith(Class) annotatedWith()} to expose {@code type} with a\n     * binding annotation.\n     ",
      "vertexLabel": "final AnnotatedElementBuilder expose()"
    },
    {
      "vertexName": "Method public Builder put(String key, TimeValue timeValue)  (Settings.java)",
      "children": [
        {
          "name": "Method public Builder put(String key, String value)  (Settings.java)"
        }
      ],
      "comment": "\n         * Sets a time value setting with the provided setting key and value.\n         *\n         * @param key  The setting key\n         * @param timeValue The setting timeValue\n         * @return The builder\n         ",
      "vertexLabel": "Builder put()"
    },
    {
      "vertexName": "Method public Iterator<ObjectObjectCursor<KType, VType>> iterator()  (ImmutableOpenMap.java)",
      "comment": "\n     * Returns a cursor over the entries (key-value pairs) in this map. The iterator is\n     * implemented as a cursor and it returns <b>the same cursor instance</b> on every\n     * call to {@link Iterator#next()}. To read the current key and value use the cursor's\n     * public fields. An example is shown below.\n     * <pre>\n     * for (IntShortCursor c : intShortMap)\n     * {\n     *     System.out.println(&quot;index=&quot; + c.index\n     *       + &quot; key=&quot; + c.key\n     *       + &quot; value=&quot; + c.value);\n     * }\n     * </pre>\n     * <p>\n     * The <code>index</code> field inside the cursor gives the internal index inside\n     * the container's implementation. The interpretation of this index depends on\n     * to the container.\n     ",
      "vertexLabel": "Iterator<ObjectObjectCursor<KType, VType>> iterator()"
    },
    {
      "vertexName": "Method public InnerHitBuilder setStoredFieldNames(List<String> fieldNames)  (InnerHitBuilder.java)",
      "comment": "\n     * Sets the stored fields to load and return.\n     * If none are specified, the source of the document will be returned.\n     ",
      "vertexLabel": "InnerHitBuilder setStoredFieldNames()"
    },
    {
      "vertexName": "Method TimeValue timeout()  (ClusterStateTaskConfig.java)",
      "children": [
        {
          "name": "Method static ClusterStateTaskConfig build(Priority priority)  (ClusterStateTaskConfig.java)"
        }
      ],
      "comment": "\n     * The timeout for this cluster state update task configuration. If\n     * the cluster state update task isn't processed within this\n     * timeout, the associated {@link ClusterStateTaskListener#onFailure(String, Exception)}\n     * is invoked.\n     *\n     * @return the timeout, or null if one is not set\n     ",
      "vertexLabel": "TimeValue timeout()"
    },
    {
      "vertexName": "Method public UnassignedInfo(Reason reason, @Nullable String message, @Nullable Exception failure, int failedAllocations, long unassignedTimeNanos, long unassignedTimeMillis, boolean delayed, AllocationStatus lastAllocationStatus)  (UnassignedInfo.java)",
      "children": [
        {
          "name": "Method public UnassignedInfo(Reason reason, String message)  (UnassignedInfo.java)"
        }
      ],
      "comment": "\n     * @param reason               the cause for making this shard unassigned. See {@link Reason} for more information.\n     * @param message              more information about cause.\n     * @param failure              the shard level failure that caused this shard to be unassigned, if exists.\n     * @param unassignedTimeNanos  the time to use as the base for any delayed re-assignment calculation\n     * @param unassignedTimeMillis the time of unassignment used to display to in our reporting.\n     * @param delayed              if allocation of this shard is delayed due to INDEX_DELAYED_NODE_LEFT_TIMEOUT_SETTING.\n     * @param lastAllocationStatus the result of the last allocation attempt for this shard\n     ",
      "vertexLabel": "UnassignedInfo()"
    },
    {
      "vertexName": "Method public static boolean hasLength(CharSequence str)  (Strings.java)",
      "children": [
        {
          "name": "Method public static boolean isEmpty(CharSequence str)  (Strings.java)"
        }
      ],
      "comment": "\n     * Check that the given CharSequence is neither <code>null</code> nor of length 0.\n     * Note: Will return <code>true</code> for a CharSequence that purely consists of whitespace.\n     * <pre>\n     * StringUtils.hasLength(null) = false\n     * StringUtils.hasLength(\"\") = false\n     * StringUtils.hasLength(\" \") = true\n     * StringUtils.hasLength(\"Hello\") = true\n     * </pre>\n     *\n     * @param str the CharSequence to check (may be <code>null</code>)\n     * @return <code>true</code> if the CharSequence is not null and has length\n     * @see #hasText(String)\n     ",
      "vertexLabel": "boolean hasLength()"
    },
    {
      "vertexName": "Method public abstract boolean isVersionConflictForReads(long currentVersion, long expectedVersion)  (VersionType.java)",
      "comment": "\n     * Checks whether the current version conflicts with the expected version, based on the current version type.\n     *\n     * @param currentVersion  the current version for the document\n     * @param expectedVersion the version specified for the read operation\n     * @return true if versions conflict false o.w.\n     ",
      "vertexLabel": "abstract boolean isVersionConflictForReads()"
    },
    {
      "vertexName": "Method public AckClusterStatePublishResponseHandler(Set<DiscoveryNode> publishingToNodes, Discovery.AckListener ackListener)  (AckClusterStatePublishResponseHandler.java)",
      "children": [
        {
          "name": "Method public BlockingClusterStatePublishResponseHandler(Set<DiscoveryNode> publishingToNodes)  (BlockingClusterStatePublishResponseHandler.java)"
        }
      ],
      "comment": "\n     * Creates a new AckClusterStatePublishResponseHandler\n     * @param publishingToNodes the set of nodes to which the cluster state will be published and should respond\n     * @param ackListener the {@link org.elasticsearch.discovery.Discovery.AckListener} to notify for each response\n     *                    gotten from non master nodes\n     ",
      "vertexLabel": "AckClusterStatePublishResponseHandler()"
    },
    {
      "vertexName": "Method public static Setting<ByteSizeValue> memorySizeSetting(String key, ByteSizeValue defaultValue, Property... properties)  (Setting.java)",
      "children": [
        {
          "name": "Method public static Setting<String> simpleString(String key, String defaultValue, Property... properties)  (Setting.java)"
        }
      ],
      "comment": "\n     * Creates a setting which specifies a memory size. This can either be\n     * specified as an absolute bytes value or as a percentage of the heap\n     * memory.\n     *\n     * @param key the key for the setting\n     * @param defaultValue the default value for this setting\n     * @param properties properties properties for this setting like scope, filtering...\n     * @return the setting object\n     ",
      "vertexLabel": "Setting<ByteSizeValue> memorySizeSetting()"
    },
    {
      "vertexName": "Method void setForcedRefresh(boolean forcedRefresh)  (WriteResponse.java)",
      "children": [
        {
          "name": "Method public boolean forcedRefresh()  (DocWriteResponse.java)"
        }
      ],
      "comment": "\n     * Mark the response as having forced a refresh? Requests that set {@link WriteRequest#setRefreshPolicy(RefreshPolicy)} to\n     * {@link RefreshPolicy#IMMEDIATE} should always mark this as true. Requests that set it to {@link RefreshPolicy#WAIT_UNTIL} will only\n     * set this to true if they run out of refresh listener slots (see {@link IndexSettings#MAX_REFRESH_LISTENERS_PER_SHARD}).\n     ",
      "vertexLabel": "void setForcedRefresh()"
    },
    {
      "vertexName": "Method static Object maybeConvertToString(Object obj)  (AbstractQueryBuilder.java)",
      "children": [
        {
          "name": "Method static Object maybeConvertToBytesRef(Object obj)  (AbstractQueryBuilder.java)"
        }
      ],
      "comment": "\n     * This helper method checks if the object passed in is a {@link BytesRef} or {@link CharBuffer},\n     * if so it converts it to a utf8 string.\n     * @param obj the input object\n     * @return the same input object or a utf8 string if input was of type {@link BytesRef} or {@link CharBuffer}\n     ",
      "vertexLabel": "Object maybeConvertToString()"
    },
    {
      "vertexName": "Field total  (WorkerBulkByScrollTaskState.java)",
      "comment": "\n     * The total number of documents this request will process. 0 means we don't yet know or, possibly, there are actually 0 documents\n     * to process. Its ok that these have the same meaning because any request with 0 actual documents should be quite short lived.\n     ",
      "vertexLabel": "Field total"
    },
    {
      "vertexName": "Method public static boolean isCountDesc(BucketOrder order)  (InternalOrder.java)",
      "children": [
        {
          "name": "Method public static boolean isKeyDesc(BucketOrder order)  (InternalOrder.java)"
        }
      ],
      "comment": "\n     * Determine if the ordering strategy is sorting on bucket count descending.\n     *\n     * @param order bucket ordering strategy to check.\n     * @return {@code true} if the ordering strategy is sorting on bucket count descending, {@code false} otherwise.\n     ",
      "vertexLabel": "boolean isCountDesc()"
    },
    {
      "vertexName": "Method public Aggregator resolveTopmostAggregator(Aggregator root)  (AggregationPath.java)",
      "comment": "\n     * Resolves the topmost aggregator pointed by this path using the given root as a point of reference.\n     *\n     * @param root      The point of reference of this path\n     * @return          The first child aggregator of the root pointed by this path\n     ",
      "vertexLabel": "Aggregator resolveTopmostAggregator()"
    },
    {
      "vertexName": "Method public boolean autoGenerateSynonymsPhraseQuery()  (MultiMatchQueryBuilder.java)",
      "children": [
        {
          "name": "Method public boolean autoGenerateSynonymsPhraseQuery()  (MatchQueryBuilder.java)"
        }
      ],
      "comment": "\n     * Whether phrase queries should be automatically generated for multi terms synonyms.\n     * Defaults to {@code true}.\n     ",
      "vertexLabel": "boolean autoGenerateSynonymsPhraseQuery()"
    },
    {
      "vertexName": "Method public UpdateSettingsClusterStateUpdateRequest setPreserveExisting(boolean preserveExisting)  (UpdateSettingsClusterStateUpdateRequest.java)",
      "comment": "\n     * Iff set to <code>true</code> this settings update will only add settings not already set on an index. Existing settings remain\n     * unchanged.\n     ",
      "vertexLabel": "UpdateSettingsClusterStateUpdateRequest setPreserveExisting()"
    },
    {
      "vertexName": "Method public void setHasPendingAsyncFetch()  (RoutingAllocation.java)",
      "children": [
        {
          "name": "Method public boolean hasPendingAsyncFetch()  (RoutingAllocation.java)"
        }
      ],
      "comment": "\n     * Sets a flag that signals that current allocation run has not processed all of the in-flight or available shard or store fetches.\n     * This state is anti-viral and can be reset in on allocation run.\n     ",
      "vertexLabel": "void setHasPendingAsyncFetch()"
    },
    {
      "vertexName": "Method public HoltWintersModelBuilder beta(double beta)  (HoltWintersModel.java)",
      "children": [
        {
          "name": "Method public HoltLinearModelBuilder beta(double beta)  (HoltLinearModel.java)"
        }
      ],
      "comment": "\n         * Equivalent to <code>alpha</code>, but controls the smoothing of the trend instead of the data\n         *\n         * @param beta a double between 0-1 inclusive, controls trend smoothing\n         *\n         * @return The builder to continue chaining\n         ",
      "vertexLabel": "HoltWintersModelBuilder beta()"
    },
    {
      "vertexName": "Method void nodesInfo(NodesInfoRequest request, ActionListener<NodesInfoResponse> listener)  (ClusterAdminClient.java)",
      "children": [
        {
          "name": "Method ActionFuture<NodesInfoResponse> nodesInfo(NodesInfoRequest request)  (ClusterAdminClient.java)"
        }
      ],
      "comment": "\n     * Nodes info of the cluster.\n     *\n     * @param request  The nodes info request\n     * @param listener A listener to be notified with a result\n     * @see org.elasticsearch.client.Requests#nodesInfoRequest(String...)\n     ",
      "vertexLabel": "void nodesInfo()"
    },
    {
      "vertexName": "Method public static MessageDigest sha1()  (MessageDigests.java)",
      "children": [
        {
          "name": "Method public static MessageDigest md5()  (MessageDigests.java)"
        }
      ],
      "comment": "\n     * Returns a {@link MessageDigest} instance for SHA-1 digests; note\n     * that the instance returned is thread local and must not be\n     * shared amongst threads.\n     *\n     * @return a thread local {@link MessageDigest} instance that\n     * provides SHA-1 message digest functionality.\n     ",
      "vertexLabel": "MessageDigest sha1()"
    },
    {
      "vertexName": "Method public Version getSmallestNonClientNodeVersion()  (DiscoveryNodes.java)",
      "children": [
        {
          "name": "Method public Version getMinNodeVersion()  (DiscoveryNodes.java)"
        }
      ],
      "comment": "\n     * Returns the version of the node with the oldest version in the cluster that is not a client node\n     *\n     * If there are no non-client nodes, Version.CURRENT will be returned.\n     *\n     * @return the oldest version in the cluster\n     ",
      "vertexLabel": "Version getSmallestNonClientNodeVersion()"
    },
    {
      "vertexName": "Method private StoredScriptSource build(boolean ignoreEmpty)  (StoredScriptSource.java)",
      "comment": "\n         * Validates the parameters and creates an {@link StoredScriptSource}.\n         *\n         * @param ignoreEmpty Specify as {@code true} to ignoreEmpty the empty source check.\n         *                    This allow empty templates to be loaded for backwards compatibility.\n         *                    This allow empty templates to be loaded for backwards compatibility.\n         ",
      "vertexLabel": "StoredScriptSource build()"
    },
    {
      "vertexName": "Method public CombineFunction boostMode()  (FunctionScoreQueryBuilder.java)",
      "children": [
        {
          "name": "Method public FunctionScoreQueryBuilder boostMode(CombineFunction combineFunction)  (FunctionScoreQueryBuilder.java)"
        }
      ],
      "comment": "\n     * Returns the boost mode, meaning how the combined result of score functions will influence the final score together with the sub query\n     * score.\n     *\n     * @see CombineFunction\n     ",
      "vertexLabel": "CombineFunction boostMode()"
    },
    {
      "vertexName": "Method public UpdateRequest upsert(XContentType xContentType, Object... source)  (UpdateRequest.java)",
      "children": [
        {
          "name": "Method public UpdateRequest upsert(Object... source)  (UpdateRequest.java)"
        }
      ],
      "comment": "\n     * Sets the doc source of the update request to be used when the document does not exists. The doc\n     * includes field and value pairs.\n     ",
      "vertexLabel": "UpdateRequest upsert()"
    },
    {
      "vertexName": "Method public abstract double execute(ScriptedSimilarity.Query query, ScriptedSimilarity.Field field, ScriptedSimilarity.Term term)  (SimilarityWeightScript.java)",
      "comment": " Compute the weight.\n     * @param query  scoring factors that come from the query\n     * @param field  field-level statistics\n     * @param term   term-level statistics\n     ",
      "vertexLabel": "abstract double execute()"
    },
    {
      "vertexName": "Method List<String> readSysFsCgroupCpuAcctCpuStat(final String controlGroup) throws IOException  (OsProbe.java)",
      "children": [
        {
          "name": "Method String readSysFsCgroupCpuAcctCpuAcctCfsQuota(final String controlGroup) throws IOException  (OsProbe.java)"
        }
      ],
      "comment": "\n     * Returns the lines from {@code cpu.stat} for the control group to which the Elasticsearch process belongs for the {@code cpu}\n     * subsystem. These lines represent the CPU time statistics and have the form\n     * <blockquote><pre>\n     * nr_periods \\d+\n     * nr_throttled \\d+\n     * throttled_time \\d+\n     * </pre></blockquote>\n     * where {@code nr_periods} is the number of period intervals as specified by {@code cpu.cfs_period_us} that have elapsed, {@code\n     * nr_throttled} is the number of times tasks in the given control group have been throttled, and {@code throttled_time} is the total\n     * time in nanoseconds for which tasks in the given control group have been throttled.\n     *\n     * @param controlGroup the control group to which the Elasticsearch process belongs for the {@code cpu} subsystem\n     * @return the lines from {@code cpu.stat}\n     * @throws IOException if an I/O exception occurs reading {@code cpu.stat} for the control group\n     ",
      "vertexLabel": "List<String> readSysFsCgroupCpuAcctCpuStat()"
    },
    {
      "vertexName": "Method native boolean VirtualLock(Pointer address, SizeT size)  (JNAKernel32Library.java)",
      "comment": "\n     * Locks the specified region of the process's virtual address space into physical\n     * memory, ensuring that subsequent access to the region will not incur a page fault.\n     *\n     * https://msdn.microsoft.com/en-us/library/windows/desktop/aa366895%28v=vs.85%29.aspx\n     *\n     * @param address A pointer to the base address of the region of pages to be locked.\n     * @param size The size of the region to be locked, in bytes.\n     * @return true if the function succeeds\n     ",
      "vertexLabel": "native boolean VirtualLock()"
    },
    {
      "vertexName": "Method ActionFuture<TypesExistsResponse> typesExists(TypesExistsRequest request)  (IndicesAdminClient.java)",
      "comment": "\n     * Types exists.\n     *\n     * @deprecated Types are deprecated and are in the process of being removed.\n     * @param request The types exists request\n     * @return The result future\n     ",
      "vertexLabel": "ActionFuture<TypesExistsResponse> typesExists()"
    },
    {
      "vertexName": "Method public EnvironmentAwareCommand(final String description)  (EnvironmentAwareCommand.java)",
      "comment": "\n     * Construct the command with the specified command description. This command will have logging configured without reading Elasticsearch\n     * configuration files.\n     *\n     * @param description the command description\n     ",
      "vertexLabel": "EnvironmentAwareCommand()"
    },
    {
      "vertexName": "Method void execute(Action<Response> action, Request request, ActionListener<Response> listener)  (ElasticsearchClient.java)",
      "comment": "\n     * Executes a generic action, denoted by an {@link Action}.\n     *\n     * @param action           The action type to execute.\n     * @param request          The action request.\n     * @param listener         The listener to receive the response back.\n     * @param <Request>        The request type.\n     * @param <Response>       The response type.\n     ",
      "vertexLabel": "void execute()"
    },
    {
      "vertexName": "Method public SignificanceHeuristic rewrite(InternalAggregation.ReduceContext reduceContext)  (SignificanceHeuristic.java)",
      "children": [
        {
          "name": "Method public SignificanceHeuristic rewrite(SearchContext context)  (SignificanceHeuristic.java)"
        }
      ],
      "comment": "\n     * Provides a hook for subclasses to provide a version of the heuristic\n     * prepared for execution on data on the coordinating node.\n     * @param reduceContext the reduce context on the coordinating node\n     * @return a version of this heuristic suitable for execution\n     ",
      "vertexLabel": "SignificanceHeuristic rewrite()"
    },
    {
      "vertexName": "Method public static PreConfiguredTokenizer singleton(String name, Supplier<Tokenizer> create, @Nullable Supplier<TokenFilterFactory> multiTermComponent)  (PreConfiguredTokenizer.java)",
      "comment": "\n     * Create a pre-configured tokenizer that may not vary at all.\n     * \n     * @param name the name of the tokenizer in the api\n     * @param create builds the tokenizer\n     * @param multiTermComponent null if this tokenizer shouldn't be used for multi-term queries, otherwise a supplier for the\n     *        {@link TokenFilterFactory} that stands in for this tokenizer in multi-term queries.\n     ",
      "vertexLabel": "PreConfiguredTokenizer singleton()"
    },
    {
      "vertexName": "Field ALL_CONTEXTS  (MetaData.java)",
      "comment": "\n     * Indicates that this custom metadata will be returned as part of an API call, stored as a part of\n     * a snapshot global state, and will be persisted between node restarts\n     ",
      "vertexLabel": "Field ALL_CONTEXTS"
    },
    {
      "vertexName": "Method void delete(DeleteRequest request, ActionListener<DeleteResponse> listener)  (Client.java)",
      "children": [
        {
          "name": "Method ActionFuture<DeleteResponse> delete(DeleteRequest request)  (Client.java)"
        },
        {
          "name": "Method void get(GetRequest request, ActionListener<GetResponse> listener)  (Client.java)"
        }
      ],
      "comment": "\n     * Deletes a document from the index based on the index, type and id.\n     *\n     * @param request  The delete request\n     * @param listener A listener to be notified with a result\n     * @see Requests#deleteRequest(String)\n     ",
      "vertexLabel": "void delete()"
    },
    {
      "vertexName": "Method long getRefreshingBytes()  (LiveVersionMap.java)",
      "children": [
        {
          "name": "Method long ramBytesUsedForRefresh()  (LiveVersionMap.java)"
        }
      ],
      "comment": "\n     * Returns how much RAM is current being freed up by refreshing.  This is {@link #ramBytesUsed()}\n     * except does not include tombstones because they don't clear on refresh.\n     ",
      "vertexLabel": "long getRefreshingBytes()"
    },
    {
      "vertexName": "Method public IndicesShardStoreRequestBuilder setIndicesOptions(IndicesOptions indicesOptions)  (IndicesShardStoreRequestBuilder.java)",
      "children": [
        {
          "name": "Method public DeleteIndexRequestBuilder setIndicesOptions(IndicesOptions options)  (DeleteIndexRequestBuilder.java)"
        }
      ],
      "comment": "\n     * Specifies what type of requested indices to ignore and wildcard indices expressions\n     * By default, expands wildcards to both open and closed indices\n     ",
      "vertexLabel": "IndicesShardStoreRequestBuilder setIndicesOptions()"
    },
    {
      "vertexName": "Method public ChecksumBlobStoreFormat(String codec, String blobNameFormat, CheckedFunction<XContentParser, T, IOException> reader, NamedXContentRegistry namedXContentRegistry, boolean compress, XContentType xContentType)  (ChecksumBlobStoreFormat.java)",
      "children": [
        {
          "name": "Method public ChecksumBlobStoreFormat(String codec, String blobNameFormat, CheckedFunction<XContentParser, T, IOException> reader, NamedXContentRegistry namedXContentRegistry, boolean compress)  (ChecksumBlobStoreFormat.java)"
        }
      ],
      "comment": "\n     * @param codec          codec name\n     * @param blobNameFormat format of the blobname in {@link String#format} format\n     * @param reader         prototype object that can deserialize T from XContent\n     * @param compress       true if the content should be compressed\n     * @param xContentType   content type that should be used for write operations\n     ",
      "vertexLabel": "ChecksumBlobStoreFormat()"
    },
    {
      "vertexName": "Method SnapshotContext(Store store, SnapshotId snapshotId, IndexId indexId, IndexShardSnapshotStatus snapshotStatus, long startTime)  (BlobStoreRepository.java)",
      "comment": "\n         * Constructs new context\n         *\n         * @param store          store to be snapshotted\n         * @param snapshotId     snapshot id\n         * @param indexId        the id of the index being snapshotted\n         * @param snapshotStatus snapshot status to report progress\n         ",
      "vertexLabel": "SnapshotContext()"
    },
    {
      "vertexName": "Method public boolean mightMatchNonNestedDocs(Query query, String nestedPath)  (NestedHelper.java)",
      "comment": " Returns true if the given query might match parent documents or documents\n     *  that are nested under a different path. ",
      "vertexLabel": "boolean mightMatchNonNestedDocs()"
    },
    {
      "vertexName": "Method public GeoDistanceSortBuilder(String fieldName, GeoPoint... points)  (GeoDistanceSortBuilder.java)",
      "comment": "\n     * Constructs a new distance based sort on a geo point like field.\n     *\n     * @param fieldName The geo point like field name.\n     * @param points The points to create the range distance facets from.\n     ",
      "vertexLabel": "GeoDistanceSortBuilder()"
    },
    {
      "vertexName": "Method public MetadataSnapshot getMetadata(IndexCommit commit) throws IOException  (Store.java)",
      "children": [
        {
          "name": "Method public Store.MetadataSnapshot snapshotStoreMetadata() throws IOException  (IndexShard.java)"
        }
      ],
      "comment": "\n     * Returns a new MetadataSnapshot for the given commit. If the given commit is <code>null</code>\n     * the latest commit point is used.\n     *\n     * Note that this method requires the caller verify it has the right to access the store and\n     * no concurrent file changes are happening. If in doubt, you probably want to use one of the following:\n     *\n     * {@link #readMetadataSnapshot(Path, ShardId, NodeEnvironment.ShardLocker, Logger)} to read a meta data while locking\n     * {@link IndexShard#snapshotStoreMetadata()} to safely read from an existing shard\n     * {@link IndexShard#acquireLastIndexCommit(boolean)} to get an {@link IndexCommit} which is safe to use but has to be freed\n     * @param commit the index commit to read the snapshot from or <code>null</code> if the latest snapshot should be read from the\n     *               directory\n     * @throws CorruptIndexException      if the lucene index is corrupted. This can be caused by a checksum mismatch or an\n     *                                    unexpected exception when opening the index reading the segments file.\n     * @throws IndexFormatTooOldException if the lucene index is too old to be opened.\n     * @throws IndexFormatTooNewException if the lucene index is too new to be opened.\n     * @throws FileNotFoundException      if one or more files referenced by a commit are not present.\n     * @throws NoSuchFileException        if one or more files referenced by a commit are not present.\n     * @throws IndexNotFoundException     if the commit point can't be found in this store\n     ",
      "vertexLabel": "MetadataSnapshot getMetadata()"
    },
    {
      "vertexName": "Method public IndexShardRoutingTable shardRoutingTable(ShardId shardId)  (RoutingTable.java)",
      "comment": "\n     * All shards for the provided {@link ShardId}\n     * @return All the shard routing entries for the given index and shard id\n     * @throws IndexNotFoundException if provided index does not exist\n     * @throws ShardNotFoundException if provided shard id is unknown\n     ",
      "vertexLabel": "IndexShardRoutingTable shardRoutingTable()"
    },
    {
      "vertexName": "Method public void submitStateUpdateTask(String source, T task, ClusterStateTaskConfig config, ClusterStateTaskExecutor<T> executor, ClusterStateTaskListener listener)  (ClusterService.java)",
      "children": [
        {
          "name": "Method public void submitStateUpdateTasks(final String source, final Map<T, ClusterStateTaskListener> tasks, final ClusterStateTaskConfig config, final ClusterStateTaskExecutor<T> executor)  (ClusterService.java)"
        }
      ],
      "comment": "\n     * Submits a cluster state update task; submitted updates will be\n     * batched across the same instance of executor. The exact batching\n     * semantics depend on the underlying implementation but a rough\n     * guideline is that if the update task is submitted while there\n     * are pending update tasks for the same executor, these update\n     * tasks will all be executed on the executor in a single batch\n     *\n     * @param source   the source of the cluster state update task\n     * @param task     the state needed for the cluster state update task\n     * @param config   the cluster state update task configuration\n     * @param executor the cluster state update task executor; tasks\n     *                 that share the same executor will be executed\n     *                 batches on this executor\n     * @param listener callback after the cluster state update task\n     *                 completes\n     * @param <T>      the type of the cluster state update task state\n     *\n     ",
      "vertexLabel": "void submitStateUpdateTask()"
    },
    {
      "vertexName": "Method public BulkRequest waitForActiveShards(final int waitForActiveShards)  (BulkRequest.java)",
      "children": [
        {
          "name": "Method public CreateIndexRequest waitForActiveShards(final int waitForActiveShards)  (CreateIndexRequest.java)"
        }
      ],
      "comment": "\n     * A shortcut for {@link #waitForActiveShards(ActiveShardCount)} where the numerical\n     * shard count is passed in, instead of having to first call {@link ActiveShardCount#from(int)}\n     * to get the ActiveShardCount.\n     ",
      "vertexLabel": "BulkRequest waitForActiveShards()"
    },
    {
      "vertexName": "Method public Builder rewrite(QueryRewriteContext context) throws IOException  (AggregatorFactories.java)",
      "comment": "\n         * Rewrites the underlying aggregation builders into their primitive\n         * form. If the builder did not change the identity reference must be\n         * returned otherwise the builder will be rewritten infinitely.\n         ",
      "vertexLabel": "Builder rewrite()"
    },
    {
      "vertexName": "Method void addError(String message, Object... arguments)  (TypeEncounter.java)",
      "children": [
        {
          "name": "Method void addError(String message, Object... arguments)  (Binder.java)"
        }
      ],
      "comment": "\n     * Records an error message for type {@code I} which will be presented to the user at a later\n     * time. Unlike throwing an exception, this enable us to continue configuring the Injector and\n     * discover more errors. Uses {@link String#format(String, Object[])} to insert the arguments\n     * into the message.\n     ",
      "vertexLabel": "void addError()"
    },
    {
      "vertexName": "Method void onSuccess(String source)  (ClusterApplier.java)",
      "comment": "\n         * Called on successful cluster state application\n         * @param source information where the cluster state came from\n         ",
      "vertexLabel": "void onSuccess()"
    },
    {
      "vertexName": "Method ActionFuture<NodesUsageResponse> nodesUsage(NodesUsageRequest request)  (ClusterAdminClient.java)",
      "children": [
        {
          "name": "Method void nodesUsage(NodesUsageRequest request, ActionListener<NodesUsageResponse> listener)  (ClusterAdminClient.java)"
        },
        {
          "name": "Method ActionFuture<NodesHotThreadsResponse> nodesHotThreads(NodesHotThreadsRequest request)  (ClusterAdminClient.java)"
        }
      ],
      "comment": "\n     * Returns top N hot-threads samples per node. The hot-threads are only\n     * sampled for the node ids specified in the request. Nodes usage of the\n     * cluster.\n     *\n     * @param request\n     *            The nodes usage request\n     * @return The result future\n     * @see org.elasticsearch.client.Requests#nodesUsageRequest(String...)\n     ",
      "vertexLabel": "ActionFuture<NodesUsageResponse> nodesUsage()"
    },
    {
      "vertexName": "Method private static void addSocketPermissionForTransport(final Permissions policy, final Settings settings)  (Security.java)",
      "children": [
        {
          "name": "Method private static void addSocketPermissionForHttp(final Permissions policy, final Settings settings)  (Security.java)"
        }
      ],
      "comment": "\n     * Add dynamic {@link SocketPermission} based on transport settings.\n     *\n     * @param policy          the {@link Permissions} instance to apply the dynamic {@link SocketPermission}s to\n     * @param settings        the {@link Settings} instance to read the transport settings from\n     ",
      "vertexLabel": "void addSocketPermissionForTransport()"
    },
    {
      "vertexName": "Method public CreateSnapshotRequest settings(String source, XContentType xContentType)  (CreateSnapshotRequest.java)",
      "children": [
        {
          "name": "Method public RestoreSnapshotRequest settings(String source, XContentType xContentType)  (RestoreSnapshotRequest.java)"
        }
      ],
      "comment": "\n     * Sets repository-specific snapshot settings in JSON or YAML format\n     * <p>\n     * See repository documentation for more information.\n     *\n     * @param source repository-specific snapshot settings\n     * @param xContentType the content type of the source\n     * @return this request\n     ",
      "vertexLabel": "CreateSnapshotRequest settings()"
    },
    {
      "vertexName": "Method public static SearchType fromString(String searchType)  (SearchType.java)",
      "comment": "\n     * The a string representation search type to execute, defaults to {@link SearchType#DEFAULT}. Can be\n     * one of \"dfs_query_then_fetch\"/\"dfsQueryThenFetch\", \"dfs_query_and_fetch\"/\"dfsQueryAndFetch\",\n     * \"query_then_fetch\"/\"queryThenFetch\" and \"query_and_fetch\"/\"queryAndFetch\".\n     ",
      "vertexLabel": "SearchType fromString()"
    },
    {
      "vertexName": "Method public static String collectionToDelimitedString(Iterable<?> coll, String delim, String prefix, String suffix)  (Strings.java)",
      "children": [
        {
          "name": "Method public static String collectionToDelimitedString(Iterable<?> coll, String delim)  (Strings.java)"
        }
      ],
      "comment": "\n     * Convenience method to return a Collection as a delimited (e.g. CSV)\n     * String. E.g. useful for <code>toString()</code> implementations.\n     *\n     * @param coll   the Collection to display\n     * @param delim  the delimiter to use (probably a \",\")\n     * @param prefix the String to start each element with\n     * @param suffix the String to end each element with\n     * @return the delimited String\n     ",
      "vertexLabel": "String collectionToDelimitedString()"
    },
    {
      "vertexName": "Method public void registerRequestHandler(String action, String executor, boolean forceExecution, boolean canTripCircuitBreaker, Writeable.Reader<Request> requestReader, TransportRequestHandler<Request> handler)  (TransportService.java)",
      "children": [
        {
          "name": "Method public void registerRequestHandler(String action, Supplier<Request> request, String executor, boolean forceExecution, boolean canTripCircuitBreaker, TransportRequestHandler<Request> handler)  (TransportService.java)"
        }
      ],
      "comment": "\n     * Registers a new request handler\n     *\n     * @param action                The action the request handler is associated with\n     * @param requestReader               The request class that will be used to construct new instances for streaming\n     * @param executor              The executor the request handling will be executed on\n     * @param forceExecution        Force execution on the executor queue and never reject it\n     * @param canTripCircuitBreaker Check the request size and raise an exception in case the limit is breached.\n     * @param handler               The handler itself that implements the request handling\n     ",
      "vertexLabel": "void registerRequestHandler()"
    },
    {
      "vertexName": "Method public static AllocationId cancelRelocation(AllocationId allocationId)  (AllocationId.java)",
      "comment": "\n     * Creates a new allocation id representing a cancelled relocation.\n     * <p>\n     * Note that this is expected to be called on the allocation id\n     * of the *source* shard\n     ",
      "vertexLabel": "AllocationId cancelRelocation()"
    },
    {
      "vertexName": "Class AbstractSortingNumericDocValues  (AbstractSortingNumericDocValues.java)",
      "children": [
        {
          "name": "Class AbstractBinaryDocValues  (AbstractBinaryDocValues.java)"
        }
      ],
      "comment": "\n * Base implementation that throws an {@link IOException} for the\n * {@link DocIdSetIterator} APIs. This impl is safe to use for sorting and\n * aggregations, which only use {@link #advanceExact(int)} and\n * {@link #docValueCount()} and {@link #nextValue()}.\n ",
      "vertexLabel": "Class AbstractSortingNumericDocValues"
    },
    {
      "vertexName": "Method public UnaryOperator<IndexMetaData> getIndexMetaDataUpgrader()  (Plugin.java)",
      "comment": "\n     * Provides a function to modify index meta data when an index is introduced into the cluster state for the first time.\n     * <p>\n     * Plugins should return the input index metadata via {@link UnaryOperator#identity()} if no upgrade is required.\n     * <p>\n     * The order of the index upgrader calls for the same index is undefined and can change between runs so, it is expected that\n     * plugins will modify only indices owned by them to avoid conflicts.\n     * <p>\n     * @return Never {@code null}. The same or upgraded {@code IndexMetaData}.\n     * @throws IllegalStateException if the node should not start because the index is unsupported\n     ",
      "vertexLabel": "UnaryOperator<IndexMetaData> getIndexMetaDataUpgrader()"
    },
    {
      "vertexName": "Method public static SyncedFlushRequest syncedFlushRequest(String... indices)  (Requests.java)",
      "comment": "\n     * Creates a synced flush indices request.\n     *\n     * @param indices The indices to sync flush. Use {@code null} or {@code _all} to execute against all indices\n     * @return The synced flush request\n     * @see org.elasticsearch.client.IndicesAdminClient#syncedFlush(SyncedFlushRequest)\n     ",
      "vertexLabel": "SyncedFlushRequest syncedFlushRequest()"
    },
    {
      "vertexName": "Method public ExplainRequestBuilder setFetchSource(@Nullable String include, @Nullable String exclude)  (ExplainRequestBuilder.java)",
      "comment": "\n     * Indicate that _source should be returned, with an \"include\" and/or \"exclude\" set which can include simple wildcard\n     * elements.\n     *\n     * @param include An optional include (optionally wildcarded) pattern to filter the returned _source\n     * @param exclude An optional exclude (optionally wildcarded) pattern to filter the returned _source\n     ",
      "vertexLabel": "ExplainRequestBuilder setFetchSource()"
    },
    {
      "vertexName": "Method void postDelete(ShardId shardId, Engine.Delete delete, Exception ex)  (IndexingOperationListener.java)",
      "children": [
        {
          "name": "Method void postIndex(ShardId shardId, Engine.Index index, Exception ex)  (IndexingOperationListener.java)"
        }
      ],
      "comment": "\n     * Called after the delete operation occurred with engine level exception.\n     * See {@link #postDelete(ShardId, Engine.Delete, Engine.DeleteResult)} for document\n     * related failures\n     ",
      "vertexLabel": "void postDelete()"
    },
    {
      "vertexName": "Method void remove(K key, V value, Consumer<CompletableFuture<Entry<K, V>>> onRemoval)  (Cache.java)",
      "children": [
        {
          "name": "Method void remove(K key, Consumer<CompletableFuture<Entry<K, V>>> onRemoval)  (Cache.java)"
        }
      ],
      "comment": "\n         * remove an entry from the segment iff the future is done and the value is equal to the\n         * expected value\n         *\n         * @param key the key of the entry to remove from the cache\n         * @param value the value expected to be associated with the key\n         * @param onRemoval a callback for the removed entry\n         ",
      "vertexLabel": "void remove()"
    },
    {
      "vertexName": "Method public T getFieldValue(String path, Class<T> clazz, boolean ignoreMissing)  (IngestDocument.java)",
      "children": [
        {
          "name": "Method public T getFieldValue(String path, Class<T> clazz)  (IngestDocument.java)"
        }
      ],
      "comment": "\n     * Returns the value contained in the document for the provided path\n     *\n     * @param path The path within the document in dot-notation\n     * @param clazz The expected class of the field value\n     * @param ignoreMissing The flag to determine whether to throw an exception when `path` is not found in the document.\n     * @return the value for the provided path if existing, null otherwise.\n     * @throws IllegalArgumentException only if ignoreMissing is false and the path is null, empty, invalid, if the field doesn't exist\n     * or if the field that is found at the provided path is not of the expected type.\n     ",
      "vertexLabel": "T getFieldValue()"
    },
    {
      "vertexName": "Method public abstract Closeable acquireRetentionLockForPeerRecovery()  (Engine.java)",
      "comment": "\n     * Acquires a lock on the translog files and Lucene soft-deleted documents to prevent them from being trimmed\n     ",
      "vertexLabel": "abstract Closeable acquireRetentionLockForPeerRecovery()"
    },
    {
      "vertexName": "Method private CompletionSuggestionBuilder(String fieldname, CompletionSuggestionBuilder in)  (CompletionSuggestionBuilder.java)",
      "comment": "\n     * internal copy constructor that copies over all class fields except for the field which is\n     * set to the one provided in the first argument\n     ",
      "vertexLabel": "CompletionSuggestionBuilder()"
    },
    {
      "vertexName": "Method public ImmutableOpenMap<String, Settings> getIndexToDefaultSettings()  (GetSettingsResponse.java)",
      "children": [
        {
          "name": "Method public ImmutableOpenMap<String, Settings> defaultSettings()  (GetIndexResponse.java)"
        }
      ],
      "comment": "\n     * If the originating {@link GetSettingsRequest} object was configured to include\n     * defaults, this will contain a mapping of index name to {@link Settings} objects.\n     * The returned {@link Settings} objects will contain only those settings taking\n     * effect as defaults.  Any settings explicitly set on the index will be available\n     * via {@link #getIndexToSettings()}.\n     * See also {@link GetSettingsRequest#includeDefaults(boolean)}\n     ",
      "vertexLabel": "ImmutableOpenMap<String, Settings> getIndexToDefaultSettings()"
    },
    {
      "vertexName": "Method public Path getRootDataPath()  (ShardPath.java)",
      "comment": "\n     * Returns the data-path root for this shard. The root is a parent of {@link #getDataPath()} without the index name\n     * and the shard ID.\n     ",
      "vertexLabel": "Path getRootDataPath()"
    },
    {
      "vertexName": "Method public SearchShardIterator(String clusterAlias, ShardId shardId, List<ShardRouting> shards, OriginalIndices originalIndices)  (SearchShardIterator.java)",
      "comment": "\n     * Creates a {@link PlainShardIterator} instance that iterates over a subset of the given shards\n     * this the a given <code>shardId</code>.\n     *\n     * @param shardId shard id of the group\n     * @param shards  shards to iterate\n     ",
      "vertexLabel": "SearchShardIterator()"
    },
    {
      "vertexName": "EnumConstant PHRASE  (MultiMatchQueryBuilder.java)",
      "comment": "\n         * Uses the best matching phrase field as main score and uses\n         * a tie-breaker to adjust the score based on remaining field matches\n         ",
      "vertexLabel": "EnumConstant PHRASE"
    },
    {
      "vertexName": "Method public static SortedBinaryDocValues toString(final SortedSetDocValues values)  (FieldData.java)",
      "comment": "\n     * Return a {@link String} representation of the provided values. That is\n     * typically used for scripts or for the `map` execution mode of terms aggs.\n     * NOTE: this is slow!\n     ",
      "vertexLabel": "SortedBinaryDocValues toString()"
    },
    {
      "vertexName": "Method public ShardIterator activeInitializingShardsRandomIt()  (IndexShardRoutingTable.java)",
      "comment": "\n     * Returns an iterator over active and initializing shards. Making sure though that\n     * its random within the active shards, and initializing shards are the last to iterate through.\n     ",
      "vertexLabel": "ShardIterator activeInitializingShardsRandomIt()"
    },
    {
      "vertexName": "Method public TermSuggestionBuilder maxTermFreq(float maxTermFreq)  (TermSuggestionBuilder.java)",
      "children": [
        {
          "name": "Method public DirectCandidateGeneratorBuilder maxTermFreq(float maxTermFreq)  (DirectCandidateGeneratorBuilder.java)"
        }
      ],
      "comment": "\n     * Sets a maximum threshold in number of documents a suggest text token can\n     * exist in order to be corrected. Can be a relative percentage number (e.g\n     * 0.4) or an absolute number to represent document frequencies. If an value\n     * higher than 1 is specified then fractional can not be specified. Defaults\n     * to {@code 0.01}.\n     * <p>\n     * This can be used to exclude high frequency terms from being suggested.\n     * High frequency terms are usually spelled correctly on top of this this\n     * also improves the suggest performance.\n     ",
      "vertexLabel": "TermSuggestionBuilder maxTermFreq()"
    },
    {
      "vertexName": "Method ActionFuture<UpgradeResponse> upgrade(UpgradeRequest request)  (IndicesAdminClient.java)",
      "comment": "\n     * Explicitly upgrade one or more indices\n     *\n     * @param request The upgrade request\n     * @return A result future\n     * @see org.elasticsearch.client.Requests#upgradeRequest(String...)\n     ",
      "vertexLabel": "ActionFuture<UpgradeResponse> upgrade()"
    },
    {
      "vertexName": "Method public static String randomBase64UUID()  (UUIDs.java)",
      "children": [
        {
          "name": "Method public static String randomBase64UUID(Random random)  (UUIDs.java)"
        }
      ],
      "comment": " Returns a Base64 encoded version of a Version 4.0 compatible UUID as defined here: http://www.ietf.org/rfc/rfc4122.txt, using a\n     *  private {@code SecureRandom} instance ",
      "vertexLabel": "String randomBase64UUID()"
    },
    {
      "vertexName": "EnumConstant STORED  (ScriptType.java)",
      "children": [
        {
          "name": "EnumConstant INLINE  (ScriptType.java)"
        }
      ],
      "comment": "\n     * STORED scripts are saved as part of the {@link org.elasticsearch.cluster.ClusterState}\n     * based on user requests.  They will be cached when they are first used in a query.\n     * They are turned off by default because most languages are insecure\n     * (Groovy and others), but can be overridden by the specific {@link ScriptEngine}\n     * if the language is naturally secure (Painless, Mustache, and Expressions).\n     ",
      "vertexLabel": "EnumConstant STORED"
    },
    {
      "vertexName": "Method public ChildMemoryCircuitBreaker(BreakerSettings settings, ChildMemoryCircuitBreaker oldBreaker, Logger logger, HierarchyCircuitBreakerService parent, String name)  (ChildMemoryCircuitBreaker.java)",
      "children": [
        {
          "name": "Method public ChildMemoryCircuitBreaker(BreakerSettings settings, Logger logger, HierarchyCircuitBreakerService parent, String name)  (ChildMemoryCircuitBreaker.java)"
        }
      ],
      "comment": "\n     * Create a circuit breaker that will break if the number of estimated\n     * bytes grows above the limit. All estimations will be multiplied by\n     * the given overheadConstant. Uses the given oldBreaker to initialize\n     * the starting offset.\n     * @param settings settings to configure this breaker\n     * @param parent parent circuit breaker service to delegate tripped breakers to\n     * @param name the name of the breaker\n     * @param oldBreaker the previous circuit breaker to inherit the used value from (starting offset)\n     ",
      "vertexLabel": "ChildMemoryCircuitBreaker()"
    },
    {
      "vertexName": "Method public RequestBuilder setWaitForActiveShards(ActiveShardCount waitForActiveShards)  (ReplicationRequestBuilder.java)",
      "children": [
        {
          "name": "Method public UpdateRequest waitForActiveShards(ActiveShardCount waitForActiveShards)  (UpdateRequest.java)"
        }
      ],
      "comment": "\n     * Sets the number of shard copies that must be active before proceeding with the write.\n     * See {@link ReplicationRequest#waitForActiveShards(ActiveShardCount)} for details.\n     ",
      "vertexLabel": "RequestBuilder setWaitForActiveShards()"
    },
    {
      "vertexName": "Method public void writeVLong(long i) throws IOException  (StreamOutput.java)",
      "children": [
        {
          "name": "Method public void writeVInt(int i) throws IOException  (StreamOutput.java)"
        }
      ],
      "comment": "\n     * Writes a non-negative long in a variable-length format. Writes between one and ten bytes. Smaller values take fewer bytes. Negative\n     * numbers use ten bytes and trip assertions (if running in tests) so prefer {@link #writeLong(long)} or {@link #writeZLong(long)} for\n     * negative numbers.\n     ",
      "vertexLabel": "void writeVLong()"
    },
    {
      "vertexName": "Field NOOP_FIELD_FILTER  (MapperPlugin.java)",
      "comment": "\n     * The default field filter applied, which doesn't filter anything. That means that by default get mappings, get index\n     * get field mappings and field capabilities API will return every field that's present in the mappings.\n     ",
      "vertexLabel": "Field NOOP_FIELD_FILTER"
    },
    {
      "vertexName": "Method public Builder setBulkSize(ByteSizeValue bulkSize)  (BulkProcessor.java)",
      "comment": "\n         * Sets when to flush a new bulk request based on the size of actions currently added. Defaults to\n         * {@code 5mb}. Can be set to {@code -1} to disable it.\n         ",
      "vertexLabel": "Builder setBulkSize()"
    },
    {
      "vertexName": "Method public MovAvgModel model()  (MovAvgPipelineAggregationBuilder.java)",
      "comment": "\n     * Gets a MovAvgModel for the Moving Average. The model is used to\n     * define what type of moving average you want to use on the series\n     ",
      "vertexLabel": "MovAvgModel model()"
    },
    {
      "vertexName": "Method public boolean addOrNotify(Translog.Location location, Consumer<Boolean> listener)  (RefreshListeners.java)",
      "children": [
        {
          "name": "Method public void addRefreshListener(Translog.Location location, Consumer<Boolean> listener)  (IndexShard.java)"
        }
      ],
      "comment": "\n     * Add a listener for refreshes, calling it immediately if the location is already visible. If this runs out of listener slots then it\n     * forces a refresh and calls the listener immediately as well.\n     *\n     * @param location the location to listen for\n     * @param listener for the refresh. Called with true if registering the listener ran it out of slots and forced a refresh. Called with\n     *        false otherwise.\n     * @return did we call the listener (true) or register the listener to call later (false)?\n     ",
      "vertexLabel": "boolean addOrNotify()"
    },
    {
      "vertexName": "Method public static byte toByteExact(Number n)  (Numbers.java)",
      "children": [
        {
          "name": "Method public static int toIntExact(Number n)  (Numbers.java)"
        }
      ],
      "comment": " Return the byte that {@code n} stores, or throws an exception if the\n     *  stored value cannot be converted to a byte that stores the exact same\n     *  value. ",
      "vertexLabel": "byte toByteExact()"
    },
    {
      "vertexName": "Method static void validateShardLimit(ClusterState currentState, Index[] indices, DeprecationLogger deprecationLogger)  (MetaDataIndexStateService.java)",
      "children": [
        {
          "name": "Method static Optional<String> checkShardLimit(Settings settings, ClusterState clusterState, DeprecationLogger deprecationLogger)  (MetaDataCreateIndexService.java)"
        }
      ],
      "comment": "\n     * Validates whether a list of indices can be opened without going over the cluster shard limit.  Only counts indices which are\n     * currently closed and will be opened, ignores indices which are already open.\n     *\n     * @param currentState The current cluster state.\n     * @param indices The indices which are to be opened.\n     * @param deprecationLogger The logger to use to emit a deprecation warning, if appropriate.\n     * @throws ValidationException If this operation would take the cluster over the limit and enforcement is enabled.\n     ",
      "vertexLabel": "void validateShardLimit()"
    },
    {
      "vertexName": "Method public DateRangeAggregationBuilder addUnboundedTo(String key, DateTime to)  (DateRangeAggregationBuilder.java)",
      "children": [
        {
          "name": "Method public DateRangeAggregationBuilder addUnboundedTo(String key, String to)  (DateRangeAggregationBuilder.java)"
        }
      ],
      "comment": "\n     * Add a new range with no lower bound.\n     *\n     * @param key\n     *            the key to use for this range in the response\n     * @param to\n     *            the upper bound on the dates, exclusive\n     ",
      "vertexLabel": "DateRangeAggregationBuilder addUnboundedTo()"
    },
    {
      "vertexName": "Method public ForceMergeRequestBuilder setMaxNumSegments(int maxNumSegments)  (ForceMergeRequestBuilder.java)",
      "children": [
        {
          "name": "Method public int maxNumSegments()  (ForceMergeRequest.java)"
        }
      ],
      "comment": "\n     * Will force merge the index down to &lt;= maxNumSegments. By default, will\n     * cause the merge process to merge down to half the configured number of\n     * segments.\n     ",
      "vertexLabel": "ForceMergeRequestBuilder setMaxNumSegments()"
    },
    {
      "vertexName": "Method private Path resolveIndexCustomLocation(IndexSettings indexSettings)  (NodeEnvironment.java)",
      "children": [
        {
          "name": "Method public static Path resolveBaseCustomLocation(IndexSettings indexSettings, Path sharedDataPath, int nodeLockId)  (NodeEnvironment.java)"
        }
      ],
      "comment": "\n     * Resolve the custom path for a index's shard.\n     * Uses the {@code IndexMetaData.SETTING_DATA_PATH} setting to determine\n     * the root path for the index.\n     *\n     * @param indexSettings settings for the index\n     ",
      "vertexLabel": "Path resolveIndexCustomLocation()"
    },
    {
      "vertexName": "Method void exists(IndicesExistsRequest request, ActionListener<IndicesExistsResponse> listener)  (IndicesAdminClient.java)",
      "comment": "\n     * The status of one or more indices.\n     *\n     * @param request  The indices status request\n     * @param listener A listener to be notified with a result\n     * @see Requests#indicesExistsRequest(String...)\n     ",
      "vertexLabel": "void exists()"
    },
    {
      "vertexName": "Method public PutMappingRequestBuilder setIndicesOptions(IndicesOptions options)  (PutMappingRequestBuilder.java)",
      "children": [
        {
          "name": "Method public DeleteIndexRequestBuilder setIndicesOptions(IndicesOptions options)  (DeleteIndexRequestBuilder.java)"
        }
      ],
      "comment": "\n     * Specifies what type of requested indices to ignore and wildcard indices expressions.\n     * <p>\n     * For example indices that don't exist.\n     ",
      "vertexLabel": "PutMappingRequestBuilder setIndicesOptions()"
    },
    {
      "vertexName": "Method boolean recoverFromRepository(final IndexShard indexShard, Repository repository)  (StoreRecovery.java)",
      "comment": "\n     * Recovers an index from a given {@link Repository}. This method restores a\n     * previously created index snapshot into an existing initializing shard.\n     * @param indexShard the index shard instance to recovery the snapshot from\n     * @param repository the repository holding the physical files the shard should be recovered from\n     * @return <code>true</code> if the shard has been recovered successfully, <code>false</code> if the recovery\n     * has been ignored due to a concurrent modification of if the clusters state has changed due to async updates.\n     ",
      "vertexLabel": "boolean recoverFromRepository()"
    },
    {
      "vertexName": "Method public static double quadTreeCellSize(int level)  (GeoUtils.java)",
      "children": [
        {
          "name": "Method public static double geoHashCellSize(int level)  (GeoUtils.java)"
        }
      ],
      "comment": "\n     * Calculate the size (in meters) of quadtree cells at a specific level\n     * @param level quadtree level must be greater or equal to zero\n     * @return the size of cells at level in meters\n     ",
      "vertexLabel": "double quadTreeCellSize()"
    },
    {
      "vertexName": "Method native boolean SetConsoleCtrlHandler(StdCallLibrary.StdCallCallback handler, boolean add)  (JNAKernel32Library.java)",
      "children": [
        {
          "name": "Method boolean addConsoleCtrlHandler(ConsoleCtrlHandler handler)  (JNAKernel32Library.java)"
        }
      ],
      "comment": "\n     * Native call to the Kernel32 API to set a new Console Ctrl Handler.\n     *\n     * @return true if the handler is correctly set\n     * @throws java.lang.UnsatisfiedLinkError if the Kernel32 library is not loaded or if the native function is not found\n     * @throws java.lang.NoClassDefFoundError if the library for native calls is missing\n     ",
      "vertexLabel": "native boolean SetConsoleCtrlHandler()"
    },
    {
      "vertexName": "Method public AnalyzeRequestBuilder setTokenizer(String tokenizer)  (AnalyzeRequestBuilder.java)",
      "comment": "\n     * Instead of setting the analyzer, sets the tokenizer as name that will be used as part of a custom\n     * analyzer.\n     ",
      "vertexLabel": "AnalyzeRequestBuilder setTokenizer()"
    },
    {
      "vertexName": "Class BigDoubleArray  (BigDoubleArray.java)",
      "children": [
        {
          "name": "Class BigByteArray  (BigByteArray.java)"
        }
      ],
      "comment": "\n * Double array abstraction able to support more than 2B values. This implementation slices data into fixed-sized blocks of\n * configurable length.\n ",
      "vertexLabel": "Class BigDoubleArray"
    },
    {
      "vertexName": "Method public ByteArray grow(ByteArray array, long minSize)  (BigArrays.java)",
      "comment": " Grow an array to a size that is larger than <code>minSize</code>,\n     * preserving content, and potentially reusing part of the provided array. ",
      "vertexLabel": "ByteArray grow()"
    },
    {
      "vertexName": "Method public SearchRequestBuilder setMaxConcurrentShardRequests(int maxConcurrentShardRequests)  (SearchRequestBuilder.java)",
      "children": [
        {
          "name": "Method public void setMaxConcurrentShardRequests(int maxConcurrentShardRequests)  (SearchRequest.java)"
        }
      ],
      "comment": "\n     * Sets the number of shard requests that should be executed concurrently on a single node. This value should be used as a\n     * protection mechanism to reduce the number of shard requests fired per high level search request. Searches that hit the entire\n     * cluster can be throttled with this number to reduce the cluster load. The default is {@code 5}.\n     ",
      "vertexLabel": "SearchRequestBuilder setMaxConcurrentShardRequests()"
    },
    {
      "vertexName": "Method public boolean activeOnly()  (RecoveryRequest.java)",
      "children": [
        {
          "name": "Method public boolean detailed()  (RecoveryRequest.java)"
        }
      ],
      "comment": "\n     * True if activeOnly flag is set, false otherwise. This value is false by default.\n     *\n     * @return  True if activeOnly flag is set, false otherwise\n     ",
      "vertexLabel": "boolean activeOnly()"
    },
    {
      "vertexName": "Method public SearchRequestBuilder setBatchedReduceSize(int batchedReduceSize)  (SearchRequestBuilder.java)",
      "children": [
        {
          "name": "Method public void setBatchedReduceSize(int batchedReduceSize)  (SearchRequest.java)"
        }
      ],
      "comment": "\n     * Sets the number of shard results that should be reduced at once on the coordinating node. This value should be used as a protection\n     * mechanism to reduce the memory overhead per search request if the potential number of shards in the request can be large.\n     ",
      "vertexLabel": "SearchRequestBuilder setBatchedReduceSize()"
    },
    {
      "vertexName": "Method public String[] types()  (CommonStatsFlags.java)",
      "children": [
        {
          "name": "Method public CommonStatsFlags types(String... types)  (CommonStatsFlags.java)"
        }
      ],
      "comment": "\n     * Document types to return stats for. Mainly affects {@link Flag#Indexing} when\n     * enabled, returning specific indexing stats for those types.\n     ",
      "vertexLabel": "String[] types()"
    },
    {
      "vertexName": "Method ActionFuture<ClusterStatsResponse> clusterStats(ClusterStatsRequest request)  (ClusterAdminClient.java)",
      "comment": "\n     * Cluster wide aggregated stats.\n     *\n     * @param request The cluster stats request\n     * @return The result future\n     * @see org.elasticsearch.client.Requests#clusterStatsRequest\n     ",
      "vertexLabel": "ActionFuture<ClusterStatsResponse> clusterStats()"
    },
    {
      "vertexName": "Method protected int parseIntegerParam(@Nullable Map<String, Object> settings, String name, int defaultValue) throws ParseException  (MovAvgModel.java)",
      "children": [
        {
          "name": "Method protected boolean parseBoolParam(@Nullable Map<String, Object> settings, String name, boolean defaultValue) throws ParseException  (MovAvgModel.java)"
        }
      ],
      "comment": "\n         * Extracts an integer from the settings map, otherwise throws an exception\n         *\n         * @param settings      Map of settings provided to this model\n         * @param name          Name of parameter we are attempting to extract\n         * @param defaultValue  Default value to be used if value does not exist in map\n         * @return Integer value extracted from settings map\n         ",
      "vertexLabel": "int parseIntegerParam()"
    },
    {
      "vertexName": "Method public long minDocCount()  (DateHistogramAggregationBuilder.java)",
      "comment": " Return the minimum count of documents that buckets need to have in order\n     *  to be included in the response. ",
      "vertexLabel": "long minDocCount()"
    },
    {
      "vertexName": "Method public ShardLock shardLock(ShardId id) throws ShardLockObtainFailedException  (NodeEnvironment.java)",
      "children": [
        {
          "name": "Method public ShardLock shardLock(final ShardId shardId, long lockTimeoutMS) throws ShardLockObtainFailedException  (NodeEnvironment.java)"
        }
      ],
      "comment": "\n     * Tries to lock the given shards ID. A shard lock is required to perform any kind of\n     * write operation on a shards data directory like deleting files, creating a new index writer\n     * or recover from a different shard instance into it. If the shard lock can not be acquired\n     * a {@link ShardLockObtainFailedException} is thrown.\n     *\n     * Note: this method will return immediately if the lock can't be acquired.\n     *\n     * @param id the shard ID to lock\n     * @return the shard lock. Call {@link ShardLock#close()} to release the lock\n     ",
      "vertexLabel": "ShardLock shardLock()"
    },
    {
      "vertexName": "Method public ClusterStatsRequest(String... nodesIds)  (ClusterStatsRequest.java)",
      "children": [
        {
          "name": "Method public NodesStatsRequest(String... nodesIds)  (NodesStatsRequest.java)"
        }
      ],
      "comment": "\n     * Get stats from nodes based on the nodes ids specified. If none are passed, stats\n     * based on all nodes will be returned.\n     ",
      "vertexLabel": "ClusterStatsRequest()"
    },
    {
      "vertexName": "Method public static AffixSetting<T> affixKeySetting(String prefix, String suffix, Function<String, Setting<T>> delegateFactory, AffixSetting... dependencies)  (Setting.java)",
      "children": [
        {
          "name": "Method public static AffixSetting<T> prefixKeySetting(String prefix, Function<String, Setting<T>> delegateFactory)  (Setting.java)"
        }
      ],
      "comment": "\n     * This setting type allows to validate settings that have the same type and a common prefix and suffix. For instance\n     * storage.${backend}.enable=[true|false] can easily be added with this setting. Yet, affix key settings don't support updaters\n     * out of the box unless {@link #getConcreteSetting(String)} is used to pull the updater.\n     ",
      "vertexLabel": "AffixSetting<T> affixKeySetting()"
    },
    {
      "vertexName": "Method public static double quadTreeCellWidth(int level)  (GeoUtils.java)",
      "children": [
        {
          "name": "Method public static double geoHashCellWidth(int level)  (GeoUtils.java)"
        },
        {
          "name": "Method public static double quadTreeCellSize(int level)  (GeoUtils.java)"
        }
      ],
      "comment": "\n     * Calculate the width (in meters) of quadtree cells at a specific level\n     * @param level quadtree level must be greater or equal to zero\n     * @return the width of cells at level in meters\n     ",
      "vertexLabel": "double quadTreeCellWidth()"
    },
    {
      "vertexName": "Method R setRefreshPolicy(String refreshPolicy)  (WriteRequest.java)",
      "comment": "\n     * Parse the refresh policy from a string, only modifying it if the string is non null. Convenient to use with request parsing.\n     ",
      "vertexLabel": "R setRefreshPolicy()"
    },
    {
      "vertexName": "Class DefaultElementVisitor  (DefaultElementVisitor.java)",
      "children": [
        {
          "name": "Class DefaultBindingScopingVisitor  (DefaultBindingScopingVisitor.java)"
        }
      ],
      "comment": "\n * No-op visitor for subclassing. All interface methods simply delegate to\n * {@link #visitOther(Element)}, returning its result.\n *\n * @param <V> any type to be returned by the visit method. Use {@link Void} with\n *            {@code return null} if no return type is needed.\n * @author sberlin@gmail.com (Sam Berlin)\n * @since 2.0\n ",
      "vertexLabel": "Class DefaultElementVisitor"
    },
    {
      "vertexName": "Method public GeoShapeQueryBuilder(String fieldName, String indexedShapeId, String indexedShapeType)  (GeoShapeQueryBuilder.java)",
      "children": [
        {
          "name": "Method public GeoShapeQueryBuilder(String fieldName, ShapeBuilder shape)  (GeoShapeQueryBuilder.java)"
        }
      ],
      "comment": "\n     * Creates a new GeoShapeQueryBuilder whose Query will be against the given\n     * field name and will use the Shape found with the given ID in the given\n     * type\n     *\n     * @param fieldName\n     *            Name of the field that will be filtered\n     * @param indexedShapeId\n     *            ID of the indexed Shape that will be used in the Query\n     * @param indexedShapeType\n     *            Index type of the indexed Shapes\n     ",
      "vertexLabel": "GeoShapeQueryBuilder()"
    },
    {
      "vertexName": "Method public abstract long getLastSyncedGlobalCheckpoint()  (Engine.java)",
      "comment": "\n     * Returns the latest global checkpoint value that has been persisted in the underlying storage (i.e. translog's checkpoint)\n     ",
      "vertexLabel": "abstract long getLastSyncedGlobalCheckpoint()"
    },
    {
      "vertexName": "Method native int VirtualQueryEx(Pointer handle, Pointer address, MemoryBasicInformation memoryInfo, int length)  (JNAKernel32Library.java)",
      "children": [
        {
          "name": "Method native boolean VirtualLock(Pointer address, SizeT size)  (JNAKernel32Library.java)"
        },
        {
          "name": "Method native boolean SetProcessWorkingSetSize(Pointer handle, SizeT minSize, SizeT maxSize)  (JNAKernel32Library.java)"
        },
        {
          "name": "Class MemoryBasicInformation  (JNAKernel32Library.java)"
        }
      ],
      "comment": "\n     * Retrieves information about a range of pages within the virtual address space of a specified process.\n     *\n     * https://msdn.microsoft.com/en-us/library/windows/desktop/aa366907%28v=vs.85%29.aspx\n     *\n     * @param handle A handle to the process whose memory information is queried.\n     * @param address A pointer to the base address of the region of pages to be queried.\n     * @param memoryInfo A pointer to a structure in which information about the specified page range is returned.\n     * @param length The size of the buffer pointed to by the memoryInfo parameter, in bytes.\n     * @return the actual number of bytes returned in the information buffer.\n     ",
      "vertexLabel": "native int VirtualQueryEx()"
    },
    {
      "vertexName": "Method protected ValuesSourceAggregationBuilder(StreamInput in, ValuesSourceType valuesSourceType) throws IOException  (ValuesSourceAggregationBuilder.java)",
      "comment": "\n     * Read an aggregation from a stream that serializes its targetValueType. This should only be used by subclasses that override\n     * {@link #serializeTargetValueType()} to return true.\n     ",
      "vertexLabel": "ValuesSourceAggregationBuilder()"
    },
    {
      "vertexName": "Method public static List<TransportAddress> resolveHostsLists(final ExecutorService executorService, final Logger logger, final List<String> hosts, final int limitPortCounts, final TransportService transportService, final TimeValue resolveTimeout)  (UnicastZenPing.java)",
      "children": [
        {
          "name": "Interface HostsResolver  (UnicastHostsProvider.java)"
        }
      ],
      "comment": "\n     * Resolves a list of hosts to a list of transport addresses. Each host is resolved into a transport address (or a collection of\n     * addresses if the number of ports is greater than one). Host lookups are done in parallel using specified executor service up\n     * to the specified resolve timeout.\n     *\n     * @param executorService  the executor service used to parallelize hostname lookups\n     * @param logger           logger used for logging messages regarding hostname lookups\n     * @param hosts            the hosts to resolve\n     * @param limitPortCounts  the number of ports to resolve (should be 1 for non-local transport)\n     * @param transportService the transport service\n     * @param resolveTimeout   the timeout before returning from hostname lookups\n     * @return a list of resolved transport addresses\n     ",
      "vertexLabel": "List<TransportAddress> resolveHostsLists()"
    },
    {
      "vertexName": "Method public Builder put(String key, org.apache.lucene.util.Version luceneVersion)  (Settings.java)",
      "children": [
        {
          "name": "Method public Builder put(String key, Enum<?> enumValue)  (Settings.java)"
        }
      ],
      "comment": "\n         * Sets an lucene version setting with the provided setting key and lucene version instance.\n         *\n         * @param key  The setting key\n         * @param luceneVersion The setting value\n         * @return The builder\n         ",
      "vertexLabel": "Builder put()"
    },
    {
      "vertexName": "Method private Updates changes(ShardId shardId)  (IndexMetaDataUpdater.java)",
      "comment": "\n     * Helper method that creates update entry for the given shard id if such an entry does not exist yet.\n     ",
      "vertexLabel": "Updates changes()"
    },
    {
      "vertexName": "Method public Builder put(String setting, boolean value)  (Settings.java)",
      "children": [
        {
          "name": "Method public Builder put(String setting, double value)  (Settings.java)"
        }
      ],
      "comment": "\n         * Sets the setting with the provided setting key and the boolean value.\n         *\n         * @param setting The setting key\n         * @param value   The boolean value\n         * @return The builder\n         ",
      "vertexLabel": "Builder put()"
    },
    {
      "vertexName": "Method public RestoreSnapshotRequest indicesOptions(IndicesOptions indicesOptions)  (RestoreSnapshotRequest.java)",
      "children": [
        {
          "name": "Method public IndicesOptions indicesOptions()  (RestoreSnapshotRequest.java)"
        },
        {
          "name": "Method public DeleteIndexRequestBuilder setIndicesOptions(IndicesOptions options)  (DeleteIndexRequestBuilder.java)"
        }
      ],
      "comment": "\n     * Specifies what type of requested indices to ignore and how to deal with wildcard expressions.\n     * For example indices that don't exist.\n     *\n     * @param indicesOptions the desired behaviour regarding indices to ignore and wildcard indices expressions\n     * @return this request\n     ",
      "vertexLabel": "RestoreSnapshotRequest indicesOptions()"
    },
    {
      "vertexName": "Class Bucket  (UnmappedSignificantTerms.java)",
      "children": [
        {
          "name": "Class Bucket  (UnmappedTerms.java)"
        }
      ],
      "comment": "\n     * Concrete type that can't be built because Java needs a concrete type so {@link InternalTerms.Bucket} can have a self type but\n     * {@linkplain UnmappedTerms} doesn't ever need to build it because it never returns any buckets.\n     ",
      "vertexLabel": "Class Bucket"
    },
    {
      "vertexName": "Method ActionFuture<DeleteResponse> delete(DeleteRequest request)  (Client.java)",
      "comment": "\n     * Deletes a document from the index based on the index, type and id.\n     *\n     * @param request The delete request\n     * @return The result future\n     * @see Requests#deleteRequest(String)\n     ",
      "vertexLabel": "ActionFuture<DeleteResponse> delete()"
    },
    {
      "vertexName": "Method public ShardRestoreStatus(String nodeId, State state)  (RestoreInProgress.java)",
      "children": [
        {
          "name": "Method public ShardRestoreStatus(String nodeId)  (RestoreInProgress.java)"
        }
      ],
      "comment": "\n         * Constructs a new shard restore status in with specified state on the given node\n         *\n         * @param nodeId node id\n         * @param state  restore state\n         ",
      "vertexLabel": "ShardRestoreStatus()"
    },
    {
      "vertexName": "Field NOOP_FIELD_PREDICATE  (MapperPlugin.java)",
      "children": [
        {
          "name": "Field NOOP_FIELD_FILTER  (MapperPlugin.java)"
        }
      ],
      "comment": "\n     * The default field predicate applied, which doesn't filter anything. That means that by default get mappings, get index\n     * get field mappings and field capabilities API will return every field that's present in the mappings.\n     ",
      "vertexLabel": "Field NOOP_FIELD_PREDICATE"
    },
    {
      "vertexName": "Method public Explicit(T value, boolean explicit)  (Explicit.java)",
      "children": [
        {
          "name": "Method public boolean explicit()  (Explicit.java)"
        }
      ],
      "comment": "\n     * Create a value with an indication if this was an explicit choice\n     * @param value a setting value\n     * @param explicit true if the value passed is a conscious decision, false if using some kind of default\n     ",
      "vertexLabel": "Explicit()"
    },
    {
      "vertexName": "Class DiverseDocsDeferringCollector  (DiversifiedOrdinalsSamplerAggregator.java)",
      "children": [
        {
          "name": "Class DiverseDocsDeferringCollector  (DiversifiedBytesHashSamplerAggregator.java)"
        }
      ],
      "comment": "\n     * A {@link DeferringBucketCollector} that identifies top scoring documents\n     * but de-duped by a key then passes only these on to nested collectors.\n     * This implementation is only for use with a single bucket aggregation.\n     ",
      "vertexLabel": "Class DiverseDocsDeferringCollector"
    },
    {
      "vertexName": "Method public MatchPhrasePrefixQueryBuilder analyzer(String analyzer)  (MatchPhrasePrefixQueryBuilder.java)",
      "comment": "\n     * Explicitly set the analyzer to use. Defaults to use explicit mapping\n     * config for the field, or, if not set, the default search analyzer.\n     ",
      "vertexLabel": "MatchPhrasePrefixQueryBuilder analyzer()"
    },
    {
      "vertexName": "Method void onFetchPhase(SearchContext searchContext, long tookInNanos)  (SearchOperationListener.java)",
      "children": [
        {
          "name": "Method void onQueryPhase(SearchContext searchContext, long tookInNanos)  (SearchOperationListener.java)"
        }
      ],
      "comment": "\n     * Executed after the fetch phase successfully finished.\n     * Note: this is not invoked if the fetch phase execution failed.\n     * @param searchContext the current search context\n     * @param tookInNanos the number of nanoseconds the fetch execution took\n     *\n     * @see #onFailedFetchPhase(SearchContext)\n     ",
      "vertexLabel": "void onFetchPhase()"
    },
    {
      "vertexName": "Method public void bootstrapNewHistory(long maxSeqNo) throws IOException  (Store.java)",
      "children": [
        {
          "name": "Method public void bootstrapNewHistory() throws IOException  (Store.java)"
        }
      ],
      "comment": "\n     * Marks an existing lucene index with a new history uuid and sets the given maxSeqNo as the local checkpoint\n     * as well as the maximum sequence number.\n     * This is used to make sure no existing shard will recovery from this index using ops based recovery.\n     * @see SequenceNumbers#LOCAL_CHECKPOINT_KEY\n     * @see SequenceNumbers#MAX_SEQ_NO\n     ",
      "vertexLabel": "void bootstrapNewHistory()"
    },
    {
      "vertexName": "Method public byte[] getFieldValueAsBytes(String path, boolean ignoreMissing)  (IngestDocument.java)",
      "children": [
        {
          "name": "Method public byte[] getFieldValueAsBytes(String path)  (IngestDocument.java)"
        }
      ],
      "comment": "\n     * Returns the value contained in the document for the provided path as a byte array.\n     * If the path value is a string, a base64 decode operation will happen.\n     * If the path value is a byte array, it is just returned\n     * @param path The path within the document in dot-notation\n     * @param ignoreMissing The flag to determine whether to throw an exception when `path` is not found in the document.\n     * @return the byte array for the provided path if existing\n     * @throws IllegalArgumentException if the path is null, empty, invalid, if the field doesn't exist\n     * or if the field that is found at the provided path is not of the expected type.\n     ",
      "vertexLabel": "byte[] getFieldValueAsBytes()"
    },
    {
      "vertexName": "Method public IndexRequest routing(String routing)  (IndexRequest.java)",
      "children": [
        {
          "name": "Method public GetRequest routing(String routing)  (GetRequest.java)"
        }
      ],
      "comment": "\n     * Controls the shard routing of the request. Using this value to hash the shard\n     * and not the id.\n     ",
      "vertexLabel": "IndexRequest routing()"
    },
    {
      "vertexName": "Method public void trimTranslog()  (IndexShard.java)",
      "children": [
        {
          "name": "Method public abstract void trimUnreferencedTranslogFiles() throws EngineException  (Engine.java)"
        }
      ],
      "comment": "\n     * checks and removes translog files that no longer need to be retained. See\n     * {@link org.elasticsearch.index.translog.TranslogDeletionPolicy} for details\n     ",
      "vertexLabel": "void trimTranslog()"
    },
    {
      "vertexName": "Method public void setMaxDocFreq(int maxFreq)  (XMoreLikeThis.java)",
      "children": [
        {
          "name": "Method public MoreLikeThisQueryBuilder maxDocFreq(int maxDocFreq)  (MoreLikeThisQueryBuilder.java)"
        }
      ],
      "comment": "\n     * Set the maximum frequency in which words may still appear. Words that appear\n     * in more than this many docs will be ignored.\n     *\n     * @param maxFreq the maximum count of documents that a term may appear\n     * in to be still considered relevant\n     ",
      "vertexLabel": "void setMaxDocFreq()"
    },
    {
      "vertexName": "Method public TopHitsAggregationBuilder scriptField(String name, Script script, boolean ignoreFailure)  (TopHitsAggregationBuilder.java)",
      "children": [
        {
          "name": "Method public TopHitsAggregationBuilder scriptField(String name, Script script)  (TopHitsAggregationBuilder.java)"
        }
      ],
      "comment": "\n     * Adds a script field under the given name with the provided script.\n     *\n     * @param name\n     *            The name of the field\n     * @param script\n     *            The script\n     ",
      "vertexLabel": "TopHitsAggregationBuilder scriptField()"
    },
    {
      "vertexName": "Method public boolean ignoreUnmapped()  (NestedQueryBuilder.java)",
      "comment": "\n     * Gets whether the query builder will ignore unmapped fields (and run a\n     * {@link MatchNoDocsQuery} in place of this query) or throw an exception if\n     * the path is unmapped.\n     ",
      "vertexLabel": "boolean ignoreUnmapped()"
    },
    {
      "vertexName": "Method public Builder putList(String setting, String... values)  (Settings.java)",
      "children": [
        {
          "name": "Method public Builder putList(String setting, List<String> values)  (Settings.java)"
        }
      ],
      "comment": "\n         * Sets the setting with the provided setting key and an array of values.\n         *\n         * @param setting The setting key\n         * @param values  The values\n         * @return The builder\n         ",
      "vertexLabel": "Builder putList()"
    },
    {
      "vertexName": "Method public T get(Settings settings)  (Setting.java)",
      "comment": "\n     * Returns the settings value. If the setting is not present in the given settings object the default value is returned\n     * instead.\n     ",
      "vertexLabel": "T get()"
    },
    {
      "vertexName": "Method public static byte[] intToBytes(int val)  (Numbers.java)",
      "comment": "\n     * Converts an int to a byte array.\n     *\n     * @param val The int to convert to a byte array\n     * @return The byte array converted\n     ",
      "vertexLabel": "byte[] intToBytes()"
    },
    {
      "vertexName": "Method void onRemoval(ShardId shardId, Accountable accountable)  (BitsetFilterCache.java)",
      "children": [
        {
          "name": "Method void onCache(ShardId shardId, Accountable accountable)  (BitsetFilterCache.java)"
        }
      ],
      "comment": "\n         * Called for each cached bitset on the removal event.\n         * @param shardId the shard id the bitset was cached for. This can be <code>null</code>\n         * @param accountable the bitsets ram representation\n         ",
      "vertexLabel": "void onRemoval()"
    },
    {
      "vertexName": "Method public static ShardId extractShardId(DirectoryReader reader)  (ShardUtils.java)",
      "children": [
        {
          "name": "Method public static ShardId extractShardId(LeafReader reader)  (ShardUtils.java)"
        }
      ],
      "comment": "\n     * Tries to extract the shard id from a reader if possible, when its not possible,\n     * will return null.\n     ",
      "vertexLabel": "ShardId extractShardId()"
    },
    {
      "vertexName": "Method public GetRepositoriesRequest(String[] repositories)  (GetRepositoriesRequest.java)",
      "children": [
        {
          "name": "Method public GetRepositoriesRequest repositories(String[] repositories)  (GetRepositoriesRequest.java)"
        }
      ],
      "comment": "\n     * Constructs a new get repositories request with a list of repositories.\n     * <p>\n     * If the list of repositories is empty or it contains a single element \"_all\", all registered repositories\n     * are returned.\n     *\n     * @param repositories list of repositories\n     ",
      "vertexLabel": "GetRepositoriesRequest()"
    },
    {
      "vertexName": "Class AbstractBinaryDocValues  (AbstractBinaryDocValues.java)",
      "children": [
        {
          "name": "Class AbstractSortedDocValues  (AbstractSortedDocValues.java)"
        }
      ],
      "comment": "\n * Base implementation that throws an {@link IOException} for the\n * {@link DocIdSetIterator} APIs. This impl is safe to use for sorting and\n * aggregations, which only use {@link #advanceExact(int)} and\n * {@link #binaryValue()}.\n ",
      "vertexLabel": "Class AbstractBinaryDocValues"
    },
    {
      "vertexName": "Method protected DecayFunctionBuilder(String fieldName, Object origin, Object scale, Object offset)  (DecayFunctionBuilder.java)",
      "comment": "\n     * Convenience constructor that converts its parameters into json to parse on the data nodes.\n     ",
      "vertexLabel": "DecayFunctionBuilder()"
    },
    {
      "vertexName": "Method public void close()  (BulkProcessor.java)",
      "comment": "\n     * Closes the processor. If flushing by time is enabled, then it's shutdown. Any remaining bulk actions are flushed.\n     ",
      "vertexLabel": "void close()"
    },
    {
      "vertexName": "Method private PriorityQueue<ScoreTerm> retrieveTerms(Reader r, String fieldName) throws IOException  (XMoreLikeThis.java)",
      "children": [
        {
          "name": "Method public String[] retrieveInterestingTerms(Reader r, String fieldName) throws IOException  (XMoreLikeThis.java)"
        }
      ],
      "comment": "\n     * Find words for a more-like-this query former.\n     * The result is a priority queue of arrays with one entry for <b>every word</b> in the document.\n     * Each array has 6 elements.\n     * The elements are:\n     * <ol>\n     * <li> The word (String)\n     * <li> The top field that this word comes from (String)\n     * <li> The score for this word (Float)\n     * <li> The IDF value (Float)\n     * <li> The frequency of this word in the index (Integer)\n     * <li> The frequency of this word in the source document (Integer)\n     * </ol>\n     * This is a somewhat \"advanced\" routine, and in general only the 1st entry in the array is of interest.\n     * This method is exposed so that you can identify the \"interesting words\" in a document.\n     * For an easier method to call see {@link #retrieveInterestingTerms retrieveInterestingTerms()}.\n     *\n     * @param r the reader that has the content of the document\n     * @param fieldName field passed to the analyzer to use when analyzing the content\n     * @return the most interesting words in the document ordered by score, with the highest scoring, or best entry, first\n     * @see #retrieveInterestingTerms\n     ",
      "vertexLabel": "PriorityQueue<ScoreTerm> retrieveTerms()"
    },
    {
      "vertexName": "Method public void addHeader(String key, String... value)  (ElasticsearchException.java)",
      "children": [
        {
          "name": "Method public void addHeader(String key, List<String> value)  (ElasticsearchException.java)"
        }
      ],
      "comment": "\n     * Adds a new header with the given key.\n     * This method will replace existing header if a header with the same key already exists\n     ",
      "vertexLabel": "void addHeader()"
    },
    {
      "vertexName": "Method public UpdateRequestBuilder setScript(Script script)  (UpdateRequestBuilder.java)",
      "children": [
        {
          "name": "Method public UpdateRequest script(Script script)  (UpdateRequest.java)"
        }
      ],
      "comment": "\n     * The script to execute. Note, make sure not to send different script each times and instead\n     * use script params if possible with the same (automatically compiled) script.\n     * <p>\n     * The script works with the variable <code>ctx</code>, which is bound to the entry,\n     * e.g. <code>ctx._source.mycounter += 1</code>.\n     *\n     ",
      "vertexLabel": "UpdateRequestBuilder setScript()"
    },
    {
      "vertexName": "Method public static long readGlobalCheckpoint(final Path location, final String expectedTranslogUUID) throws IOException  (Translog.java)",
      "comment": "\n     * Reads the sequence numbers global checkpoint from the translog checkpoint.\n     * This ensures that the translogUUID from this translog matches with the provided translogUUID.\n     *\n     * @param location the location of the translog\n     * @return the global checkpoint\n     * @throws IOException                if an I/O exception occurred reading the checkpoint\n     * @throws TranslogCorruptedException if the translog is corrupted or mismatched with the given uuid\n     ",
      "vertexLabel": "long readGlobalCheckpoint()"
    },
    {
      "vertexName": "Method public UpdateRequestBuilder setWaitForActiveShards(ActiveShardCount waitForActiveShards)  (UpdateRequestBuilder.java)",
      "children": [
        {
          "name": "Method public UpdateRequest waitForActiveShards(ActiveShardCount waitForActiveShards)  (UpdateRequest.java)"
        }
      ],
      "comment": "\n     * Sets the number of shard copies that must be active before proceeding with the write.\n     * See {@link ReplicationRequest#waitForActiveShards(ActiveShardCount)} for details.\n     ",
      "vertexLabel": "UpdateRequestBuilder setWaitForActiveShards()"
    },
    {
      "vertexName": "Method public DeleteRequest(String index, String type, String id)  (DeleteRequest.java)",
      "children": [
        {
          "name": "Method public GetRequest(String index, String type, String id)  (GetRequest.java)"
        }
      ],
      "comment": "\n     * Constructs a new delete request against the specified index with the type and id.\n     *\n     * @param index The index to get the document from\n     * @param type  The type of the document\n     * @param id    The id of the document\n     ",
      "vertexLabel": "DeleteRequest()"
    },
    {
      "vertexName": "Method public abstract long nextRoundingValue(long value)  (Rounding.java)",
      "comment": "\n     * Given the rounded value (which was potentially generated by {@link #round(long)}, returns the next rounding value. For example, with\n     * interval based rounding, if the interval is 3, {@code nextRoundValue(6) = 9 }.\n     *\n     * @param value The current rounding value\n     * @return The next rounding value\n     ",
      "vertexLabel": "abstract long nextRoundingValue()"
    },
    {
      "vertexName": "Method public SearchSourceBuilder sort(String name, SortOrder order)  (SearchSourceBuilder.java)",
      "children": [
        {
          "name": "Method public TopHitsAggregationBuilder sort(String name, SortOrder order)  (TopHitsAggregationBuilder.java)"
        }
      ],
      "comment": "\n     * Adds a sort against the given field name and the sort ordering.\n     *\n     * @param name\n     *            The name of the field\n     * @param order\n     *            The sort ordering\n     ",
      "vertexLabel": "SearchSourceBuilder sort()"
    },
    {
      "vertexName": "Method public DeleteByQueryRequest setRouting(String routing)  (DeleteByQueryRequest.java)",
      "comment": "\n     * Set routing limiting the process to the shards that match that routing value\n     ",
      "vertexLabel": "DeleteByQueryRequest setRouting()"
    },
    {
      "vertexName": "Method public static void registerProxyActionWithDynamicResponseType(TransportService service, String action, Function<TransportRequest, Writeable.Reader<? extends TransportResponse>> responseFunction)  (TransportActionProxy.java)",
      "children": [
        {
          "name": "Method public static void registerProxyAction(TransportService service, String action, Writeable.Reader<? extends TransportResponse> reader)  (TransportActionProxy.java)"
        }
      ],
      "comment": "\n     * Registers a proxy request handler that allows to forward requests for the given action to another node. To be used when the\n     * response type changes based on the upcoming request (quite rare)\n     ",
      "vertexLabel": "void registerProxyActionWithDynamicResponseType()"
    },
    {
      "vertexName": "Method public synchronized void addAffixUpdateConsumer(Setting.AffixSetting<T> setting, BiConsumer<String, T> consumer, BiConsumer<String, T> validator)  (AbstractScopedSettings.java)",
      "comment": "\n     * Adds a settings consumer for affix settings. Affix settings have a namespace associated to it that needs to be available to the\n     * consumer in order to be processed correctly.\n     ",
      "vertexLabel": "synchronized void addAffixUpdateConsumer()"
    },
    {
      "vertexName": "Method public DeleteRequest routing(String routing)  (DeleteRequest.java)",
      "comment": "\n     * Controls the shard routing of the request. Using this value to hash the shard\n     * and not the id.\n     ",
      "vertexLabel": "DeleteRequest routing()"
    },
    {
      "vertexName": "Method public PercentilesAggregationBuilder compression(double compression)  (PercentilesAggregationBuilder.java)",
      "children": [
        {
          "name": "Method public PercentileRanksAggregationBuilder compression(double compression)  (PercentileRanksAggregationBuilder.java)"
        }
      ],
      "comment": "\n     * Expert: set the compression. Higher values improve accuracy but also\n     * memory usage. Only relevant when using {@link PercentilesMethod#TDIGEST}.\n     ",
      "vertexLabel": "PercentilesAggregationBuilder compression()"
    },
    {
      "vertexName": "Method public TermVectorsRequest(TermVectorsRequest other)  (TermVectorsRequest.java)",
      "children": [
        {
          "name": "Method public TermVectorsRequest(String index, String type, String id)  (TermVectorsRequest.java)"
        }
      ],
      "comment": "\n     * Constructs a new term vector request for a document that will be fetch\n     * from the provided index. Use {@link #type(String)} and\n     * {@link #id(String)} to specify the document to load.\n     ",
      "vertexLabel": "TermVectorsRequest()"
    },
    {
      "vertexName": "Method public MembersInjector<T> getMembersInjector()  (MembersInjectorLookup.java)",
      "children": [
        {
          "name": "Method public Provider<T> getProvider()  (ProviderLookup.java)"
        }
      ],
      "comment": "\n     * Returns the looked up members injector. The result is not valid until this lookup has been\n     * initialized, which usually happens when the injector is created. The members injector will\n     * throw an {@code IllegalStateException} if you try to use it beforehand.\n     ",
      "vertexLabel": "MembersInjector<T> getMembersInjector()"
    },
    {
      "vertexName": "Method public synchronized void updateFromMaster(final long applyingClusterStateVersion, final Set<String> inSyncAllocationIds, final IndexShardRoutingTable routingTable, final Set<String> pre60AllocationIds)  (ReplicationTracker.java)",
      "comment": "\n     * Notifies the tracker of the current allocation IDs in the cluster state.\n     *\n     * @param applyingClusterStateVersion the cluster state version being applied when updating the allocation IDs from the master\n     * @param inSyncAllocationIds         the allocation IDs of the currently in-sync shard copies\n     * @param routingTable                the shard routing table\n     * @param pre60AllocationIds          the allocation IDs of shards that are allocated to pre-6.0 nodes\n     ",
      "vertexLabel": "synchronized void updateFromMaster()"
    },
    {
      "vertexName": "Method String readSysFsCgroupCpuAcctCpuAcctUsage(final String controlGroup) throws IOException  (OsProbe.java)",
      "children": [
        {
          "name": "Method String readSysFsCgroupMemoryLimitInBytes(final String controlGroup) throws IOException  (OsProbe.java)"
        }
      ],
      "comment": "\n     * Returns the line from {@code cpuacct.usage} for the control group to which the Elasticsearch process belongs for the {@code cpuacct}\n     * subsystem. This line represents the total CPU time in nanoseconds consumed by all tasks in the same control group.\n     *\n     * @param controlGroup the control group to which the Elasticsearch process belongs for the {@code cpuacct} subsystem\n     * @return the line from {@code cpuacct.usage}\n     * @throws IOException if an I/O exception occurs reading {@code cpuacct.usage} for the control group\n     ",
      "vertexLabel": "String readSysFsCgroupCpuAcctCpuAcctUsage()"
    },
    {
      "vertexName": "Method public HB boundaryScannerType(BoundaryScannerType boundaryScannerType)  (AbstractHighlighterBuilder.java)",
      "children": [
        {
          "name": "Method public HB boundaryScannerType(String boundaryScannerType)  (AbstractHighlighterBuilder.java)"
        }
      ],
      "comment": "\n     * When using the highlighterType {@code fvh} this setting\n     * controls which scanner to use for fragment boundaries, and defaults to \"simple\".\n     ",
      "vertexLabel": "HB boundaryScannerType()"
    },
    {
      "vertexName": "Method public boolean isPreserveExisting()  (UpdateSettingsRequest.java)",
      "children": [
        {
          "name": "Method public boolean isPreserveExisting()  (UpdateSettingsClusterStateUpdateRequest.java)"
        }
      ],
      "comment": "\n     * Returns <code>true</code> iff the settings update should only add but not update settings. If the setting already exists\n     * it should not be overwritten by this update. The default is <code>false</code>\n     ",
      "vertexLabel": "boolean isPreserveExisting()"
    },
    {
      "vertexName": "Method V visit(ProviderKeyBinding<? extends T> binding)  (BindingTargetVisitor.java)",
      "children": [
        {
          "name": "Interface ProviderKeyBinding  (ProviderKeyBinding.java)"
        }
      ],
      "comment": "\n     * Visit a provider key binding. To resolve injections, the provider key is first resolved, then\n     * that provider's {@code get} method is invoked. This target is found in both module and injector\n     * bindings.\n     ",
      "vertexLabel": "V visit()"
    },
    {
      "vertexName": "Method public static double quadTreeCellHeight(int level)  (GeoUtils.java)",
      "children": [
        {
          "name": "Method public static double quadTreeCellWidth(int level)  (GeoUtils.java)"
        }
      ],
      "comment": "\n     * Calculate the height (in meters) of quadtree cells at a specific level\n     * @param level quadtree level must be greater or equal to zero\n     * @return the height of cells at level in meters\n     ",
      "vertexLabel": "double quadTreeCellHeight()"
    },
    {
      "vertexName": "Method public void submitStateUpdateTasks(final String source, final Map<T, ClusterStateTaskListener> tasks, final ClusterStateTaskConfig config, final ClusterStateTaskExecutor<T> executor)  (MasterService.java)",
      "children": [
        {
          "name": "Method public void submitStateUpdateTasks(final String source, final Map<T, ClusterStateTaskListener> tasks, final ClusterStateTaskConfig config, final ClusterStateTaskExecutor<T> executor)  (ClusterService.java)"
        }
      ],
      "comment": "\n     * Submits a batch of cluster state update tasks; submitted updates are guaranteed to be processed together,\n     * potentially with more tasks of the same executor.\n     *\n     * @param source   the source of the cluster state update task\n     * @param tasks    a map of update tasks and their corresponding listeners\n     * @param config   the cluster state update task configuration\n     * @param executor the cluster state update task executor; tasks\n     *                 that share the same executor will be executed\n     *                 batches on this executor\n     * @param <T>      the type of the cluster state update task state\n     *\n     ",
      "vertexLabel": "void submitStateUpdateTasks()"
    },
    {
      "vertexName": "Method public VType get(int key)  (ImmutableOpenIntMap.java)",
      "children": [
        {
          "name": "Method public VType getOrDefault(KType key, VType defaultValue)  (ImmutableOpenMap.java)"
        }
      ],
      "comment": "\n     * @return Returns the value associated with the given key or the default value\n     * for the key type, if the key is not associated with any value.\n     * <p>\n     * <b>Important note:</b> For primitive type values, the value returned for a non-existing\n     * key may not be the default value of the primitive type (it may be any value previously\n     * assigned to that slot).\n     ",
      "vertexLabel": "VType get()"
    },
    {
      "vertexName": "Method protected void initializeUnassignedShard(RoutingAllocation allocation, RoutingNodes routingNodes, RoutingNode routingNode, ShardRouting shardRouting)  (AbstractAllocateAllocationCommand.java)",
      "comment": "\n     * Initializes an unassigned shard on a node and removes it from the unassigned\n     *\n     * @param allocation the allocation\n     * @param routingNodes the routing nodes\n     * @param routingNode the node to initialize it to\n     * @param shardRouting the shard routing that is to be matched in unassigned shards\n     ",
      "vertexLabel": "void initializeUnassignedShard()"
    },
    {
      "vertexName": "Method public RestoreSnapshotRequest settings(Settings settings)  (RestoreSnapshotRequest.java)",
      "children": [
        {
          "name": "Method public RestoreSnapshotRequest settings(Map<String, Object> source)  (RestoreSnapshotRequest.java)"
        }
      ],
      "comment": "\n     * Sets repository-specific restore settings.\n     * <p>\n     * See repository documentation for more information.\n     *\n     * @param settings repository-specific snapshot settings\n     * @return this request\n     ",
      "vertexLabel": "RestoreSnapshotRequest settings()"
    },
    {
      "vertexName": "Method public CloseIndexRequestBuilder setIndicesOptions(IndicesOptions indicesOptions)  (CloseIndexRequestBuilder.java)",
      "children": [
        {
          "name": "Method public MultiSearchRequestBuilder setIndicesOptions(IndicesOptions indicesOptions)  (MultiSearchRequestBuilder.java)"
        },
        {
          "name": "Method public IndicesOptions indicesOptions()  (RestoreSnapshotRequest.java)"
        },
        {
          "name": "Method public CreateSnapshotRequest indicesOptions(IndicesOptions indicesOptions)  (CreateSnapshotRequest.java)"
        }
      ],
      "comment": "\n     * Specifies what type of requested indices to ignore and wildcard indices expressions\n     * For example indices that don't exist.\n     *\n     * @param indicesOptions the desired behaviour regarding indices to ignore and indices wildcard expressions\n     * @return the request itself\n     ",
      "vertexLabel": "CloseIndexRequestBuilder setIndicesOptions()"
    },
    {
      "vertexName": "Method public MultiTermVectorsShardRequest preference(String preference)  (MultiTermVectorsShardRequest.java)",
      "children": [
        {
          "name": "Method public MultiGetRequest preference(String preference)  (MultiGetRequest.java)"
        }
      ],
      "comment": "\n     * Sets the preference to execute the search. Defaults to randomize across shards. Can be set to\n     * {@code _local} to prefer local shards or a custom value, which guarantees that the same order\n     * will be used across different requests.\n     ",
      "vertexLabel": "MultiTermVectorsShardRequest preference()"
    },
    {
      "vertexName": "Method CompositeValuesSourceConfig(String name, @Nullable MappedFieldType fieldType, ValuesSource vs, DocValueFormat format, SortOrder order, boolean missingBucket)  (CompositeValuesSourceConfig.java)",
      "comment": "\n     * Creates a new {@link CompositeValuesSourceConfig}.\n     * @param name The name of the source.\n     * @param fieldType The field type or null if the source is a script.\n     * @param vs The underlying {@link ValuesSource}.\n     * @param format The {@link DocValueFormat} of this source.\n     * @param order The sort order associated with this source.\n     ",
      "vertexLabel": "CompositeValuesSourceConfig()"
    },
    {
      "vertexName": "Method public SortedTopDocs sortDocs(boolean ignoreFrom, Collection<? extends SearchPhaseResult> results, final Collection<TopDocs> bufferedTopDocs, final TopDocsStats topDocsStats, int from, int size)  (SearchPhaseController.java)",
      "children": [
        {
          "name": "Method public InternalSearchResponse merge(boolean ignoreFrom, ReducedQueryPhase reducedQueryPhase, Collection<? extends SearchPhaseResult> fetchResults, IntFunction<SearchPhaseResult> resultsLookup)  (SearchPhaseController.java)"
        }
      ],
      "comment": "\n     * Returns a score doc array of top N search docs across all shards, followed by top suggest docs for each\n     * named completion suggestion across all shards. If more than one named completion suggestion is specified in the\n     * request, the suggest docs for a named suggestion are ordered by the suggestion name.\n     *\n     * Note: The order of the sorted score docs depends on the shard index in the result array if the merge process needs to disambiguate\n     * the result. In oder to obtain stable results the shard index (index of the result in the result array) must be the same.\n     *\n     * @param ignoreFrom Whether to ignore the from and sort all hits in each shard result.\n     *                   Enabled only for scroll search, because that only retrieves hits of length 'size' in the query phase.\n     * @param results the search phase results to obtain the sort docs from\n     * @param bufferedTopDocs the pre-consumed buffered top docs\n     * @param topDocsStats the top docs stats to fill\n     * @param from the offset into the search results top docs\n     * @param size the number of hits to return from the merged top docs\n     ",
      "vertexLabel": "SortedTopDocs sortDocs()"
    },
    {
      "vertexName": "Method public void setFieldNames(String[] fieldNames)  (XMoreLikeThis.java)",
      "children": [
        {
          "name": "Method public String[] getFieldNames()  (XMoreLikeThis.java)"
        }
      ],
      "comment": "\n     * Sets the field names that will be used when generating the 'More Like This' query.\n     * Set this to null for the field names to be determined at runtime from the IndexReader\n     * provided in the constructor.\n     *\n     * @param fieldNames the field names that will be used when generating the 'More Like This'\n     * query.\n     ",
      "vertexLabel": "void setFieldNames()"
    },
    {
      "vertexName": "Method public RestoreSnapshotRequestBuilder setIndexSettings(Settings settings)  (RestoreSnapshotRequestBuilder.java)",
      "children": [
        {
          "name": "Method public RestoreSnapshotRequestBuilder setIndexSettings(Map<String, Object> source)  (RestoreSnapshotRequestBuilder.java)"
        }
      ],
      "comment": "\n     * Sets index settings that should be added or replaced during restore\n     *\n     * @param settings index settings\n     * @return this builder\n     ",
      "vertexLabel": "RestoreSnapshotRequestBuilder setIndexSettings()"
    },
    {
      "vertexName": "Method public DoubleArray grow(DoubleArray array, long minSize)  (BigArrays.java)",
      "children": [
        {
          "name": "Method public ByteArray grow(ByteArray array, long minSize)  (BigArrays.java)"
        }
      ],
      "comment": " Grow an array to a size that is larger than <code>minSize</code>,\n     * preserving content, and potentially reusing part of the provided array. ",
      "vertexLabel": "DoubleArray grow()"
    },
    {
      "vertexName": "Method static T rewrite(T original, QueryRewriteContext context) throws IOException  (Rewriteable.java)",
      "children": [
        {
          "name": "Method static AggregationBuilder rewriteAggregation(AggregationBuilder original, QueryRewriteContext context) throws IOException  (AggregationBuilder.java)"
        }
      ],
      "comment": "\n     * Rewrites the given {@link Rewriteable} into its primitive form. Rewriteables that for instance fetch resources from remote hosts or\n     * can simplify / optimize itself should do their heavy lifting during {@link #rewrite(QueryRewriteContext)}. This method\n     * rewrites the rewriteable until it doesn't change anymore.\n     * @param original the original rewriteable to rewrite\n     * @param context the rewrite context to use\n     * @throws IOException if an {@link IOException} occurs\n     ",
      "vertexLabel": "T rewrite()"
    },
    {
      "vertexName": "Method public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException  (StoredScriptSource.java)",
      "comment": "\n     * This will write XContent from a {@link StoredScriptSource}. The following format will be written:\n     *\n     * {@code\n     * {\n     *     \"script\" : {\n     *         \"lang\" : \"<lang>\",\n     *         \"source\" : \"<source>\",\n     *         \"options\" : {\n     *             \"option0\" : \"<option0>\",\n     *             \"option1\" : \"<option1>\",\n     *             ...\n     *         }\n     *     }\n     * }\n     * }\n     *\n     * Note that the 'source' parameter can also handle templates written as complex JSON.\n     ",
      "vertexLabel": "XContentBuilder toXContent()"
    },
    {
      "vertexName": "Method LeafBucketCollector getLeafCollector(Comparable<?> forceLeadSourceValue, LeafReaderContext context, LeafBucketCollector in) throws IOException  (CompositeValuesCollectorQueue.java)",
      "children": [
        {
          "name": "Method LeafBucketCollector getLeafCollector(LeafReaderContext context, LeafBucketCollector in) throws IOException  (CompositeValuesCollectorQueue.java)"
        }
      ],
      "comment": "\n     * Creates the collector that will visit the composite buckets of the matching documents.\n     * If <code>forceLeadSourceValue</code> is not null, the leading source will use this value\n     * for each document.\n     * The provided collector <code>in</code> is called on each composite bucket.\n     ",
      "vertexLabel": "LeafBucketCollector getLeafCollector()"
    },
    {
      "vertexName": "Method public Durability getDurability()  (ChildMemoryCircuitBreaker.java)",
      "comment": "\n     * @return whether a tripped circuit breaker will reset itself (transient) or requires manual intervention (permanent).\n     ",
      "vertexLabel": "Durability getDurability()"
    },
    {
      "vertexName": "Method public Map<Integer, IndexShardUpgradeStatus> getShards()  (IndexUpgradeStatus.java)",
      "children": [
        {
          "name": "Method public Map<Integer, IndexShardSegments> getShards()  (IndexSegments.java)"
        }
      ],
      "comment": "\n     * A shard id to index shard upgrade status map (note, index shard upgrade status is the replication shard group that maps\n     * to the shard id).\n     ",
      "vertexLabel": "Map<Integer, IndexShardUpgradeStatus> getShards()"
    },
    {
      "vertexName": "Method protected boolean set(@Nullable V value)  (BaseFuture.java)",
      "comment": "\n     * Subclasses should invoke this method to set the result of the computation\n     * to {@code value}.  This will set the state of the future to\n     * {@link BaseFuture.Sync#COMPLETED} and call {@link #done()} if the\n     * state was successfully changed.\n     *\n     * @param value the value that was the result of the task.\n     * @return true if the state was successfully changed.\n     ",
      "vertexLabel": "boolean set()"
    },
    {
      "vertexName": "Method public SliceBuilder(String field, int id, int max)  (SliceBuilder.java)",
      "children": [
        {
          "name": "Method public SliceQuery(String field, int id, int max)  (SliceQuery.java)"
        }
      ],
      "comment": "\n     *\n     * @param field The name of the field\n     * @param id The id of the slice\n     * @param max The maximum number of slices\n     ",
      "vertexLabel": "SliceBuilder()"
    },
    {
      "vertexName": "Method public static List<T> readOptionalList(String processorType, String processorTag, Map<String, Object> configuration, String propertyName)  (ConfigurationUtils.java)",
      "children": [
        {
          "name": "Method public static String readOptionalStringOrIntProperty(String processorType, String processorTag, Map<String, Object> configuration, String propertyName)  (ConfigurationUtils.java)"
        }
      ],
      "comment": "\n     * Returns and removes the specified property of type list from the specified configuration map.\n     *\n     * If the property value isn't of type list an {@link ElasticsearchParseException} is thrown.\n     ",
      "vertexLabel": "List<T> readOptionalList()"
    },
    {
      "vertexName": "Method void requestInjection(TypeLiteral<T> type, T instance)  (Binder.java)",
      "children": [
        {
          "name": "Method void requestInjection(Object instance)  (Binder.java)"
        }
      ],
      "comment": "\n     * Upon successful creation, the {@link Injector} will inject instance fields\n     * and methods of the given object.\n     *\n     * @param type     of instance\n     * @param instance for which members will be injected\n     * @since 2.0\n     ",
      "vertexLabel": "void requestInjection()"
    },
    {
      "vertexName": "Field alpha  (HoltLinearModel.java)",
      "children": [
        {
          "name": "Field alpha  (EwmaModel.java)"
        }
      ],
      "comment": "\n     * Controls smoothing of data.  Also known as \"level\" value.\n     * Alpha = 1 retains no memory of past values\n     * (e.g. random walk), while alpha = 0 retains infinite memory of past values (e.g.\n     * mean of the series).\n     ",
      "vertexLabel": "Field alpha"
    },
    {
      "vertexName": "Method public void markAllocationIdAsInSync(final String allocationId, final long localCheckpoint) throws InterruptedException  (IndexShard.java)",
      "comment": "\n     * Marks the shard with the provided allocation ID as in-sync with the primary shard. See\n     * {@link ReplicationTracker#markAllocationIdAsInSync(String, long)}\n     * for additional details.\n     *\n     * @param allocationId    the allocation ID of the shard to mark as in-sync\n     * @param localCheckpoint the current local checkpoint on the shard\n     ",
      "vertexLabel": "void markAllocationIdAsInSync()"
    },
    {
      "vertexName": "Method ActionFuture<ExplainResponse> explain(ExplainRequest request)  (Client.java)",
      "comment": "\n     * Computes a score explanation for the specified request.\n     *\n     * @param request The request encapsulating the query and document identifier to compute a score explanation for\n     ",
      "vertexLabel": "ActionFuture<ExplainResponse> explain()"
    },
    {
      "vertexName": "Method public void localShardFailed(final ShardRouting shardRouting, final String message, @Nullable final Exception failure, Listener listener, final ClusterState currentState)  (ShardStateAction.java)",
      "children": [
        {
          "name": "Method public void localShardFailed(final ShardRouting shardRouting, final String message, @Nullable final Exception failure, Listener listener)  (ShardStateAction.java)"
        }
      ],
      "comment": "\n     * Send a shard failed request to the master node to update the cluster state when a shard on the local node failed.\n     ",
      "vertexLabel": "void localShardFailed()"
    },
    {
      "vertexName": "Class SortableLongBitsSortedNumericDocValues  (SortableLongBitsSortedNumericDocValues.java)",
      "children": [
        {
          "name": "Class SortableLongBitsNumericDocValues  (SortableLongBitsNumericDocValues.java)"
        }
      ],
      "comment": "\n * {@link SortedNumericDocValues} instance that wraps a {@link SortedNumericDoubleValues}\n * and converts the doubles to sortable long bits using\n * {@link NumericUtils#doubleToSortableLong(double)}.\n ",
      "vertexLabel": "Class SortableLongBitsSortedNumericDocValues"
    },
    {
      "vertexName": "Method public void acquireReplicaOperationPermit(final long opPrimaryTerm, final long globalCheckpoint, final long maxSeqNoOfUpdatesOrDeletes, final ActionListener<Releasable> onPermitAcquired, final String executorOnDelay, final Object debugInfo)  (IndexShard.java)",
      "children": [
        {
          "name": "Method void performOn(ShardRouting replica, RequestT replicaRequest, long globalCheckpoint, long maxSeqNoOfUpdatesOrDeletes, ActionListener<ReplicaResponse> listener)  (ReplicationOperation.java)"
        }
      ],
      "comment": "\n     * Acquire a replica operation permit whenever the shard is ready for indexing (see\n     * {@link #acquirePrimaryOperationPermit(ActionListener, String, Object)}). If the given primary term is lower than then one in\n     * {@link #shardRouting}, the {@link ActionListener#onFailure(Exception)} method of the provided listener is invoked with an\n     * {@link IllegalStateException}. If permit acquisition is delayed, the listener will be invoked on the executor with the specified\n     * name.\n     *\n     * @param opPrimaryTerm              the operation primary term\n     * @param globalCheckpoint           the global checkpoint associated with the request\n     * @param maxSeqNoOfUpdatesOrDeletes the max seq_no of updates (index operations overwrite Lucene) or deletes captured on the primary\n     *                                   after this replication request was executed on it (see {@link #getMaxSeqNoOfUpdatesOrDeletes()}\n     * @param onPermitAcquired           the listener for permit acquisition\n     * @param executorOnDelay            the name of the executor to invoke the listener on if permit acquisition is delayed\n     * @param debugInfo                  an extra information that can be useful when tracing an unreleased permit. When assertions are\n     *                                   enabled the tracing will capture the supplied object's {@link Object#toString()} value.\n     *                                   Otherwise the object isn't used\n     ",
      "vertexLabel": "void acquireReplicaOperationPermit()"
    },
    {
      "vertexName": "Method public static IndicesOptions strictExpand()  (IndicesOptions.java)",
      "children": [
        {
          "name": "Method public static IndicesOptions strictExpandOpen()  (IndicesOptions.java)"
        }
      ],
      "comment": "\n     * @return indices option that requires every specified index to exist, expands wildcards to both open and closed\n     * indices and allows that no indices are resolved from wildcard expressions (not returning an error).\n     ",
      "vertexLabel": "IndicesOptions strictExpand()"
    },
    {
      "vertexName": "Method public static DeleteIndexRequest deleteIndexRequest(String index)  (Requests.java)",
      "children": [
        {
          "name": "Method public static CloseIndexRequest closeIndexRequest(String index)  (Requests.java)"
        }
      ],
      "comment": "\n     * Creates a delete index request.\n     *\n     * @param index The index to delete\n     * @return The delete index request\n     * @see org.elasticsearch.client.IndicesAdminClient#delete(org.elasticsearch.action.admin.indices.delete.DeleteIndexRequest)\n     ",
      "vertexLabel": "DeleteIndexRequest deleteIndexRequest()"
    },
    {
      "vertexName": "Method public Set<String> availableIndexFoldersForPath(final NodePath nodePath) throws IOException  (NodeEnvironment.java)",
      "comment": "\n     * Return all directory names in the nodes/{node.id}/indices directory for the given node path.\n     *\n     * @param nodePath the path\n     * @return all directories that could be indices for the given node path.\n     * @throws IOException if an I/O exception occurs traversing the filesystem\n     ",
      "vertexLabel": "Set<String> availableIndexFoldersForPath()"
    },
    {
      "vertexName": "Method ActionFuture<IndexResponse> index(IndexRequest request)  (Client.java)",
      "children": [
        {
          "name": "Method IndexRequestBuilder prepareIndex()  (Client.java)"
        }
      ],
      "comment": "\n     * Index a JSON source associated with a given index and type.\n     * <p>\n     * The id is optional, if it is not provided, one will be generated automatically.\n     *\n     * @param request The index request\n     * @return The result future\n     * @see Requests#indexRequest(String)\n     ",
      "vertexLabel": "ActionFuture<IndexResponse> index()"
    },
    {
      "vertexName": "Method List<String> unconsumedParams()  (RestRequest.java)",
      "children": [
        {
          "name": "Method List<String> consumedParams()  (RestRequest.java)"
        }
      ],
      "comment": "\n     * Returns a list of parameters that have not yet been consumed. This method returns a copy,\n     * callers are free to modify the returned list.\n     *\n     * @return the list of currently unconsumed parameters.\n     ",
      "vertexLabel": "List<String> unconsumedParams()"
    },
    {
      "vertexName": "Method void sendMessage(BytesReference reference, ActionListener<Void> listener)  (TcpChannel.java)",
      "comment": "\n     * Sends a tcp message to the channel. The listener will be executed once the send process has been\n     * completed.\n     *\n     * @param reference to send to channel\n     * @param listener to execute upon send completion\n     ",
      "vertexLabel": "void sendMessage()"
    },
    {
      "vertexName": "Method public static Set<InjectionPoint> forStaticMethodsAndFields(Class<?> type)  (InjectionPoint.java)",
      "children": [
        {
          "name": "Method public static Set<InjectionPoint> forStaticMethodsAndFields(TypeLiteral type)  (InjectionPoint.java)"
        }
      ],
      "comment": "\n     * Returns all static method and field injection points on {@code type}.\n     *\n     * @return a possibly empty set of injection points. The set has a specified iteration order. All\n     *         fields are returned and then all methods. Within the fields, supertype fields are returned\n     *         before subtype fields. Similarly, supertype methods are returned before subtype methods.\n     * @throws ConfigurationException if there is a malformed injection point on {@code type}, such as\n     *                                a field with multiple binding annotations. The exception's {@link\n     *                                ConfigurationException#getPartialValue() partial value} is a {@code Set<InjectionPoint>}\n     *                                of the valid injection points.\n     ",
      "vertexLabel": "Set<InjectionPoint> forStaticsAndFields()"
    },
    {
      "vertexName": "Method V visit(UntargettedBinding<? extends T> binding)  (BindingTargetVisitor.java)",
      "comment": "\n     * Visit an untargetted binding. This target is found only on module bindings. It indicates\n     * that the injector should use its implicit binding strategies to resolve injections.\n     ",
      "vertexLabel": "V visit()"
    },
    {
      "vertexName": "Method public Map<Integer, IndexShardSegments> getShards()  (IndexSegments.java)",
      "comment": "\n     * A shard id to index shard segments map (note, index shard segments is the replication shard group that maps\n     * to the shard id).\n     ",
      "vertexLabel": "Map<Integer, IndexShardSegments> getShards()"
    },
    {
      "vertexName": "Method public UpdateRequest upsert(String source, XContentType xContentType)  (UpdateRequest.java)",
      "children": [
        {
          "name": "Method public UpdateRequest upsert(XContentBuilder source)  (UpdateRequest.java)"
        }
      ],
      "comment": "\n     * Sets the doc source of the update request to be used when the document does not exists.\n     ",
      "vertexLabel": "UpdateRequest upsert()"
    },
    {
      "vertexName": "Method public TermsQueryBuilder(String fieldName, double... values)  (TermsQueryBuilder.java)",
      "children": [
        {
          "name": "Method public TermsQueryBuilder(String fieldName, String... values)  (TermsQueryBuilder.java)"
        }
      ],
      "comment": "\n     * A filter for a field based on several terms matching on any of them.\n     *\n     * @param fieldName The field name\n     * @param values The terms\n     ",
      "vertexLabel": "TermsQueryBuilder()"
    },
    {
      "vertexName": "Method public ClusterHealthRequestBuilder setWaitForActiveShards(int waitForActiveShards)  (ClusterHealthRequestBuilder.java)",
      "children": [
        {
          "name": "Method public ResizeRequestBuilder setWaitForActiveShards(final int waitForActiveShards)  (ResizeRequestBuilder.java)"
        }
      ],
      "comment": "\n     * A shortcut for {@link #setWaitForActiveShards(ActiveShardCount)} where the numerical\n     * shard count is passed in, instead of having to first call {@link ActiveShardCount#from(int)}\n     * to get the ActiveShardCount.\n     ",
      "vertexLabel": "ClusterHealthRequestBuilder setWaitForActiveShards()"
    },
    {
      "vertexName": "Class MergingBucketsDeferringCollector  (MergingBucketsDeferringCollector.java)",
      "comment": "\n * A specialization of {@link DeferringBucketCollector} that collects all\n * matches and then is able to replay a given subset of buckets. Exposes\n * mergeBuckets, which can be invoked by the aggregator when increasing the\n * rounding interval.\n ",
      "vertexLabel": "Class MergingBucketsDeferringCollector"
    },
    {
      "vertexName": "Method long getNumIndexVersionsLookups()  (InternalEngine.java)",
      "comment": "\n     * Returns the number of times a version was looked up either from the index.\n     * Note this is only available if assertions are enabled\n     ",
      "vertexLabel": "long getNumIndexVersionsLookups()"
    },
    {
      "vertexName": "Method public SpanWithinQueryBuilder(SpanQueryBuilder big, SpanQueryBuilder little)  (SpanWithinQueryBuilder.java)",
      "children": [
        {
          "name": "Method public static SpanWithinQueryBuilder spanWithinQuery(SpanQueryBuilder big, SpanQueryBuilder little)  (QueryBuilders.java)"
        }
      ],
      "comment": "\n     * Query that returns spans from <code>little</code> that are contained in a spans from <code>big</code>.\n     * @param big clause that must enclose {@code little} for a match.\n     * @param little the little clause, it must be contained within {@code big} for a match.\n     ",
      "vertexLabel": "SpanWithinQueryBuilder()"
    },
    {
      "vertexName": "Method public SearchSourceBuilder indexBoost(String index, float indexBoost)  (SearchSourceBuilder.java)",
      "children": [
        {
          "name": "Method public SearchRequestBuilder addIndexBoost(String index, float indexBoost)  (SearchRequestBuilder.java)"
        }
      ],
      "comment": "\n     * Sets the boost a specific index or alias will receive when the query is executed\n     * against it.\n     *\n     * @param index\n     *            The index or alias to apply the boost against\n     * @param indexBoost\n     *            The boost to apply to the index\n     ",
      "vertexLabel": "SearchSourceBuilder indexBoost()"
    },
    {
      "vertexName": "Method public ClusterHealthRequestBuilder setWaitForActiveShards(ActiveShardCount waitForActiveShards)  (ClusterHealthRequestBuilder.java)",
      "children": [
        {
          "name": "Method public ClusterHealthRequest waitForActiveShards(ActiveShardCount waitForActiveShards)  (ClusterHealthRequest.java)"
        }
      ],
      "comment": "\n     * Sets the number of shard copies that must be active before getting the health status.\n     * Defaults to {@link ActiveShardCount#NONE}, meaning we don't wait on any active shards.\n     * Set this value to {@link ActiveShardCount#ALL} to wait for all shards (primary and\n     * all replicas) to be active across all indices in the cluster. Otherwise, use\n     * {@link ActiveShardCount#from(int)} to set this value to any non-negative integer, up to the\n     * total number of shard copies that would exist across all indices in the cluster.\n     ",
      "vertexLabel": "ClusterHealthRequestBuilder setWaitForActiveShards()"
    },
    {
      "vertexName": "Class SortableLongBitsToNumericDoubleValues  (SortableLongBitsToNumericDoubleValues.java)",
      "comment": "\n * {@link NumericDoubleValues} instance that wraps a {@link NumericDocValues}\n * and converts the doubles to sortable long bits using\n * {@link NumericUtils#sortableLongToDouble(long)}.\n ",
      "vertexLabel": "Class SortableLongBitsToNumericDoubleValues"
    },
    {
      "vertexName": "Method public static GeoDistanceSortBuilder geoDistanceSort(String fieldName, GeoPoint... points)  (SortBuilders.java)",
      "children": [
        {
          "name": "Method public GeoDistanceSortBuilder(String fieldName, GeoPoint... points)  (GeoDistanceSortBuilder.java)"
        }
      ],
      "comment": "\n     * Constructs a new distance based sort on a geo point like field.\n     *\n     * @param fieldName The geo point like field name.\n     * @param points The points to create the range distance facets from.\n     ",
      "vertexLabel": "GeoDistanceSortBuilder geoDistanceSort()"
    },
    {
      "vertexName": "Method public static void writeRawField(String field, BytesReference source, XContentBuilder builder, ToXContent.Params params) throws IOException  (XContentHelper.java)",
      "children": [
        {
          "name": "Method public static void writeRawField(String field, BytesReference source, XContentType xContentType, XContentBuilder builder, ToXContent.Params params) throws IOException  (XContentHelper.java)"
        }
      ],
      "comment": "\n     * Writes a \"raw\" (bytes) field, handling cases where the bytes are compressed, and tries to optimize writing using\n     * {@link XContentBuilder#rawField(String, InputStream)}.\n     * @deprecated use {@link #writeRawField(String, BytesReference, XContentType, XContentBuilder, Params)} to avoid content type\n     * auto-detection\n     ",
      "vertexLabel": "void writeRawField()"
    },
    {
      "vertexName": "Method public static IndicesOptions lenientExpandOpen()  (IndicesOptions.java)",
      "comment": "\n     * @return indices options that ignores unavailable indices, expands wildcards only to open indices and\n     *         allows that no indices are resolved from wildcard expressions (not returning an error).\n     ",
      "vertexLabel": "IndicesOptions lenientExpandOpen()"
    },
    {
      "vertexName": "Method TermVectorsRequestBuilder prepareTermVector(String index, String type, String id)  (Client.java)",
      "children": [
        {
          "name": "Method TermVectorsRequestBuilder prepareTermVectors(String index, String type, String id)  (Client.java)"
        }
      ],
      "comment": "\n     * Builder for the term vector request.\n     *\n     * @param index The index to load the document from\n     * @param type  The type of the document\n     * @param id    The id of the document\n     ",
      "vertexLabel": "TermVectorsRequestBuilder prepareTermVector()"
    },
    {
      "vertexName": "Method public FunctionScoreQuery(Query subQuery, ScoreMode scoreMode, ScoreFunction[] functions, CombineFunction combineFunction, Float minScore, float maxBoost)  (FunctionScoreQuery.java)",
      "children": [
        {
          "name": "Method public FunctionScoreQuery(Query subQuery, ScoreFunction function, CombineFunction combineFunction, Float minScore, float maxBoost)  (FunctionScoreQuery.java)"
        }
      ],
      "comment": "\n     * Creates a FunctionScoreQuery with multiple score functions\n     * @param subQuery The query to match.\n     * @param scoreMode Defines how the different score functions should be combined.\n     * @param functions The {@link ScoreFunction}s to apply.\n     * @param combineFunction Defines how the query and function score should be applied.\n     * @param minScore The minimum score to consider a document.\n     * @param maxBoost The maximum applicable boost.\n     ",
      "vertexLabel": "FunctionScoreQuery()"
    },
    {
      "vertexName": "Class MatchPhraseQueryBuilder  (MatchPhraseQueryBuilder.java)",
      "children": [
        {
          "name": "Class MatchQueryBuilder  (MatchQueryBuilder.java)"
        }
      ],
      "comment": "\n * Match query is a query that analyzes the text and constructs a phrase query\n * as the result of the analysis.\n ",
      "vertexLabel": "Class MatchPhraseQueryBuilder"
    },
    {
      "vertexName": "Method public final void validate(final Settings settings, final boolean validateDependencies, final boolean ignorePrivateSettings, final boolean ignoreArchivedSettings)  (AbstractScopedSettings.java)",
      "children": [
        {
          "name": "Method public final void validate(final Settings settings, final boolean validateDependencies, final boolean validateInternalOrPrivateIndex)  (AbstractScopedSettings.java)"
        }
      ],
      "comment": "\n     * Validates that all settings are registered and valid.\n     *\n     * @param settings               the settings\n     * @param validateDependencies   true if dependent settings should be validated\n     * @param ignorePrivateSettings  true if private settings should be ignored during validation\n     * @param ignoreArchivedSettings true if archived settings should be ignored during validation\n     * @see Setting#getSettingsDependencies(String)\n     ",
      "vertexLabel": "final void validate()"
    },
    {
      "vertexName": "Method public TransportClient addTransportAddress(TransportAddress transportAddress)  (TransportClient.java)",
      "comment": "\n     * Adds a transport address that will be used to connect to.\n     * <p>\n     * The Node this transport address represents will be used if its possible to connect to it.\n     * If it is unavailable, it will be automatically connected to once it is up.\n     * <p>\n     * In order to get the list of all the current connected nodes, please see {@link #connectedNodes()}.\n     ",
      "vertexLabel": "TransportClient addTransportAddress()"
    },
    {
      "vertexName": "Method ActionFuture<TermVectorsResponse> termVectors(TermVectorsRequest request)  (Client.java)",
      "children": [
        {
          "name": "Method void termVectors(TermVectorsRequest request, ActionListener<TermVectorsResponse> listener)  (Client.java)"
        }
      ],
      "comment": "\n     * An action that returns the term vectors for a specific document.\n     *\n     * @param request The term vector request\n     * @return The response future\n     ",
      "vertexLabel": "ActionFuture<TermVectorsResponse> termVectors()"
    },
    {
      "vertexName": "Class ListTasksRequestBuilder  (ListTasksRequestBuilder.java)",
      "children": [
        {
          "name": "Class GetTaskRequestBuilder  (GetTaskRequestBuilder.java)"
        }
      ],
      "comment": "\n * Builder for the request to retrieve the list of tasks running on the specified nodes\n ",
      "vertexLabel": "Class ListTasksRequestBuilder"
    },
    {
      "vertexName": "Method public static double max(double[] values)  (MovingFunctions.java)",
      "children": [
        {
          "name": "Method public static double min(double[] values)  (MovingFunctions.java)"
        }
      ],
      "comment": "\n     * Find the maximum value in a window of values.\n     * If all values are missing/null/NaN, the return value will be NaN\n     ",
      "vertexLabel": "double max()"
    },
    {
      "vertexName": "Method public HighlightBuilder field(String name, int fragmentSize)  (HighlightBuilder.java)",
      "children": [
        {
          "name": "Method public HighlightBuilder field(String name)  (HighlightBuilder.java)"
        }
      ],
      "comment": "\n     * Adds a field to be highlighted with a provided fragment size (in characters), and\n     * default number of fragments of 5.\n     *\n     * @param name         The field to highlight\n     * @param fragmentSize The size of a fragment in characters\n     ",
      "vertexLabel": "HighlightBuilder field()"
    },
    {
      "vertexName": "Method public static void addSingleFilePath(Permissions policy, Path path, String permissions) throws IOException  (FilePermissionUtils.java)",
      "comment": "\n     * Add access to single file path\n     * @param policy current policy to add permissions to\n     * @param path the path itself\n     * @param permissions set of file permissions to grant to the path\n     ",
      "vertexLabel": "void addSingleFilePath()"
    },
    {
      "vertexName": "Method public ClusterHealthRequestBuilder setWaitForNoRelocatingShards(boolean waitForRelocatingShards)  (ClusterHealthRequestBuilder.java)",
      "children": [
        {
          "name": "Method public ClusterHealthRequest waitForNoRelocatingShards(boolean waitForNoRelocatingShards)  (ClusterHealthRequest.java)"
        }
      ],
      "comment": "\n     * Sets whether the request should wait for there to be no relocating shards before\n     * retrieving the cluster health status.  Defaults to <code>false</code>, meaning the\n     * operation does not wait on there being no more relocating shards.  Set to <code>true</code>\n     * to wait until the number of relocating shards in the cluster is 0.\n     ",
      "vertexLabel": "ClusterHealthRequestBuilder setWaitForNoRelocatingShards()"
    },
    {
      "vertexName": "Method public String getBase64UUID()  (RandomBasedUUIDGenerator.java)",
      "comment": "\n     * Returns a Base64 encoded version of a Version 4.0 compatible UUID\n     * as defined here: http://www.ietf.org/rfc/rfc4122.txt\n     ",
      "vertexLabel": "String getBase64UUID()"
    },
    {
      "vertexName": "Field STRICT_DATE_OPTIONAL_TIME  (DateFormatters.java)",
      "comment": "\n     * Returns a generic ISO datetime parser where the date is mandatory and the time is optional.\n     ",
      "vertexLabel": "Field STRICT_DATE_OPTIONAL_TIME"
    },
    {
      "vertexName": "Method public TopHitsAggregationBuilder scriptField(String name, Script script)  (TopHitsAggregationBuilder.java)",
      "comment": "\n     * Adds a script field under the given name with the provided script.\n     *\n     * @param name\n     *            The name of the field\n     * @param script\n     *            The script\n     ",
      "vertexLabel": "TopHitsAggregationBuilder scriptField()"
    },
    {
      "vertexName": "Method public static NodesUsageRequest nodesUsageRequest(String... nodesIds)  (Requests.java)",
      "children": [
        {
          "name": "Method public static NodesInfoRequest nodesInfoRequest(String... nodesIds)  (Requests.java)"
        }
      ],
      "comment": "\n     * Creates a nodes usage request against one or more nodes. Pass\n     * {@code null} or an empty array for all nodes.\n     *\n     * @param nodesIds\n     *            The nodes ids to get the usage for\n     * @return The nodes usage request\n     * @see org.elasticsearch.client.ClusterAdminClient#nodesUsage(org.elasticsearch.action.admin.cluster.node.usage.NodesUsageRequest)\n     ",
      "vertexLabel": "NodesUsageRequest nodesUsageRequest()"
    },
    {
      "vertexName": "Method public final void addValidationErrors(Iterable<String> errors)  (ValidationException.java)",
      "children": [
        {
          "name": "Method public final void addValidationError(String error)  (ValidationException.java)"
        }
      ],
      "comment": "\n     * Add a sequence of validation errors to the accumulating validation errors\n     * @param errors the errors to add\n     ",
      "vertexLabel": "final void addValidationErrors()"
    },
    {
      "vertexName": "Method public CreateIndexRequestBuilder setWaitForActiveShards(final int waitForActiveShards)  (CreateIndexRequestBuilder.java)",
      "children": [
        {
          "name": "Method public BulkRequest waitForActiveShards(final int waitForActiveShards)  (BulkRequest.java)"
        }
      ],
      "comment": "\n     * A shortcut for {@link #setWaitForActiveShards(ActiveShardCount)} where the numerical\n     * shard count is passed in, instead of having to first call {@link ActiveShardCount#from(int)}\n     * to get the ActiveShardCount.\n     ",
      "vertexLabel": "CreateIndexRequestBuilder setWaitForActiveShards()"
    },
    {
      "vertexName": "Method public SimpleQueryStringQueryParser(Map<String, Float> weights, int flags, Settings settings, QueryShardContext context)  (SimpleQueryStringQueryParser.java)",
      "comment": " Creates a new parser with custom flags used to enable/disable certain features. ",
      "vertexLabel": "SimpleQueryStringQueryParser()"
    },
    {
      "vertexName": "Method public Builder put(String key, Level level)  (Settings.java)",
      "children": [
        {
          "name": "Method public Builder put(String key, String value)  (Settings.java)"
        }
      ],
      "comment": "\n         * Sets an level setting with the provided setting key and level instance.\n         *\n         * @param key  The setting key\n         * @param level The setting value\n         * @return The builder\n         ",
      "vertexLabel": "Builder put()"
    },
    {
      "vertexName": "Method public static String arrayToDelimitedString(Object[] arr, String delim)  (Strings.java)",
      "children": [
        {
          "name": "Method public static String arrayToCommaDelimitedString(Object[] arr)  (Strings.java)"
        }
      ],
      "comment": "\n     * Convenience method to return a String array as a delimited (e.g. CSV)\n     * String. E.g. useful for <code>toString()</code> implementations.\n     *\n     * @param arr   the array to display\n     * @param delim the delimiter to use (probably a \",\")\n     * @return the delimited String\n     ",
      "vertexLabel": "String arrayToDelimitedString()"
    },
    {
      "vertexName": "Method public MovAvgPipelineAggregationBuilder window(int window)  (MovAvgPipelineAggregationBuilder.java)",
      "children": [
        {
          "name": "Method public int window()  (MovAvgPipelineAggregationBuilder.java)"
        }
      ],
      "comment": "\n     * Sets the window size for the moving average. This window will \"slide\"\n     * across the series, and the values inside that window will be used to\n     * calculate the moving avg value\n     *\n     * @param window\n     *            Size of window\n     ",
      "vertexLabel": "MovAvgPipelineAggregationBuilder window()"
    },
    {
      "vertexName": "Method public long runAsLong()  (TermsSetQueryScript.java)",
      "children": [
        {
          "name": "Method public long runAsLong()  (AggregationScript.java)"
        }
      ],
      "comment": "\n     * Return the result as a long. This is used by aggregation scripts over long fields.\n     ",
      "vertexLabel": "long runAsLong()"
    },
    {
      "vertexName": "Method CreateIndexRequestBuilder prepareCreate(String index)  (IndicesAdminClient.java)",
      "children": [
        {
          "name": "Method void resizeIndex(ResizeRequest request, ActionListener<ResizeResponse> listener)  (IndicesAdminClient.java)"
        }
      ],
      "comment": "\n     * Creates an index using an explicit request allowing to specify the settings of the index.\n     *\n     * @param index The index name to create\n     ",
      "vertexLabel": "CreateIndexRequestBuilder prepareCreate()"
    },
    {
      "vertexName": "Method public LoggingAwareMultiCommand(final String description)  (LoggingAwareMultiCommand.java)",
      "children": [
        {
          "name": "Method public EnvironmentAwareCommand(final String description)  (EnvironmentAwareCommand.java)"
        }
      ],
      "comment": "\n     * Construct the command with the specified command description. This command will have logging configured without reading Elasticsearch\n     * configuration files.\n     *\n     * @param description the command description\n     ",
      "vertexLabel": "LoggingAwareMultiCommand()"
    },
    {
      "vertexName": "Method void getAliases(GetAliasesRequest request, ActionListener<GetAliasesResponse> listener)  (IndicesAdminClient.java)",
      "children": [
        {
          "name": "Method void getIndex(GetIndexRequest request, ActionListener<GetIndexResponse> listener)  (IndicesAdminClient.java)"
        }
      ],
      "comment": "\n     * Get specific index aliases that exists in particular indices and / or by name.\n     *\n     * @param request  The index aliases request\n     * @param listener A listener to be notified with a result\n     ",
      "vertexLabel": "void getAliases()"
    },
    {
      "vertexName": "Method public Builder setFuzziness(Fuzziness fuzziness)  (FuzzyOptions.java)",
      "children": [
        {
          "name": "Method public Builder setFuzziness(int editDistance)  (FuzzyOptions.java)"
        }
      ],
      "comment": "\n         * Sets the level of fuzziness used to create suggestions using a {@link Fuzziness} instance.\n         * The default value is {@link Fuzziness#ONE} which allows for an \"edit distance\" of one.\n         ",
      "vertexLabel": "Builder setFuzziness()"
    },
    {
      "vertexName": "Method public static final long longEncode(final double lon, final double lat, final int level)  (GeoHashUtils.java)",
      "comment": "\n     * Encode lon/lat to the geohash based long format (lon/lat interleaved, 4 least significant bits = level)\n     ",
      "vertexLabel": "final long longEncode()"
    },
    {
      "vertexName": "Field slices  (AbstractBulkByScrollRequest.java)",
      "comment": "\n     * The number of slices this task should be divided into. Defaults to 1 meaning the task isn't sliced into subtasks.\n     ",
      "vertexLabel": "Field slices"
    },
    {
      "vertexName": "Method public DiscoveryNode(String id, TransportAddress address, Map<String, String> attributes, Set<Role> roles, Version version)  (DiscoveryNode.java)",
      "children": [
        {
          "name": "Method public DiscoveryNode(final String id, TransportAddress address, Version version)  (DiscoveryNode.java)"
        }
      ],
      "comment": "\n     * Creates a new {@link DiscoveryNode}\n     * <p>\n     * <b>Note:</b> if the version of the node is unknown {@link Version#minimumCompatibilityVersion()} should be used for the current\n     * version. it corresponds to the minimum version this elasticsearch version can communicate with. If a higher version is used\n     * the node might not be able to communicate with the remote node. After initial handshakes node versions will be discovered\n     * and updated.\n     * </p>\n     *\n     * @param id               the nodes unique (persistent) node id. This constructor will auto generate a random ephemeral id.\n     * @param address          the nodes transport address\n     * @param attributes       node attributes\n     * @param roles            node roles\n     * @param version          the version of the node\n     ",
      "vertexLabel": "DiscoveryNode()"
    },
    {
      "vertexName": "Method protected abstract void validate(AggregatorFactory<?> parent, Collection<AggregationBuilder> aggregationBuilders, Collection<PipelineAggregationBuilder> pipelineAggregatorBuilders)  (PipelineAggregationBuilder.java)",
      "children": [
        {
          "name": "Method public final void validate(AggregatorFactory<?> parent, Collection<AggregationBuilder> factories, Collection<PipelineAggregationBuilder> pipelineAggregatorFactories)  (AbstractPipelineAggregationBuilder.java)"
        }
      ],
      "comment": "\n     * Internal: Validates the state of this factory (makes sure the factory is properly\n     * configured)\n     ",
      "vertexLabel": "abstract void validate()"
    },
    {
      "vertexName": "Method public BulkRequestBuilder add(IndexRequestBuilder request)  (BulkRequestBuilder.java)",
      "children": [
        {
          "name": "Method public BulkProcessor add(IndexRequest request)  (BulkProcessor.java)"
        }
      ],
      "comment": "\n     * Adds an {@link IndexRequest} to the list of actions to execute. Follows the same behavior of {@link IndexRequest}\n     * (for example, if no id is provided, one will be generated, or usage of the create flag).\n     ",
      "vertexLabel": "BulkRequestBuilder add()"
    },
    {
      "vertexName": "Method public Map<String, Long> getRestUsage()  (NodeUsage.java)",
      "comment": "\n     * @return a map containing the counts of the number of times each REST\n     *         endpoint has been called\n     ",
      "vertexLabel": "Map<String, Long> getRestUsage()"
    },
    {
      "vertexName": "Class Multibinder  (Multibinder.java)",
      "comment": "\n * An API to bind multiple values separately, only to later inject them as a\n * complete collection. Multibinder is intended for use in your application's\n * module:\n * <pre><code>\n * public class SnacksModule extends AbstractModule {\n *   protected void configure() {\n *     Multibinder&lt;Snack&gt; multibinder\n *         = Multibinder.newSetBinder(binder(), Snack.class);\n *     multibinder.addBinding().toInstance(new Twix());\n *     multibinder.addBinding().toProvider(SnickersProvider.class);\n *     multibinder.addBinding().to(Skittles.class);\n *   }\n * }</code></pre>\n * <p>\n * With this binding, a {@link Set}{@code <Snack>} can now be injected:\n * <pre><code>\n * class SnackMachine {\n *   {@literal @}Inject\n *   public SnackMachine(Set&lt;Snack&gt; snacks) { ... }\n * }</code></pre>\n * <p>\n * Create multibindings from different modules is supported. For example, it\n * is okay to have both {@code CandyModule} and {@code ChipsModule} to both\n * create their own {@code Multibinder<Snack>}, and to each contribute bindings\n * to the set of snacks. When that set is injected, it will contain elements\n * from both modules.\n * <p>\n * Elements are resolved at set injection time. If an element is bound to a\n * provider, that provider's get method will be called each time the set is\n * injected (unless the binding is also scoped).\n * <p>\n * Annotations are be used to create different sets of the same element\n * type. Each distinct annotation gets its own independent collection of\n * elements.\n * <p>\n * <strong>Elements must be distinct.</strong> If multiple bound elements\n * have the same value, set injection will fail.\n * <p>\n * <strong>Elements must be non-null.</strong> If any set element is null,\n * set injection will fail.\n *\n * @author jessewilson@google.com (Jesse Wilson)\n ",
      "vertexLabel": "Class Multibinder"
    },
    {
      "vertexName": "Method R setRefreshPolicy(RefreshPolicy refreshPolicy)  (WriteRequest.java)",
      "comment": "\n     * Should this request trigger a refresh ({@linkplain RefreshPolicy#IMMEDIATE}), wait for a refresh (\n     * {@linkplain RefreshPolicy#WAIT_UNTIL}), or proceed ignore refreshes entirely ({@linkplain RefreshPolicy#NONE}, the default).\n     ",
      "vertexLabel": "R setRefreshPolicy()"
    },
    {
      "vertexName": "Method synchronized long getMinRetainedSeqNo()  (SoftDeletesPolicy.java)",
      "comment": "\n     * Returns the min seqno that is retained in the Lucene index.\n     * Operations whose seq# is least this value should exist in the Lucene index.\n     ",
      "vertexLabel": "synchronized long getMinRetainedSeqNo()"
    },
    {
      "vertexName": "Method public boolean exists(final Settings settings)  (Setting.java)",
      "comment": "\n     * Returns true if and only if this setting is present in the given settings instance. Note that fallback settings are excluded.\n     *\n     * @param settings the settings\n     * @return true if the setting is present in the given settings instance, otherwise false\n     ",
      "vertexLabel": "boolean exists()"
    },
    {
      "vertexName": "Method public BaseTermQueryBuilder(String fieldName, double value)  (BaseTermQueryBuilder.java)",
      "children": [
        {
          "name": "Method public BaseTermQueryBuilder(String fieldName, float value)  (BaseTermQueryBuilder.java)"
        }
      ],
      "comment": "\n     * Constructs a new base term query.\n     *\n     * @param fieldName  The name of the field\n     * @param value The value of the term\n     ",
      "vertexLabel": "BaseTermQueryBuilder()"
    },
    {
      "vertexName": "Interface DiscoveryPlugin  (DiscoveryPlugin.java)",
      "comment": "\n * An additional extension point for {@link Plugin}s that extends Elasticsearch's discovery functionality. To add an additional\n * {@link NetworkService.CustomNameResolver} just implement the interface and implement the {@link #getCustomNameResolver(Settings)} method:\n *\n * <pre>{@code\n * public class MyDiscoveryPlugin extends Plugin implements DiscoveryPlugin {\n *     &#64;Override\n *     public NetworkService.CustomNameResolver getCustomNameResolver(Settings settings) {\n *         return new YourCustomNameResolverInstance(settings);\n *     }\n * }\n * }</pre>\n ",
      "vertexLabel": "Interface DiscoveryPlugin"
    },
    {
      "vertexName": "Method public CreateIndexRequestBuilder addMapping(String type, Map<String, Object> source)  (CreateIndexRequestBuilder.java)",
      "children": [
        {
          "name": "Method public CreateIndexRequest mapping(String type, XContentBuilder source)  (CreateIndexRequest.java)"
        }
      ],
      "comment": "\n     * Adds mapping that will be added when the index gets created.\n     *\n     * @param type   The mapping type\n     * @param source The mapping source\n     ",
      "vertexLabel": "CreateIndexRequestBuilder addMapping()"
    },
    {
      "vertexName": "Method public boolean autoGenerateSynonymsPhraseQuery()  (SimpleQueryStringQueryParser.java)",
      "children": [
        {
          "name": "Method public boolean autoGenerateSynonymsPhraseQuery()  (SimpleQueryStringBuilder.java)"
        }
      ],
      "comment": "\n         * Whether phrase queries should be automatically generated for multi terms synonyms.\n         * Defaults to {@code true}.\n         ",
      "vertexLabel": "boolean autoGenerateSynonymsPhraseQuery()"
    },
    {
      "vertexName": "Method public static boolean isRepositoryInUse(ClusterState clusterState, String repository)  (SnapshotsService.java)",
      "comment": "\n     * Checks if a repository is currently in use by one of the snapshots\n     *\n     * @param clusterState cluster state\n     * @param repository   repository id\n     * @return true if repository is currently in use by one of the running snapshots\n     ",
      "vertexLabel": "boolean isRepositoryInUse()"
    },
    {
      "vertexName": "Method private ReducedQueryPhase reducedQueryPhase(Collection<? extends SearchPhaseResult> queryResults, List<InternalAggregations> bufferedAggs, List<TopDocs> bufferedTopDocs, TopDocsStats topDocsStats, int numReducePhases, boolean isScrollRequest)  (SearchPhaseController.java)",
      "children": [
        {
          "name": "Method public ReducedQueryPhase reducedQueryPhase(Collection<? extends SearchPhaseResult> queryResults, boolean isScrollRequest)  (SearchPhaseController.java)"
        }
      ],
      "comment": "\n     * Reduces the given query results and consumes all aggregations and profile results.\n     * @param queryResults a list of non-null query shard results\n     * @param bufferedAggs a list of pre-collected / buffered aggregations. if this list is non-null all aggregations have been consumed\n     *                    from all non-null query results.\n     * @param bufferedTopDocs a list of pre-collected / buffered top docs. if this list is non-null all top docs have been consumed\n     *                    from all non-null query results.\n     * @param numReducePhases the number of non-final reduce phases applied to the query results.\n     * @see QuerySearchResult#consumeAggs()\n     * @see QuerySearchResult#consumeProfileResult()\n     ",
      "vertexLabel": "ReducedQueryPhase reducedQueryPhase()"
    },
    {
      "vertexName": "Method public int getMaxConcurrentShardRequests()  (SearchRequest.java)",
      "children": [
        {
          "name": "Method public SearchRequestBuilder setMaxConcurrentShardRequests(int maxConcurrentShardRequests)  (SearchRequestBuilder.java)"
        }
      ],
      "comment": "\n     * Returns the number of shard requests that should be executed concurrently on a single node. This value should be used as a\n     * protection mechanism to reduce the number of shard requests fired per high level search request. Searches that hit the entire\n     * cluster can be throttled with this number to reduce the cluster load. The default is {@code 5}\n     ",
      "vertexLabel": "int getMaxConcurrentShardRequests()"
    },
    {
      "vertexName": "Method public IndexSettings(final IndexMetaData indexMetaData, final Settings nodeSettings)  (IndexSettings.java)",
      "comment": "\n     * Creates a new {@link IndexSettings} instance. The given node settings will be merged with the settings in the metadata\n     * while index level settings will overwrite node settings.\n     *\n     * @param indexMetaData the index metadata this settings object is associated with\n     * @param nodeSettings the nodes settings this index is allocated on.\n     ",
      "vertexLabel": "IndexSettings()"
    },
    {
      "vertexName": "Method IndexMetaData verifyIndexIsDeleted(Index index, ClusterState clusterState)  (IndicesClusterStateService.java)",
      "children": [
        {
          "name": "Method public IndexMetaData verifyIndexIsDeleted(final Index index, final ClusterState clusterState)  (IndicesService.java)"
        }
      ],
      "comment": "\n         * Verify that the contents on disk for the given index is deleted; if not, delete the contents.\n         * This method assumes that an index is already deleted in the cluster state and/or explicitly\n         * through index tombstones.\n         * @param index {@code Index} to make sure its deleted from disk\n         * @param clusterState {@code ClusterState} to ensure the index is not part of it\n         * @return IndexMetaData for the index loaded from disk\n         ",
      "vertexLabel": "IndexMetaData verifyIndexIsDeleted()"
    },
    {
      "vertexName": "Method public StopWatch start(String taskName) throws IllegalStateException  (StopWatch.java)",
      "children": [
        {
          "name": "Method public StopWatch start() throws IllegalStateException  (StopWatch.java)"
        }
      ],
      "comment": "\n     * Start a named task. The results are undefined if {@link #stop()}\n     * or timing methods are called without invoking this method.\n     *\n     * @param taskName the name of the task to start\n     * @see #stop()\n     ",
      "vertexLabel": "StopWatch start()"
    },
    {
      "vertexName": "Method private String getCgroupMemoryUsageInBytes(final String controlGroup) throws IOException  (OsProbe.java)",
      "children": [
        {
          "name": "Method private String getCgroupMemoryLimitInBytes(final String controlGroup) throws IOException  (OsProbe.java)"
        }
      ],
      "comment": "\n     * The total current memory usage by processes in the cgroup (in bytes).\n     * If there is no limit then some Linux versions return the maximum value that can be stored in an\n     * unsigned 64 bit number, and this will overflow a long, hence the result type is <code>String</code>.\n     * (The alternative would have been <code>BigInteger</code> but then it would not be possible to index\n     * the OS stats document into Elasticsearch without losing information, as <code>BigInteger</code> is\n     * not a supported Elasticsearch type.)\n     *\n     * @param controlGroup the control group for the Elasticsearch process for the {@code memory} subsystem\n     * @return the total current memory usage by processes in the cgroup (in bytes)\n     * @throws IOException if an I/O exception occurs reading {@code memory.limit_in_bytes} for the control group\n     ",
      "vertexLabel": "String getCgroupMemoryUsageInBytes()"
    },
    {
      "vertexName": "Method public long version()  (GetRequest.java)",
      "comment": "\n     * Sets the version, which will cause the get operation to only be performed if a matching\n     * version exists and no changes happened on the doc since then.\n     ",
      "vertexLabel": "long version()"
    },
    {
      "vertexName": "Method void explain(ExplainRequest request, ActionListener<ExplainResponse> listener)  (Client.java)",
      "children": [
        {
          "name": "Method ActionFuture<ExplainResponse> explain(ExplainRequest request)  (Client.java)"
        }
      ],
      "comment": "\n     * Computes a score explanation for the specified request.\n     *\n     * @param request  The request encapsulating the query and document identifier to compute a score explanation for\n     * @param listener A listener to be notified of the result\n     ",
      "vertexLabel": "void explain()"
    },
    {
      "vertexName": "Method public HB boundaryScannerType(String boundaryScannerType)  (AbstractHighlighterBuilder.java)",
      "comment": "\n     * When using the highlighterType {@code fvh} this setting\n     * controls which scanner to use for fragment boundaries, and defaults to \"simple\".\n     ",
      "vertexLabel": "HB boundaryScannerType()"
    },
    {
      "vertexName": "Method public ExecutorService generic()  (ThreadPool.java)",
      "comment": "\n     * Get the generic {@link ExecutorService}. This executor service\n     * {@link Executor#execute(Runnable)} method will run the {@link Runnable} it is given in the\n     * {@link ThreadContext} of the thread that queues it.\n     * <p>\n     * Warning: this {@linkplain ExecutorService} will not throw {@link RejectedExecutionException}\n     * if you submit a task while it shutdown. It will instead silently queue it and not run it.\n     ",
      "vertexLabel": "ExecutorService generic()"
    },
    {
      "vertexName": "Method static ClusterStateTaskConfig build(Priority priority)  (ClusterStateTaskConfig.java)",
      "comment": "\n     * Build a cluster state update task configuration with the\n     * specified {@link Priority} and no timeout.\n     *\n     * @param priority the priority for the associated cluster state\n     *                 update task\n     * @return the resulting cluster state update task configuration\n     ",
      "vertexLabel": "ClusterStateTaskConfig build()"
    },
    {
      "vertexName": "Method static boolean isExplicitAllPattern(List<String> aliasesOrIndices)  (IndexNameExpressionResolver.java)",
      "children": [
        {
          "name": "Method public static boolean isExplicitAllType(String[] types)  (MetaData.java)"
        }
      ],
      "comment": "\n     * Identifies whether the array containing index names given as argument explicitly refers to all indices\n     * The empty or null array doesn't explicitly map to all indices\n     *\n     * @param aliasesOrIndices the array containing index names\n     * @return true if the provided array explicitly maps to all indices, false otherwise\n     ",
      "vertexLabel": "boolean isExplicitAllPattern()"
    },
    {
      "vertexName": "Method public QuerySpec(String name, Writeable.Reader<T> reader, QueryParser<T> parser)  (SearchPlugin.java)",
      "comment": "\n         * Specification of custom {@link Query}.\n         *\n         * @param name the name by which this query might be parsed or deserialized. Make sure that the query builder returns this name for\n         *        {@link NamedWriteable#getWriteableName()}.\n         * @param reader the reader registered for this query's builder. Typically a reference to a constructor that takes a\n         *        {@link StreamInput}\n         * @param parser the parser the reads the query builder from xcontent\n         ",
      "vertexLabel": "QuerySpec()"
    },
    {
      "vertexName": "Method void segments(IndicesSegmentsRequest request, ActionListener<IndicesSegmentResponse> listener)  (IndicesAdminClient.java)",
      "children": [
        {
          "name": "Method void exists(IndicesExistsRequest request, ActionListener<IndicesExistsResponse> listener)  (IndicesAdminClient.java)"
        }
      ],
      "comment": "\n     * The segments of one or more indices.\n     *\n     * @param request  The indices segments request\n     * @param listener A listener to be notified with a result\n     * @see Requests#indicesSegmentsRequest(String...)\n     ",
      "vertexLabel": "void segments()"
    },
    {
      "vertexName": "Method private synchronized void breakIfBroken() throws BrokenBarrierException  (ThreadBarrier.java)",
      "comment": "\n     * breaks this barrier if it has been reset or broken for any other reason.\n     * <p>\n     * Note: This call is not atomic in respect to await/reset calls. A\n     * breakIfBroken() may be context switched to invoke a reset() prior to\n     * await(). This resets the barrier to its initial state - parties not\n     * currently waiting at the barrier will not be accounted for! An await that\n     * wasn't time limited, will block indefinitely.\n     *\n     * @throws BrokenBarrierException an empty BrokenBarrierException.\n     ",
      "vertexLabel": "synchronized void breakIfBroken()"
    },
    {
      "vertexName": "Class MatchQueryBuilder  (MatchQueryBuilder.java)",
      "comment": "\n * Match query is a query that analyzes the text and constructs a query as the\n * result of the analysis.\n ",
      "vertexLabel": "Class MatchQueryBuilder"
    },
    {
      "vertexName": "Method public MultiMatchQueryBuilder tieBreaker(float tieBreaker)  (MultiMatchQueryBuilder.java)",
      "comment": "\n     * <p>Tie-Breaker for \"best-match\" disjunction queries (OR-Queries).\n     * The tie breaker capability allows documents that match more than one query clause\n     * (in this case on more than one field) to be scored better than documents that\n     * match only the best of the fields, without confusing this with the better case of\n     * two distinct matches in the multiple fields.</p>\n     *\n     * <p>A tie-breaker value of {@code 1.0} is interpreted as a signal to score queries as\n     * \"most-match\" queries where all matching query clauses are considered for scoring.</p>\n     *\n     * @see Type\n     ",
      "vertexLabel": "MultiMatchQueryBuilder tieBreaker()"
    },
    {
      "vertexName": "Method void nodesUsage(NodesUsageRequest request, ActionListener<NodesUsageResponse> listener)  (ClusterAdminClient.java)",
      "children": [
        {
          "name": "Method void nodesInfo(NodesInfoRequest request, ActionListener<NodesInfoResponse> listener)  (ClusterAdminClient.java)"
        }
      ],
      "comment": "\n     * Nodes usage of the cluster.\n     *\n     * @param request\n     *            The nodes usage request\n     * @param listener\n     *            A listener to be notified with a result\n     * @see org.elasticsearch.client.Requests#nodesUsageRequest(String...)\n     ",
      "vertexLabel": "void nodesUsage()"
    },
    {
      "vertexName": "Method public static SpanContainingQueryBuilder spanContainingQuery(SpanQueryBuilder big, SpanQueryBuilder little)  (QueryBuilders.java)",
      "children": [
        {
          "name": "Method public static SpanWithinQueryBuilder spanWithinQuery(SpanQueryBuilder big, SpanQueryBuilder little)  (QueryBuilders.java)"
        }
      ],
      "comment": "\n     * Creates a new {@code span_containing} builder.\n     * @param big the big clause, it must enclose {@code little} for a match.\n     * @param little the little clause, it must be contained within {@code big} for a match.\n     ",
      "vertexLabel": "SpanContainingQueryBuilder spanContainingQuery()"
    },
    {
      "vertexName": "Method public DateRangeAggregationBuilder addRange(String key, DateTime from, DateTime to)  (DateRangeAggregationBuilder.java)",
      "children": [
        {
          "name": "Method public DateRangeAggregationBuilder addRange(String key, String from, String to)  (DateRangeAggregationBuilder.java)"
        }
      ],
      "comment": "\n     * Add a new range to this aggregation.\n     *\n     * @param key\n     *            the key to use for this range in the response\n     * @param from\n     *            the lower bound on the dates, inclusive\n     * @param to\n     *            the upper bound on the dates, exclusive\n     ",
      "vertexLabel": "DateRangeAggregationBuilder addRange()"
    },
    {
      "vertexName": "Method public double[] next(Collection<Double> values, int numForecasts)  (HoltLinearModel.java)",
      "children": [
        {
          "name": "Method public double[] next(Collection<Double> values, int numForecasts)  (HoltWintersModel.java)"
        }
      ],
      "comment": "\n     * Calculate a Holt-Linear (doubly exponential weighted) moving average\n     *\n     * @param values Collection of values to calculate avg for\n     * @param numForecasts number of forecasts into the future to return\n     *\n     * @return       Returns a Double containing the moving avg for the window\n     ",
      "vertexLabel": "double[] next()"
    },
    {
      "vertexName": "Method void getIndex(GetIndexRequest request, ActionListener<GetIndexResponse> listener)  (IndicesAdminClient.java)",
      "comment": "\n     * Get index metadata for particular indices.\n     *\n     * @param request  The index aliases request\n     * @param listener A listener to be notified with a result\n     ",
      "vertexLabel": "void getIndex()"
    },
    {
      "vertexName": "Class Builder  (Script.java)",
      "comment": "\n     * Helper class used by {@link ObjectParser} to store mutable {@link Script} variables and then\n     * construct an immutable {@link Script} object based on parsed XContent.\n     ",
      "vertexLabel": "Class Builder"
    },
    {
      "vertexName": "Method void index(IndexRequest request, ActionListener<IndexResponse> listener)  (Client.java)",
      "children": [
        {
          "name": "Method IndexRequestBuilder prepareIndex()  (Client.java)"
        },
        {
          "name": "Method void get(GetRequest request, ActionListener<GetResponse> listener)  (Client.java)"
        }
      ],
      "comment": "\n     * Index a document associated with a given index and type.\n     * <p>\n     * The id is optional, if it is not provided, one will be generated automatically.\n     *\n     * @param request  The index request\n     * @param listener A listener to be notified with a result\n     * @see Requests#indexRequest(String)\n     ",
      "vertexLabel": "void index()"
    },
    {
      "vertexName": "Class PersistentTasksExecutor  (PersistentTasksExecutor.java)",
      "comment": "\n * An executor of tasks that can survive restart of requesting or executing node.\n * These tasks are using cluster state rather than only transport service to send requests and responses.\n ",
      "vertexLabel": "Class PersistentTasksExecutor"
    },
    {
      "vertexName": "Method public static ClusterState removeStaleIdsWithoutRoutings(ClusterState clusterState, List<StaleShard> staleShards, Logger logger)  (IndexMetaDataUpdater.java)",
      "comment": "\n     * Removes allocation ids from the in-sync set for shard copies for which there is no routing entries in the routing table.\n     * This method is called in AllocationService before any changes to the routing table are made.\n     ",
      "vertexLabel": "ClusterState removeStaleIdsWithoutRoutings()"
    },
    {
      "vertexName": "Method public double parse(String distance, DistanceUnit defaultUnit)  (DistanceUnit.java)",
      "comment": "\n     * Parses a given distance and converts it to this unit.\n     * \n     * @param distance String defining a distance (value and unit)\n     * @param defaultUnit unit to expect if none if provided\n     * @return parsed distance\n     ",
      "vertexLabel": "double parse()"
    },
    {
      "vertexName": "Method public abstract void writeBytes(byte[] b, int offset, int length) throws IOException  (StreamOutput.java)",
      "children": [
        {
          "name": "Method public void writeBytes(byte[] b, int length) throws IOException  (StreamOutput.java)"
        }
      ],
      "comment": "\n     * Writes an array of bytes.\n     *\n     * @param b      the bytes to write\n     * @param offset the offset in the byte array\n     * @param length the number of bytes to write\n     ",
      "vertexLabel": "abstract void writeBytes()"
    },
    {
      "vertexName": "Method public LongArray grow(LongArray array, long minSize)  (BigArrays.java)",
      "children": [
        {
          "name": "Method public ByteArray grow(ByteArray array, long minSize)  (BigArrays.java)"
        }
      ],
      "comment": " Grow an array to a size that is larger than <code>minSize</code>,\n     * preserving content, and potentially reusing part of the provided array. ",
      "vertexLabel": "LongArray grow()"
    },
    {
      "vertexName": "Method public DateRangeAggregationBuilder addUnboundedFrom(String key, String from)  (DateRangeAggregationBuilder.java)",
      "children": [
        {
          "name": "Method public DateRangeAggregationBuilder addUnboundedTo(String key, String to)  (DateRangeAggregationBuilder.java)"
        }
      ],
      "comment": "\n     * Add a new range with no upper bound.\n     *\n     * @param key\n     *            the key to use for this range in the response\n     * @param from\n     *            the lower bound on the distances, inclusive\n     ",
      "vertexLabel": "DateRangeAggregationBuilder addUnboundedFrom()"
    },
    {
      "vertexName": "Method public CreateIndexRequestBuilder addMapping(String type, String source, XContentType xContentType)  (CreateIndexRequestBuilder.java)",
      "children": [
        {
          "name": "Method public CreateIndexRequest mapping(String type, String source, XContentType xContentType)  (CreateIndexRequest.java)"
        }
      ],
      "comment": "\n     * Adds mapping that will be added when the index gets created.\n     *\n     * @param type   The mapping type\n     * @param source The mapping source\n     * @param xContentType The content type of the source\n     ",
      "vertexLabel": "CreateIndexRequestBuilder addMapping()"
    },
    {
      "vertexName": "Method public VType get(KType key)  (ImmutableOpenMap.java)",
      "children": [
        {
          "name": "Method public VType get(int key)  (ImmutableOpenIntMap.java)"
        }
      ],
      "comment": "\n     * @return Returns the value associated with the given key or the default value\n     * for the key type, if the key is not associated with any value.\n     * <p>\n     * <b>Important note:</b> For primitive type values, the value returned for a non-existing\n     * key may not be the default value of the primitive type (it may be any value previously\n     * assigned to that slot).\n     ",
      "vertexLabel": "VType get()"
    },
    {
      "vertexName": "Method public boolean indexRoutingTableChanged(String index)  (ClusterChangedEvent.java)",
      "comment": "\n     * Returns <code>true</code> iff the routing table has changed for the given index.\n     * Note that this is an object reference equality test, not an equals test.\n     ",
      "vertexLabel": "boolean indexRoutingTableChanged()"
    },
    {
      "vertexName": "Method public SpecialPermission(String name, String actions)  (SpecialPermission.java)",
      "comment": "\n     * Creates a new SpecialPermission object.\n     * This constructor exists for use by the {@code Policy} object to instantiate new Permission objects.\n     *\n     * @param name ignored\n     * @param actions ignored\n     ",
      "vertexLabel": "SpecialPermission()"
    },
    {
      "vertexName": "Method RefreshPolicy getRefreshPolicy()  (WriteRequest.java)",
      "children": [
        {
          "name": "Method R setRefreshPolicy(RefreshPolicy refreshPolicy)  (WriteRequest.java)"
        }
      ],
      "comment": "\n     * Should this request trigger a refresh ({@linkplain RefreshPolicy#IMMEDIATE}), wait for a refresh (\n     * {@linkplain RefreshPolicy#WAIT_UNTIL}), or proceed ignore refreshes entirely ({@linkplain RefreshPolicy#NONE}, the default).\n     ",
      "vertexLabel": "RefreshPolicy getRefreshPolicy()"
    },
    {
      "vertexName": "Method public DateHistogramAggregationBuilder order(BucketOrder order)  (DateHistogramAggregationBuilder.java)",
      "children": [
        {
          "name": "Method public TermsAggregationBuilder order(BucketOrder order)  (TermsAggregationBuilder.java)"
        }
      ],
      "comment": " Set a new order on this builder and return the builder so that calls\n     *  can be chained. A tie-breaker may be added to avoid non-deterministic ordering. ",
      "vertexLabel": "DateHistogramAggregationBuilder order()"
    },
    {
      "vertexName": "Method public Boolean getAsBoolean(String setting, Boolean defaultValue)  (Settings.java)",
      "children": [
        {
          "name": "Method public String get(String setting, String defaultValue)  (Settings.java)"
        }
      ],
      "comment": "\n     * Returns the setting value (as boolean) associated with the setting key. If it does not exists,\n     * returns the default value provided.\n     ",
      "vertexLabel": "Boolean getAsBoolean()"
    },
    {
      "vertexName": "Method public boolean cancel(String reason, Runnable listener)  (TaskManager.java)",
      "comment": "\n         * Marks task as cancelled.\n         * <p>\n         * Returns true if cancellation was successful, false otherwise.\n         ",
      "vertexLabel": "boolean cancel()"
    },
    {
      "vertexName": "Method Aggregation(String path, boolean asc)  (InternalOrder.java)",
      "comment": "\n         * Create a new ordering strategy to sort by a sub-aggregation.\n         *\n         * @param path path to the sub-aggregation to sort on.\n         * @param asc  direction to sort by: {@code true} for ascending, {@code false} for descending.\n         * @see AggregationPath\n         ",
      "vertexLabel": "Aggregation()"
    },
    {
      "vertexName": "Method void bulk(BulkRequest request, ActionListener<BulkResponse> listener)  (Client.java)",
      "children": [
        {
          "name": "Method ActionFuture<BulkResponse> bulk(BulkRequest request)  (Client.java)"
        }
      ],
      "comment": "\n     * Executes a bulk of index / delete operations.\n     *\n     * @param request  The bulk request\n     * @param listener A listener to be notified with a result\n     * @see org.elasticsearch.client.Requests#bulkRequest()\n     ",
      "vertexLabel": "void bulk()"
    },
    {
      "vertexName": "Method public synchronized void updateLocalCheckpoint(final String allocationId, final long localCheckpoint)  (ReplicationTracker.java)",
      "children": [
        {
          "name": "Method public void updateLocalCheckpointForShard(final String allocationId, final long checkpoint)  (IndexShard.java)"
        }
      ],
      "comment": "\n     * Notifies the service to update the local checkpoint for the shard with the provided allocation ID. If the checkpoint is lower than\n     * the currently known one, this is a no-op. If the allocation ID is not tracked, it is ignored.\n     *\n     * @param allocationId    the allocation ID of the shard to update the local checkpoint for\n     * @param localCheckpoint the local checkpoint for the shard\n     ",
      "vertexLabel": "synchronized void updateLocalCheckpoint()"
    },
    {
      "vertexName": "Method void onFailure(Throwable t)  (NodeJoinController.java)",
      "comment": "\n         * called when the local node failed to be elected as master\n         * Guaranteed to be called on the cluster state update thread\n         *",
      "vertexLabel": "void onFailure()"
    },
    {
      "vertexName": "Method public static Map<String, Float> resolveMappingFields(QueryShardContext context, Map<String, Float> fieldsAndWeights, String fieldSuffix)  (QueryParserHelper.java)",
      "comment": "\n     * Resolve all the field names and patterns present in the provided map with the\n     * {@link QueryShardContext} and returns a new map containing all the expanded fields with their original boost.\n     * @param context The context of the query.\n     * @param fieldsAndWeights The map of fields and weights to expand.\n     * @param fieldSuffix The suffix name to add to the expanded field names if a mapping exists for that name.\n     *                    The original name of the field is kept if adding the suffix to the field name does not point to a valid field\n     *                    in the mapping.\n     ",
      "vertexLabel": "Map<String, Float> resolveMappingFields()"
    },
    {
      "vertexName": "Method public boolean hasField(TemplateScript.Factory fieldPathTemplate)  (IngestDocument.java)",
      "children": [
        {
          "name": "Method public boolean hasField(String path)  (IngestDocument.java)"
        }
      ],
      "comment": "\n     * Checks whether the document contains a value for the provided templated path\n     * @param fieldPathTemplate the template for the path within the document in dot-notation\n     * @return true if the document contains a value for the field, false otherwise\n     * @throws IllegalArgumentException if the path is null, empty or invalid\n     ",
      "vertexLabel": "boolean hasField()"
    },
    {
      "vertexName": "Method public String node()  (CancelAllocationCommand.java)",
      "comment": "\n     * Get the id of the node that manages the shard which allocation should be canceled\n     * @return id of the node that manages the shard which allocation should be canceled\n     ",
      "vertexLabel": "String node()"
    },
    {
      "vertexName": "Method public UpdateRequest upsert(byte[] source, int offset, int length, XContentType xContentType)  (UpdateRequest.java)",
      "children": [
        {
          "name": "Method public UpdateRequest upsert(byte[] source, XContentType xContentType)  (UpdateRequest.java)"
        }
      ],
      "comment": "\n     * Sets the doc source of the update request to be used when the document does not exists.\n     ",
      "vertexLabel": "UpdateRequest upsert()"
    },
    {
      "vertexName": "Method public Long getAsLong(String setting, Long defaultValue)  (Settings.java)",
      "children": [
        {
          "name": "Method public Integer getAsInt(String setting, Integer defaultValue)  (Settings.java)"
        }
      ],
      "comment": "\n     * Returns the setting value (as long) associated with the setting key. If it does not exists,\n     * returns the default value provided.\n     ",
      "vertexLabel": "Long getAsLong()"
    },
    {
      "vertexName": "Method public final void writeMapOfLists(final Map<K, List<V>> map, final Writer<K> keyWriter, final Writer<V> valueWriter) throws IOException  (StreamOutput.java)",
      "children": [
        {
          "name": "Method public final void writeMap(final Map<K, V> map, final Writer<K> keyWriter, final Writer<V> valueWriter) throws IOException  (StreamOutput.java)"
        }
      ],
      "comment": "\n     * Write a {@link Map} of {@code K}-type keys to {@code V}-type {@link List}s.\n     * <pre><code>\n     * Map&lt;String, List&lt;String&gt;&gt; map = ...;\n     * out.writeMapOfLists(map, StreamOutput::writeString, StreamOutput::writeString);\n     * </code></pre>\n     *\n     * @param keyWriter The key writer\n     * @param valueWriter The value writer\n     ",
      "vertexLabel": "final void writeMapOfLists()"
    },
    {
      "vertexName": "Method public RestoreSnapshotRequestBuilder setWaitForCompletion(boolean waitForCompletion)  (RestoreSnapshotRequestBuilder.java)",
      "children": [
        {
          "name": "Method public RestoreSnapshotRequest waitForCompletion(boolean waitForCompletion)  (RestoreSnapshotRequest.java)"
        }
      ],
      "comment": "\n     * If this parameter is set to true the operation will wait for completion of restore process before returning.\n     *\n     * @param waitForCompletion if true the operation will wait for completion\n     * @return this builder\n     ",
      "vertexLabel": "RestoreSnapshotRequestBuilder setWaitForCompletion()"
    },
    {
      "vertexName": "Class QueryStringQueryBuilder  (QueryStringQueryBuilder.java)",
      "comment": "\n * A query that parses a query string and runs it. There are two modes that this operates. The first,\n * when no field is added (using {@link #field(String)}, will run the query once and non prefixed fields\n * will use the {@link #defaultField(String)} set. The second, when one or more fields are added\n * (using {@link #field(String)}), will run the parsed query against the provided fields, and combine\n * them using Dismax.\n ",
      "vertexLabel": "Class QueryStringQueryBuilder"
    },
    {
      "vertexName": "Method public Builder precision(double meters)  (GeoContextMapping.java)",
      "comment": "\n         * Set the precision use o make suggestions\n         *\n         * @param meters\n         *            precision as distance in meters\n         * @return this\n         ",
      "vertexLabel": "Builder precision()"
    },
    {
      "vertexName": "Method public UpdateRequestBuilder setRetryOnConflict(int retryOnConflict)  (UpdateRequestBuilder.java)",
      "children": [
        {
          "name": "Method public UpdateRequest retryOnConflict(int retryOnConflict)  (UpdateRequest.java)"
        }
      ],
      "comment": "\n     * Sets the number of retries of a version conflict occurs because the document was updated between\n     * getting it and updating it. Defaults to 0.\n     ",
      "vertexLabel": "UpdateRequestBuilder setRetryOnConflict()"
    },
    {
      "vertexName": "Class BootstrapChecks  (BootstrapChecks.java)",
      "comment": "\n * We enforce bootstrap checks once a node has the transport protocol bound to a non-loopback interface or if the system property {@code\n * es.enforce.bootstrap.checks} is set to {@true}. In this case we assume the node is running in production and all bootstrap checks must\n * pass.\n ",
      "vertexLabel": "Class BootstrapChecks"
    },
    {
      "vertexName": "Interface Binding  (Binding.java)",
      "children": [
        {
          "name": "Method V visit(Binding<T> binding)  (ElementVisitor.java)"
        }
      ],
      "comment": "\n * A mapping from a key (type and optional annotation) to the strategy for getting instances of the\n * type. This interface is part of the introspection API and is intended primarily for use by\n * tools.\n * <p>\n * Bindings are created in several ways:\n * <ul>\n * <li>Explicitly in a module, via {@code bind()} and {@code bindConstant()}\n * statements:\n * <pre>\n *     bind(Service.class).annotatedWith(Red.class).to(ServiceImpl.class);\n *     bindConstant().annotatedWith(ServerHost.class).to(args[0]);</pre></li>\n * <li>Implicitly by the Injector by following a type's {@link ImplementedBy\n * pointer} {@link ProvidedBy annotations} or by using its {@link Inject annotated} or\n * default constructor.</li>\n * <li>By converting a bound instance to a different type.</li>\n * <li>For {@link Provider providers}, by delegating to the binding for the provided type.</li>\n * </ul>\n *\n *\n * <p>They exist on both modules and on injectors, and their behaviour is different for each:\n * <ul>\n * <li><strong>Module bindings</strong> are incomplete and cannot be used to provide instances.\n * This is because the applicable scopes and interceptors may not be known until an injector\n * is created. From a tool's perspective, module bindings are like the injector's source\n * code. They can be inspected or rewritten, but this analysis must be done statically.</li>\n * <li><strong>Injector bindings</strong> are complete and valid and can be used to provide\n * instances. From a tools' perspective, injector bindings are like reflection for an\n * injector. They have full runtime information, including the complete graph of injections\n * necessary to satisfy a binding.</li>\n * </ul>\n *\n * @param <T> the bound type. The injected is always assignable to this type.\n * @author crazybob@google.com (Bob Lee)\n * @author jessewilson@google.com (Jesse Wilson)\n ",
      "vertexLabel": "Interface Binding"
    },
    {
      "vertexName": "Method public String getMinimumShouldMatch()  (MoreLikeThisQuery.java)",
      "comment": "\n     * Number of terms that must match the generated query expressed in the\n     * common syntax for minimum should match.\n     *\n     * @see    org.elasticsearch.common.lucene.search.Queries#calculateMinShouldMatch(int, String)\n     ",
      "vertexLabel": "String getMinimumShouldMatch()"
    },
    {
      "vertexName": "Method public IndicesAliasesRequestBuilder addAlias(String[] indices, String alias, Map<String, Object> filter)  (IndicesAliasesRequestBuilder.java)",
      "children": [
        {
          "name": "Method public IndicesAliasesRequestBuilder addAlias(String[] indices, String alias, String filter)  (IndicesAliasesRequestBuilder.java)"
        }
      ],
      "comment": "\n     * Adds an alias to the index.\n     *\n     * @param indices The indices\n     * @param alias   The alias\n     * @param filter  The filter\n     ",
      "vertexLabel": "IndicesAliasesRequestBuilder addAlias()"
    },
    {
      "vertexName": "Method native boolean SetInformationJobObject(Pointer job, int infoClass, Pointer info, int infoLength)  (JNAKernel32Library.java)",
      "children": [
        {
          "name": "Method native boolean AssignProcessToJobObject(Pointer job, Pointer process)  (JNAKernel32Library.java)"
        }
      ],
      "comment": "\n     * Set job limit and state information\n     *\n     * https://msdn.microsoft.com/en-us/library/windows/desktop/ms686216%28v=vs.85%29.aspx\n     *\n     * @param job job handle\n     * @param infoClass information class constant\n     * @param info pointer to information structure\n     * @param infoLength size of information structure\n     * @return true if the function succeeds\n     ",
      "vertexLabel": "native boolean SetInformationJobObject()"
    },
    {
      "vertexName": "Method void endSnapshot(final SnapshotsInProgress.Entry entry)  (SnapshotsService.java)",
      "comment": "\n     * Finalizes the shard in repository and then removes it from cluster state\n     * <p>\n     * This is non-blocking method that runs on a thread from SNAPSHOT thread pool\n     *\n     * @param entry snapshot\n     ",
      "vertexLabel": "void endSnapshot()"
    },
    {
      "vertexName": "Method public UpdateRequest upsert(Map<String, Object> source, XContentType contentType)  (UpdateRequest.java)",
      "children": [
        {
          "name": "Method public UpdateRequest upsert(XContentBuilder source)  (UpdateRequest.java)"
        }
      ],
      "comment": "\n     * Sets the doc source of the update request to be used when the document does not exists.\n     ",
      "vertexLabel": "UpdateRequest upsert()"
    },
    {
      "vertexName": "EnumConstant INLINE  (ScriptType.java)",
      "comment": "\n     * INLINE scripts are specified in numerous queries and compiled on-the-fly.\n     * They will be cached based on the lang and code of the script.\n     * They are turned off by default because most languages are insecure\n     * (Groovy and others), but can be overridden by the specific {@link ScriptEngine}\n     * if the language is naturally secure (Painless, Mustache, and Expressions).\n     ",
      "vertexLabel": "EnumConstant INLINE"
    },
    {
      "vertexName": "Method public BinaryDocValues select(final SortedBinaryDocValues values, final BytesRef missingValue, final BitSet parentDocs, final DocIdSetIterator childDocs, int maxDoc, int maxChildren) throws IOException  (MultiValueMode.java)",
      "children": [
        {
          "name": "Method public SortedDocValues select(final SortedSetDocValues values, final BitSet parentDocs, final DocIdSetIterator childDocs, int maxChildren) throws IOException  (MultiValueMode.java)"
        }
      ],
      "comment": "\n     * Return a {@link BinaryDocValues} instance that can be used to sort root documents\n     * with this mode, the provided values and filters for root/inner documents.\n     *\n     * For every root document, the values of its inner documents will be aggregated.\n     * If none of the inner documents has a value, then <code>missingValue</code> is returned.\n     *\n     * Allowed Modes: MIN, MAX\n     *\n     * NOTE: Calling the returned instance on docs that are not root docs is illegal\n     *       The returned instance can only be evaluate the current and upcoming docs\n     ",
      "vertexLabel": "BinaryDocValues select()"
    },
    {
      "vertexName": "Method public UpdateRequestBuilder setUpsert(String source, XContentType xContentType)  (UpdateRequestBuilder.java)",
      "children": [
        {
          "name": "Method public UpdateRequest upsert(byte[] source, XContentType xContentType)  (UpdateRequest.java)"
        }
      ],
      "comment": "\n     * Sets the doc source of the update request to be used when the document does not exists.\n     ",
      "vertexLabel": "UpdateRequestBuilder setUpsert()"
    },
    {
      "vertexName": "Method public ShardRouting initialize(String nodeId, @Nullable String existingAllocationId, long expectedShardSize, RoutingChangesObserver routingChangesObserver)  (RoutingNodes.java)",
      "children": [
        {
          "name": "Method public ShardRouting initialize(String nodeId, @Nullable String existingAllocationId, long expectedShardSize)  (ShardRouting.java)"
        }
      ],
      "comment": "\n             * Initializes the current unassigned shard and moves it from the unassigned list.\n             *\n             * @param existingAllocationId allocation id to use. If null, a fresh allocation id is generated.\n             ",
      "vertexLabel": "ShardRouting initialize()"
    },
    {
      "vertexName": "Method public String index()  (SingleShardRequest.java)",
      "children": [
        {
          "name": "Field index  (SingleShardRequest.java)"
        }
      ],
      "comment": "\n     * @return The concrete index this request is targeted for or <code>null</code> if index is optional.\n     *         Whether index property is optional depends on the concrete implementation. If index property\n     *         is required the concrete implementation should use {@link #validateNonNullIndex()} to check\n     *         if the index property has been set\n     ",
      "vertexLabel": "String index()"
    },
    {
      "vertexName": "Method static long x(long d, long m, long over)  (SizeUnit.java)",
      "children": [
        {
          "name": "Method static long x(long d, long m, long over)  (ByteSizeUnit.java)"
        }
      ],
      "comment": "\n     * Scale d by m, checking for overflow.\n     * This has a short name to make above code more readable.\n     ",
      "vertexLabel": "long x()"
    },
    {
      "vertexName": "Method public PlainShardIterator(ShardId shardId, List<ShardRouting> shards)  (PlainShardIterator.java)",
      "children": [
        {
          "name": "Method public SearchShardIterator(String clusterAlias, ShardId shardId, List<ShardRouting> shards, OriginalIndices originalIndices)  (SearchShardIterator.java)"
        }
      ],
      "comment": "\n     * Creates a {@link PlainShardIterator} instance that iterates over a subset of the given shards\n     * this the a given <code>shardId</code>.\n     *\n     * @param shardId shard id of the group\n     * @param shards  shards to iterate\n     ",
      "vertexLabel": "PlainShardIterator()"
    },
    {
      "vertexName": "Method public IndexRequest source(Object... source)  (IndexRequest.java)",
      "children": [
        {
          "name": "Method public IndexRequest source(XContentType xContentType, Object... source)  (IndexRequest.java)"
        }
      ],
      "comment": "\n     * Sets the content source to index using the default content type ({@link Requests#INDEX_CONTENT_TYPE})\n     * <p>\n     * <b>Note: the number of objects passed to this method must be an even\n     * number. Also the first argument in each pair (the field name) must have a\n     * valid String representation.</b>\n     * </p>\n     ",
      "vertexLabel": "IndexRequest source()"
    },
    {
      "vertexName": "Method public static IndicesOptions strictExpandOpenAndForbidClosed()  (IndicesOptions.java)",
      "children": [
        {
          "name": "Method public static IndicesOptions strictExpandOpen()  (IndicesOptions.java)"
        }
      ],
      "comment": "\n     * @return indices options that requires every specified index to exist, expands wildcards only to open indices,\n     *         allows that no indices are resolved from wildcard expressions (not returning an error) and forbids the\n     *         use of closed indices by throwing an error.\n     ",
      "vertexLabel": "IndicesOptions strictExpandOpenAndForbidClosed()"
    },
    {
      "vertexName": "Method public BaseTermQueryBuilder(String fieldName, long value)  (BaseTermQueryBuilder.java)",
      "children": [
        {
          "name": "Method public BaseTermQueryBuilder(String fieldName, String value)  (BaseTermQueryBuilder.java)"
        }
      ],
      "comment": "\n     * Constructs a new base term query.\n     *\n     * @param fieldName  The name of the field\n     * @param value The value of the term\n     ",
      "vertexLabel": "BaseTermQueryBuilder()"
    },
    {
      "vertexName": "Method public LoggingAwareCommand(final String description)  (LoggingAwareCommand.java)",
      "children": [
        {
          "name": "Method public EnvironmentAwareCommand(final String description)  (EnvironmentAwareCommand.java)"
        }
      ],
      "comment": "\n     * Construct the command with the specified command description. This command will have logging configured without reading Elasticsearch\n     * configuration files.\n     *\n     * @param description the command description\n     ",
      "vertexLabel": "LoggingAwareCommand()"
    },
    {
      "vertexName": "Method public CreateSnapshotRequest indicesOptions(IndicesOptions indicesOptions)  (CreateSnapshotRequest.java)",
      "children": [
        {
          "name": "Method public IndicesOptions indicesOptions()  (CreateSnapshotRequest.java)"
        }
      ],
      "comment": "\n     * Specifies the indices options. Like what type of requested indices to ignore. For example indices that don't exist.\n     *\n     * @param indicesOptions the desired behaviour regarding indices options\n     * @return this request\n     ",
      "vertexLabel": "CreateSnapshotRequest indicesOptions()"
    },
    {
      "vertexName": "Method private static long longEncode(final String hash, int length)  (GeoHashUtils.java)",
      "children": [
        {
          "name": "Method public static final long longEncode(final double lon, final double lat, final int level)  (GeoHashUtils.java)"
        }
      ],
      "comment": "\n     * Encode from geohash string to the geohash based long format (lon/lat interleaved, 4 least significant bits = level)\n     ",
      "vertexLabel": "long longEncode()"
    },
    {
      "vertexName": "Method public static ConnectionProfile buildSingleChannelProfile(TransportRequestOptions.Type channelType, @Nullable TimeValue connectTimeout, @Nullable TimeValue handshakeTimeout, @Nullable Boolean compressionEnabled)  (ConnectionProfile.java)",
      "children": [
        {
          "name": "Method public static ConnectionProfile buildSingleChannelProfile(TransportRequestOptions.Type channelType, @Nullable TimeValue connectTimeout, @Nullable TimeValue handshakeTimeout)  (ConnectionProfile.java)"
        }
      ],
      "comment": "\n     * Builds a connection profile that is dedicated to a single channel type. Allows passing connection and\n     * handshake timeouts and compression settings.\n     ",
      "vertexLabel": "ConnectionProfile buildSingleChannelProfile()"
    },
    {
      "vertexName": "Method public NestedQueryBuilder ignoreUnmapped(boolean ignoreUnmapped)  (NestedQueryBuilder.java)",
      "children": [
        {
          "name": "Method public boolean ignoreUnmapped()  (NestedQueryBuilder.java)"
        }
      ],
      "comment": "\n     * Sets whether the query builder should ignore unmapped paths (and run a\n     * {@link MatchNoDocsQuery} in place of this query) or throw an exception if\n     * the path is unmapped.\n     ",
      "vertexLabel": "NestedQueryBuilder ignoreUnmapped()"
    },
    {
      "vertexName": "Method public static OverriddenModuleBuilder override(Module... modules)  (Modules.java)",
      "comment": "\n     * Returns a builder that creates a module that overlays override modules over the given\n     * modules. If a key is bound in both sets of modules, only the binding from the override modules\n     * is kept. This can be used to replace the bindings of a production module with test bindings:\n     * <pre>\n     * Module functionalTestModule\n     *     = Modules.override(new ProductionModule()).with(new TestModule());\n     * </pre>\n     * <p>\n     * Prefer to write smaller modules that can be reused and tested without overrides.\n     *\n     * @param modules the modules whose bindings are open to be overridden\n     ",
      "vertexLabel": "OverriddenModuleBuilder override()"
    },
    {
      "vertexName": "Method Query toFilter(QueryShardContext context) throws IOException  (QueryBuilder.java)",
      "children": [
        {
          "name": "Method Query toQuery(QueryShardContext context) throws IOException  (QueryBuilder.java)"
        }
      ],
      "comment": "\n     * Converts this QueryBuilder to an unscored lucene {@link Query} that acts as a filter.\n     * Returns {@code null} if this query should be ignored in the context of\n     * parent queries.\n     *\n     * @param context additional information needed to construct the queries\n     * @return the {@link Query} or {@code null} if this query should be ignored upstream\n     ",
      "vertexLabel": "Query toFilter()"
    },
    {
      "vertexName": "Method public FieldSortBuilder setNestedSort(final NestedSortBuilder nestedSort)  (FieldSortBuilder.java)",
      "children": [
        {
          "name": "Method public GeoDistanceSortBuilder setNestedFilter(QueryBuilder nestedFilter)  (GeoDistanceSortBuilder.java)"
        }
      ],
      "comment": "\n     * Sets the {@link NestedSortBuilder} to be used for fields that are inside a nested\n     * object. The {@link NestedSortBuilder} takes a `path` argument and an optional\n     * nested filter that the nested objects should match with in\n     * order to be taken into account for sorting.\n     ",
      "vertexLabel": "FieldSortBuilder setNestedSort()"
    },
    {
      "vertexName": "Method public SearchSourceBuilder scriptField(String name, Script script)  (SearchSourceBuilder.java)",
      "children": [
        {
          "name": "Method public TopHitsAggregationBuilder scriptField(String name, Script script)  (TopHitsAggregationBuilder.java)"
        }
      ],
      "comment": "\n     * Adds a script field under the given name with the provided script.\n     *\n     * @param name\n     *            The name of the field\n     * @param script\n     *            The script\n     ",
      "vertexLabel": "SearchSourceBuilder scriptField()"
    },
    {
      "vertexName": "Method public IndexRequestBuilder setSource(Object... source)  (IndexRequestBuilder.java)",
      "children": [
        {
          "name": "Method public IndexRequest source(XContentType xContentType, Object... source)  (IndexRequest.java)"
        }
      ],
      "comment": "\n     * Constructs a simple document with a field name and value pairs.\n     * <p>\n     * <b>Note: the number of objects passed to this method must be an even\n     * number. Also the first argument in each pair (the field name) must have a\n     * valid String representation.</b>\n     * </p>\n     ",
      "vertexLabel": "IndexRequestBuilder setSource()"
    },
    {
      "vertexName": "Method public UpdateRequest fetchSource(@Nullable String[] includes, @Nullable String[] excludes)  (UpdateRequest.java)",
      "children": [
        {
          "name": "Method public ExplainRequestBuilder setFetchSource(@Nullable String[] includes, @Nullable String[] excludes)  (ExplainRequestBuilder.java)"
        }
      ],
      "comment": "\n     * Indicate that _source should be returned, with an\n     * \"include\" and/or \"exclude\" set which can include simple wildcard\n     * elements.\n     *\n     * @param includes\n     *            An optional list of include (optionally wildcarded) pattern to\n     *            filter the returned _source\n     * @param excludes\n     *            An optional list of exclude (optionally wildcarded) pattern to\n     *            filter the returned _source\n     ",
      "vertexLabel": "UpdateRequest fetchSource()"
    },
    {
      "vertexName": "Method long getNumVersionLookups()  (InternalEngine.java)",
      "children": [
        {
          "name": "Method long getNumIndexVersionsLookups()  (InternalEngine.java)"
        }
      ],
      "comment": "\n     * Returns the number of times a version was looked up either from memory or from the index.\n     * Note this is only available if assertions are enabled\n     ",
      "vertexLabel": "long getNumVersionLookups()"
    },
    {
      "vertexName": "Method public Index[] concreteIndices(ClusterState state, IndicesOptions options, long startTime, String... indexExpressions)  (IndexNameExpressionResolver.java)",
      "children": [
        {
          "name": "Method public Index concreteSingleIndex(ClusterState state, IndicesRequest request)  (IndexNameExpressionResolver.java)"
        }
      ],
      "comment": "\n     * Translates the provided index expression into actual concrete indices, properly deduplicated.\n     *\n     * @param state             the cluster state containing all the data to resolve to expressions to concrete indices\n     * @param options           defines how the aliases or indices need to be resolved to concrete indices\n     * @param startTime         The start of the request where concrete indices is being invoked for\n     * @param indexExpressions  expressions that can be resolved to alias or index names.\n     * @return the resolved concrete indices based on the cluster state, indices options and index expressions\n     * provided indices options in the context don't allow such a case, or if the final result of the indices resolution\n     * contains no indices and the indices options in the context don't allow such a case.\n     * @throws IllegalArgumentException if one of the aliases resolve to multiple indices and the provided\n     * indices options in the context don't allow such a case.\n     ",
      "vertexLabel": "Index[] concreteIndices()"
    },
    {
      "vertexName": "Method public boolean autoGenerateSynonymsPhraseQuery()  (MatchQueryBuilder.java)",
      "comment": "\n     * Whether phrase queries should be automatically generated for multi terms synonyms.\n     * Defaults to {@code true}.\n     ",
      "vertexLabel": "boolean autoGenerateSynonymsPhraseQuery()"
    },
    {
      "vertexName": "Method CompoundOrderComparator(List<BucketOrder> compoundOrder, Aggregator aggregator)  (InternalOrder.java)",
      "comment": "\n             * Create a new {@code Comparator} for sorting buckets by multiple criteria.\n             *\n             * @param compoundOrder a list of {@link BucketOrder}s to sort on, in order of priority.\n             * @param aggregator    {@link BucketOrder#comparator(Aggregator)}\n             ",
      "vertexLabel": "CompoundOrderComparator()"
    },
    {
      "vertexName": "Method public long add(BytesRef key, int code)  (BytesRefHash.java)",
      "comment": "\n     * Try to add <code>key</code>. Return its newly allocated id if it wasn't in the hash table yet, or <code>-1-id</code>\n     * if it was already present in the hash table.\n     ",
      "vertexLabel": "long add()"
    },
    {
      "vertexName": "Method protected RerouteExplanation explainOrThrowRejectedCommand(boolean explain, RoutingAllocation allocation, RuntimeException rte)  (AbstractAllocateAllocationCommand.java)",
      "children": [
        {
          "name": "Method protected RerouteExplanation explainOrThrowRejectedCommand(boolean explain, RoutingAllocation allocation, String reason)  (AbstractAllocateAllocationCommand.java)"
        }
      ],
      "comment": "\n     * Utility method for rejecting the current allocation command based on provided exception\n     ",
      "vertexLabel": "RerouteExplanation explainOrThrowRejectedCommand()"
    },
    {
      "vertexName": "Method public SearchRequestBuilder addDocValueField(String name)  (SearchRequestBuilder.java)",
      "children": [
        {
          "name": "Method public SearchRequestBuilder addDocValueField(String name, String format)  (SearchRequestBuilder.java)"
        }
      ],
      "comment": "\n     * Adds a docvalue based field to load and return. The field does not have to be stored,\n     * but its recommended to use non analyzed or numeric fields.\n     *\n     * @param name The field to get from the docvalue\n     ",
      "vertexLabel": "SearchRequestBuilder addDocValueField()"
    },
    {
      "vertexName": "Method public static MapDiff<K, T, ImmutableOpenMap<K, T>> readImmutableOpenMapDiff(StreamInput in, KeySerializer<K> keySerializer, Reader<T> reader, Reader<Diff<T>> diffReader) throws IOException  (DiffableUtils.java)",
      "children": [
        {
          "name": "Method public static MapDiff<K, T, Map<K, T>> readJdkMapDiff(StreamInput in, KeySerializer<K> keySerializer, Reader<T> reader, Reader<Diff<T>> diffReader) throws IOException  (DiffableUtils.java)"
        }
      ],
      "comment": "\n     * Loads an object that represents difference between two ImmutableOpenMaps of Diffable objects using Diffable proto object\n     ",
      "vertexLabel": "MapDiff<K, T, ImmutableOpenMap<K, T>> readImmutableOpenMapDiff()"
    },
    {
      "vertexName": "Method public ClusterHealthRequest waitForActiveShards(ActiveShardCount waitForActiveShards)  (ClusterHealthRequest.java)",
      "children": [
        {
          "name": "Method public final Request waitForActiveShards(ActiveShardCount waitForActiveShards)  (ReplicationRequest.java)"
        }
      ],
      "comment": "\n     * Sets the number of shard copies that must be active across all indices before getting the\n     * health status. Defaults to {@link ActiveShardCount#NONE}, meaning we don't wait on any active shards.\n     * Set this value to {@link ActiveShardCount#ALL} to wait for all shards (primary and\n     * all replicas) to be active across all indices in the cluster. Otherwise, use\n     * {@link ActiveShardCount#from(int)} to set this value to any non-negative integer, up to the\n     * total number of shard copies to wait for.\n     ",
      "vertexLabel": "ClusterHealthRequest waitForActiveShards()"
    },
    {
      "vertexName": "Method void syncedFlush(SyncedFlushRequest request, ActionListener<SyncedFlushResponse> listener)  (IndicesAdminClient.java)",
      "children": [
        {
          "name": "Method ActionFuture<SyncedFlushResponse> syncedFlush(SyncedFlushRequest request)  (IndicesAdminClient.java)"
        },
        {
          "name": "Method void flush(FlushRequest request, ActionListener<FlushResponse> listener)  (IndicesAdminClient.java)"
        }
      ],
      "comment": "\n     * Explicitly sync flush one or more indices (write sync id to shards for faster recovery).\n     *\n     * @param request  The sync flush request\n     * @param listener A listener to be notified with a result\n     * @see org.elasticsearch.client.Requests#syncedFlushRequest(String...)\n     ",
      "vertexLabel": "void syncedFlush()"
    },
    {
      "vertexName": "Method public SnapshotShardFailure(@Nullable String nodeId, ShardId shardId, String reason)  (SnapshotShardFailure.java)",
      "comment": "\n     * Constructs new snapshot shard failure object\n     *\n     * @param nodeId  node where failure occurred\n     * @param shardId shard id\n     * @param reason  failure reason\n     ",
      "vertexLabel": "SnapshotShardFailure()"
    },
    {
      "vertexName": "Method void updateGlobalCheckpointForShard(String allocationId, long globalCheckpoint)  (ReplicationOperation.java)",
      "children": [
        {
          "name": "Method public synchronized void updateGlobalCheckpointForShard(final String allocationId, final long globalCheckpoint)  (ReplicationTracker.java)"
        }
      ],
      "comment": "\n         * Update the local knowledge of the global checkpoint for the specified allocation ID.\n         *\n         * @param allocationId     the allocation ID to update the global checkpoint for\n         * @param globalCheckpoint the global checkpoint\n         ",
      "vertexLabel": "void updateGlobalCheckpointForShard()"
    },
    {
      "vertexName": "Method public void appendFieldValue(String path, Object value)  (IngestDocument.java)",
      "children": [
        {
          "name": "Method public void setFieldValue(String path, Object value)  (IngestDocument.java)"
        }
      ],
      "comment": "\n     * Appends the provided value to the provided path in the document.\n     * Any non existing path element will be created.\n     * If the path identifies a list, the value will be appended to the existing list.\n     * If the path identifies a scalar, the scalar will be converted to a list and\n     * the provided value will be added to the newly created list.\n     * Supports multiple values too provided in forms of list, in that case all the values will be appended to the\n     * existing (or newly created) list.\n     * @param path The path within the document in dot-notation\n     * @param value The value or values to append to the existing ones\n     * @throws IllegalArgumentException if the path is null, empty or invalid.\n     ",
      "vertexLabel": "void appendFieldValue()"
    },
    {
      "vertexName": "Interface Filters  (Filters.java)",
      "comment": "\n * A multi bucket aggregation where the buckets are defined by a set of filters (a bucket per filter). Each bucket\n * will collect all documents matching its filter.\n ",
      "vertexLabel": "Interface Filters"
    },
    {
      "vertexName": "Method public static PlainListenableActionFuture<T> newDispatchingListenableFuture(ThreadPool threadPool)  (PlainListenableActionFuture.java)",
      "children": [
        {
          "name": "Method public static PlainListenableActionFuture<T> newListenableFuture()  (PlainListenableActionFuture.java)"
        }
      ],
      "comment": "\n     * This method returns a listenable future. The listeners will be called on completion of the future.\n     * The listeners will be executed on the LISTENER thread pool.\n     * @param threadPool the thread pool used to execute listeners\n     * @param <T> the result of the future\n     * @return a listenable future\n     ",
      "vertexLabel": "PlainListenableActionFuture<T> newDispatchingListenableFuture()"
    },
    {
      "vertexName": "Method public XContentBuilder toXContent(XContentBuilder builder, Params builderParams) throws IOException  (Script.java)",
      "comment": "\n     * This will build scripts into the following XContent structure:\n     *\n     * {@code\n     * {\n     *     \"<(id, source)>\" : \"<idOrCode>\",\n     *     \"lang\" : \"<lang>\",\n     *     \"options\" : {\n     *         \"option0\" : \"<option0>\",\n     *         \"option1\" : \"<option1>\",\n     *         ...\n     *     },\n     *     \"params\" : {\n     *         \"param0\" : \"<param0>\",\n     *         \"param1\" : \"<param1>\",\n     *         ...\n     *     }\n     * }\n     * }\n     *\n     * Example:\n     * {@code\n     * {\n     *     \"source\" : \"return Math.log(doc.popularity) * params.multiplier;\",\n     *     \"lang\" : \"painless\",\n     *     \"params\" : {\n     *         \"multiplier\" : 100.0\n     *     }\n     * }\n     * }\n     *\n     * Note that lang, options, and params will only be included if there have been any specified.\n     *\n     * This also handles templates in a special way.  If the {@link Script#CONTENT_TYPE_OPTION} option\n     * is provided and the {@link ScriptType#INLINE} is specified then the template will be preserved as a raw field.\n     *\n     * {@code\n     * {\n     *     \"source\" : { \"query\" : ... },\n     *     \"lang\" : \"<lang>\",\n     *     \"options\" : {\n     *         \"option0\" : \"<option0>\",\n     *         \"option1\" : \"<option1>\",\n     *         ...\n     *     },\n     *     \"params\" : {\n     *         \"param0\" : \"<param0>\",\n     *         \"param1\" : \"<param1>\",\n     *         ...\n     *     }\n     * }\n     * }\n     ",
      "vertexLabel": "XContentBuilder toXContent()"
    },
    {
      "vertexName": "Method public void unregisterRepository(final UnregisterRepositoryRequest request, final ActionListener<ClusterStateUpdateResponse> listener)  (RepositoriesService.java)",
      "comment": "\n     * Unregisters repository in the cluster\n     * <p>\n     * This method can be only called on the master node. It removes repository information from cluster metadata.\n     *\n     * @param request  unregister repository request\n     * @param listener unregister repository listener\n     ",
      "vertexLabel": "void unregisterRepository()"
    },
    {
      "vertexName": "Interface TypeEncounter  (TypeEncounter.java)",
      "comment": "\n * Context of an injectable type encounter. Enables reporting errors, registering injection\n * listeners and binding method interceptors for injectable type {@code I}. It is an error to use\n * an encounter after the {@link TypeListener#hear(TypeLiteral, TypeEncounter) hear()} method has\n * returned.\n *\n * @param <I> the injectable type encountered\n * @since 2.0\n ",
      "vertexLabel": "Interface TypeEncounter"
    },
    {
      "vertexName": "Method public UpdateSettingsRequest setPreserveExisting(boolean preserveExisting)  (UpdateSettingsRequest.java)",
      "children": [
        {
          "name": "Method public UpdateSettingsClusterStateUpdateRequest setPreserveExisting(boolean preserveExisting)  (UpdateSettingsClusterStateUpdateRequest.java)"
        }
      ],
      "comment": "\n     * Iff set to <code>true</code> this settings update will only add settings not already set on an index. Existing settings remain\n     * unchanged.\n     ",
      "vertexLabel": "UpdateSettingsRequest setPreserveExisting()"
    },
    {
      "vertexName": "Method public static WrapperQueryBuilder wrapperQuery(BytesReference source)  (QueryBuilders.java)",
      "children": [
        {
          "name": "Method public static WrapperQueryBuilder wrapperQuery(String source)  (QueryBuilders.java)"
        }
      ],
      "comment": "\n     * A Query builder which allows building a query thanks to a JSON string or binary data.\n     ",
      "vertexLabel": "WrapperQueryBuilder wrapperQuery()"
    },
    {
      "vertexName": "Method void deleteBlob(String blobName) throws IOException  (BlobContainer.java)",
      "children": [
        {
          "name": "Method void deleteBlobIgnoringIfNotExists(String blobName) throws IOException  (BlobContainer.java)"
        },
        {
          "name": "Method InputStream readBlob(String blobName) throws IOException  (BlobContainer.java)"
        }
      ],
      "comment": "\n     * Deletes a blob with giving name, if the blob exists. If the blob does not exist,\n     * this method throws a NoSuchFileException.\n     *\n     * @param   blobName\n     *          The name of the blob to delete.\n     * @throws  NoSuchFileException if the blob does not exist\n     * @throws  IOException if the blob exists but could not be deleted.\n     ",
      "vertexLabel": "void deleteBlob()"
    },
    {
      "vertexName": "Class BigIntArray  (BigIntArray.java)",
      "comment": "\n * Int array abstraction able to support more than 2B values. This implementation slices data into fixed-sized blocks of\n * configurable length.\n ",
      "vertexLabel": "Class BigIntArray"
    },
    {
      "vertexName": "Method public static GeoShapeQueryBuilder geoDisjointQuery(String name, ShapeBuilder shape) throws IOException  (QueryBuilders.java)",
      "children": [
        {
          "name": "Method public static GeoShapeQueryBuilder geoIntersectionQuery(String name, ShapeBuilder shape) throws IOException  (QueryBuilders.java)"
        }
      ],
      "comment": "\n     * A filter to filter indexed shapes that are not intersection with the query shape\n     *\n     * @param name  The shape field name\n     * @param shape Shape to use in the filter\n     ",
      "vertexLabel": "GeoShapeQueryBuilder geoDisjointQuery()"
    },
    {
      "vertexName": "Method public Builder put(String setting, double value)  (Settings.java)",
      "children": [
        {
          "name": "Method public Builder put(String setting, int value)  (Settings.java)"
        }
      ],
      "comment": "\n         * Sets the setting with the provided setting key and the double value.\n         *\n         * @param setting The setting key\n         * @param value   The double value\n         * @return The builder\n         ",
      "vertexLabel": "Builder put()"
    },
    {
      "vertexName": "Method public RolloverRequestBuilder waitForActiveShards(final int waitForActiveShards)  (RolloverRequestBuilder.java)",
      "children": [
        {
          "name": "Method public CreateIndexRequest waitForActiveShards(final int waitForActiveShards)  (CreateIndexRequest.java)"
        }
      ],
      "comment": "\n     * A shortcut for {@link #waitForActiveShards(ActiveShardCount)} where the numerical\n     * shard count is passed in, instead of having to first call {@link ActiveShardCount#from(int)}\n     * to get the ActiveShardCount.\n     ",
      "vertexLabel": "RolloverRequestBuilder waitForActiveShards()"
    },
    {
      "vertexName": "Method private void deleteSnapshotFromRepository(final Snapshot snapshot, @Nullable final DeleteSnapshotListener listener, long repositoryStateId)  (SnapshotsService.java)",
      "comment": "\n     * Deletes snapshot from repository\n     *\n     * @param snapshot   snapshot\n     * @param listener   listener\n     * @param repositoryStateId the unique id representing the state of the repository at the time the deletion began\n     ",
      "vertexLabel": "void deleteSnapshotFromRepository()"
    },
    {
      "vertexName": "Method public Index[] concreteIndices(ClusterState state, IndicesRequest request)  (IndexNameExpressionResolver.java)",
      "comment": "\n     * Same as {@link #concreteIndices(ClusterState, IndicesOptions, String...)}, but the index expressions and options\n     * are encapsulated in the specified request.\n     ",
      "vertexLabel": "Index[] concreteIndices()"
    },
    {
      "vertexName": "Class ScopeBinding  (ScopeBinding.java)",
      "children": [
        {
          "name": "Class TypeConverterBinding  (TypeConverterBinding.java)"
        }
      ],
      "comment": "\n * Registration of a scope annotation with the scope that implements it. Instances are created\n * explicitly in a module using {@link org.elasticsearch.common.inject.Binder#bindScope(Class, Scope) bindScope()}\n * statements:\n * <pre>\n *     Scope recordScope = new RecordScope();\n *     bindScope(RecordScoped.class, new RecordScope());</pre>\n *\n * @author jessewilson@google.com (Jesse Wilson)\n * @since 2.0\n ",
      "vertexLabel": "Class ScopeBinding"
    },
    {
      "vertexName": "Method Object format(BytesRef value)  (DocValueFormat.java)",
      "comment": " Format a binary value. This is used by terms aggregations to format\n     *  keys for fields that use binary doc value representations such as the\n     *  {@code keyword} and {@code ip} fields. ",
      "vertexLabel": "Object format()"
    },
    {
      "vertexName": "Method public static TermsQueryBuilder termsQuery(String name, Object... values)  (QueryBuilders.java)",
      "children": [
        {
          "name": "Method public static TermsQueryBuilder termsQuery(String name, String... values)  (QueryBuilders.java)"
        }
      ],
      "comment": "\n     * A filer for a field based on several terms matching on any of them.\n     *\n     * @param name   The field name\n     * @param values The terms\n     ",
      "vertexLabel": "TermsQueryBuilder termsQuery()"
    },
    {
      "vertexName": "Method void updateLocalCheckpointForShard(String allocationId, long checkpoint)  (ReplicationOperation.java)",
      "children": [
        {
          "name": "Method public synchronized void markAllocationIdAsInSync(final String allocationId, final long localCheckpoint) throws InterruptedException  (ReplicationTracker.java)"
        }
      ],
      "comment": "\n         * Notifies the primary of a local checkpoint for the given allocation.\n         *\n         * Note: The primary will use this information to advance the global checkpoint if possible.\n         *\n         * @param allocationId allocation ID of the shard corresponding to the supplied local checkpoint\n         * @param checkpoint the *local* checkpoint for the shard\n         ",
      "vertexLabel": "void updateLocalCheckpointForShard()"
    },
    {
      "vertexName": "Interface ElementVisitor  (ElementVisitor.java)",
      "comment": "\n * Visit elements.\n *\n * @param <V> any type to be returned by the visit method. Use {@link Void} with\n *            {@code return null} if no return type is needed.\n * @since 2.0\n ",
      "vertexLabel": "Interface ElementVisitor"
    },
    {
      "vertexName": "Method public void deleteUnassignedIndex(String reason, IndexMetaData metaData, ClusterState clusterState)  (IndicesService.java)",
      "comment": "\n     * Deletes an index that is not assigned to this node. This method cleans up all disk folders relating to the index\n     * but does not deal with in-memory structures. For those call {@link #removeIndex(Index, IndexRemovalReason, String)}\n     ",
      "vertexLabel": "void deleteUnassignedIndex()"
    },
    {
      "vertexName": "Method public PutIndexTemplateRequestBuilder addMapping(String type, Map<String, Object> source)  (PutIndexTemplateRequestBuilder.java)",
      "children": [
        {
          "name": "Method public CreateIndexRequest mapping(String type, XContentBuilder source)  (CreateIndexRequest.java)"
        }
      ],
      "comment": "\n     * Adds mapping that will be added when the index gets created.\n     *\n     * @param type   The mapping type\n     * @param source The mapping source\n     ",
      "vertexLabel": "PutIndexTemplateRequestBuilder addMapping()"
    },
    {
      "vertexName": "Method public GeoBoundingBoxQueryBuilder setCorners(String topLeft, String bottomRight)  (GeoBoundingBoxQueryBuilder.java)",
      "children": [
        {
          "name": "Method public GeoBoundingBoxQueryBuilder setCorners(GeoPoint topLeft, GeoPoint bottomRight)  (GeoBoundingBoxQueryBuilder.java)"
        }
      ],
      "comment": "\n     * Adds points.\n     * @param topLeft topLeft point to add as geohash.\n     * @param bottomRight bottomRight point to add as geohash.\n     * ",
      "vertexLabel": "GeoBoundingBoxQueryBuilder setCorners()"
    },
    {
      "vertexName": "Method public Weight[] getWeights()  (FiltersAggregatorFactory.java)",
      "children": [
        {
          "name": "Method public Weight getWeight()  (FilterAggregatorFactory.java)"
        }
      ],
      "comment": "\n     * Returns the {@link Weight}s for this filter aggregation, creating it if\n     * necessary. This is done lazily so that the {@link Weight}s are only\n     * created if the aggregation collects documents reducing the overhead of\n     * the aggregation in the case where no documents are collected.\n     * \n     * Note that as aggregations are initialsed and executed in a serial manner,\n     * no concurrency considerations are necessary here.\n     ",
      "vertexLabel": "Weight[] getWeights()"
    },
    {
      "vertexName": "Method public static boolean canOpenIndex(Logger logger, Path indexLocation, ShardId shardId, NodeEnvironment.ShardLocker shardLocker) throws IOException  (Store.java)",
      "children": [
        {
          "name": "Method public static void tryOpenIndex(Path indexLocation, ShardId shardId, NodeEnvironment.ShardLocker shardLocker, Logger logger) throws IOException, ShardLockObtainFailedException  (Store.java)"
        }
      ],
      "comment": "\n     * Returns <code>true</code> iff the given location contains an index an the index\n     * can be successfully opened. This includes reading the segment infos and possible\n     * corruption markers.\n     ",
      "vertexLabel": "boolean canOpenIndex()"
    },
    {
      "vertexName": "Method public int window()  (MovAvgPipelineAggregationBuilder.java)",
      "comment": "\n     * Gets the window size for the moving average. This window will \"slide\"\n     * across the series, and the values inside that window will be used to\n     * calculate the moving avg value\n     ",
      "vertexLabel": "int window()"
    },
    {
      "vertexName": "Method public RangeAggregationBuilder addUnboundedTo(String key, double to)  (RangeAggregationBuilder.java)",
      "children": [
        {
          "name": "Method public GeoDistanceAggregationBuilder addUnboundedTo(String key, double to)  (GeoDistanceAggregationBuilder.java)"
        }
      ],
      "comment": "\n     * Add a new range with no lower bound.\n     *\n     * @param key\n     *            the key to use for this range in the response\n     * @param to\n     *            the upper bound on the distances, exclusive\n     ",
      "vertexLabel": "RangeAggregationBuilder addUnboundedTo()"
    },
    {
      "vertexName": "Method public ClusterHealthRequestBuilder setWaitForNodes(String waitForNodes)  (ClusterHealthRequestBuilder.java)",
      "children": [
        {
          "name": "Method public ClusterHealthRequest waitForNodes(String waitForNodes)  (ClusterHealthRequest.java)"
        }
      ],
      "comment": "\n     * Waits for N number of nodes. Use \"12\" for exact mapping, \"&gt;12\" and \"&lt;12\" for range.\n     ",
      "vertexLabel": "ClusterHealthRequestBuilder setWaitForNodes()"
    },
    {
      "vertexName": "Method public FuzzyQueryBuilder(String fieldName, Object value)  (FuzzyQueryBuilder.java)",
      "children": [
        {
          "name": "Method public FuzzyQueryBuilder(String fieldName, String value)  (FuzzyQueryBuilder.java)"
        }
      ],
      "comment": "\n     * Constructs a new fuzzy query.\n     *\n     * @param fieldName  The name of the field\n     * @param value The value of the term\n     ",
      "vertexLabel": "FuzzyQueryBuilder()"
    },
    {
      "vertexName": "Method public Builder precision(double precision, DistanceUnit unit)  (GeoContextMapping.java)",
      "children": [
        {
          "name": "Method public Builder precision(String precision)  (GeoContextMapping.java)"
        }
      ],
      "comment": "\n         * Set the precision use o make suggestions\n         *\n         * @param precision\n         *            precision value\n         * @param unit\n         *            {@link DistanceUnit} to use\n         * @return this\n         ",
      "vertexLabel": "Builder precision()"
    },
    {
      "vertexName": "Method private void setSource(XContentParser parser)  (StoredScriptSource.java)",
      "children": [
        {
          "name": "Method private void setInline(XContentParser parser)  (Script.java)"
        }
      ],
      "comment": "\n         * Since stored scripts can accept templates rather than just scripts, they must also be able\n         * to handle template parsing, hence the need for custom parsing source.  Templates can\n         * consist of either an {@link String} or a JSON object.  If a JSON object is discovered\n         * then the content type option must also be saved as a compiler option.\n         ",
      "vertexLabel": "void setSource()"
    },
    {
      "vertexName": "Method protected abstract WritePrimaryResult<ReplicaRequest, Response> shardOperationOnPrimary(Request request, IndexShard primary) throws Exception  (TransportWriteAction.java)",
      "comment": "\n     * Called on the primary with a reference to the primary {@linkplain IndexShard} to modify.\n     *\n     * @return the result of the operation on primary, including current translog location and operation response and failure\n     * async refresh is performed on the <code>primary</code> shard according to the <code>Request</code> refresh policy\n     ",
      "vertexLabel": "abstract WritePrimaryResult<ReplicaRequest, Response> shardOperationOnPrimary()"
    },
    {
      "vertexName": "Method public static void writeRawField(String field, BytesReference source, XContentType xContentType, XContentBuilder builder, ToXContent.Params params) throws IOException  (XContentHelper.java)",
      "comment": "\n     * Writes a \"raw\" (bytes) field, handling cases where the bytes are compressed, and tries to optimize writing using\n     * {@link XContentBuilder#rawField(String, InputStream, XContentType)}.\n     ",
      "vertexLabel": "void writeRawField()"
    },
    {
      "vertexName": "Method V visit(Binding<T> binding)  (ElementVisitor.java)",
      "comment": "\n     * Visit a mapping from a key (type and optional annotation) to the strategy for getting\n     * instances of the type.\n     ",
      "vertexLabel": "V visit()"
    },
    {
      "vertexName": "Method public SortMode sortMode()  (FieldSortBuilder.java)",
      "comment": "\n     * Returns what values to pick in the case a document contains multiple\n     * values for the targeted sort field.\n     ",
      "vertexLabel": "SortMode sortMode()"
    },
    {
      "vertexName": "Method public static GetRequest getRequest(String index)  (Requests.java)",
      "children": [
        {
          "name": "Method public static DeleteRequest deleteRequest(String index)  (Requests.java)"
        }
      ],
      "comment": "\n     * Creates a get request to get the JSON source from an index based on a type and id. Note, the\n     * {@link GetRequest#type(String)} and {@link GetRequest#id(String)} must be set.\n     *\n     * @param index The index to get the JSON source from\n     * @return The get request\n     * @see org.elasticsearch.client.Client#get(org.elasticsearch.action.get.GetRequest)\n     ",
      "vertexLabel": "GetRequest getRequest()"
    },
    {
      "vertexName": "Method public TransportClient addTransportAddresses(TransportAddress... transportAddress)  (TransportClient.java)",
      "children": [
        {
          "name": "Method public TransportClient addTransportAddress(TransportAddress transportAddress)  (TransportClient.java)"
        }
      ],
      "comment": "\n     * Adds a list of transport addresses that will be used to connect to.\n     * <p>\n     * The Node this transport address represents will be used if its possible to connect to it.\n     * If it is unavailable, it will be automatically connected to once it is up.\n     * <p>\n     * In order to get the list of all the current connected nodes, please see {@link #connectedNodes()}.\n     ",
      "vertexLabel": "TransportClient addTransportAddresses()"
    },
    {
      "vertexName": "Method public MultiSearchRequest add(SearchRequestBuilder request)  (MultiSearchRequest.java)",
      "comment": "\n     * Add a search request to execute. Note, the order is important, the search response will be returned in the\n     * same order as the search requests.\n     ",
      "vertexLabel": "MultiSearchRequest add()"
    },
    {
      "vertexName": "Method public void setFieldValue(String path, Object value)  (IngestDocument.java)",
      "children": [
        {
          "name": "Method public void setFieldValue(TemplateScript.Factory fieldPathTemplate, ValueSource valueSource)  (IngestDocument.java)"
        }
      ],
      "comment": "\n     * Sets the provided value to the provided path in the document.\n     * Any non existing path element will be created.\n     * If the last item in the path is a list, the value will replace the existing list as a whole.\n     * Use {@link #appendFieldValue(String, Object)} to append values to lists instead.\n     * @param path The path within the document in dot-notation\n     * @param value The value to put in for the path key\n     * @throws IllegalArgumentException if the path is null, empty, invalid or if the value cannot be set to the\n     * item identified by the provided path.\n     ",
      "vertexLabel": "void setFieldValue()"
    },
    {
      "vertexName": "Method public SearchRequestBuilder setAllowPartialSearchResults(boolean allowPartialSearchResults)  (SearchRequestBuilder.java)",
      "children": [
        {
          "name": "Method public SearchRequest allowPartialSearchResults(boolean allowPartialSearchResults)  (SearchRequest.java)"
        }
      ],
      "comment": "\n     * Sets if this request should allow partial results.  (If method is not called,\n     * will default to the cluster level setting).\n     ",
      "vertexLabel": "SearchRequestBuilder setAllowPartialSearchResults()"
    },
    {
      "vertexName": "Method void nodesStats(NodesStatsRequest request, ActionListener<NodesStatsResponse> listener)  (ClusterAdminClient.java)",
      "children": [
        {
          "name": "Method void nodesInfo(NodesInfoRequest request, ActionListener<NodesInfoResponse> listener)  (ClusterAdminClient.java)"
        }
      ],
      "comment": "\n     * Nodes stats of the cluster.\n     *\n     * @param request  The nodes info request\n     * @param listener A listener to be notified with a result\n     * @see org.elasticsearch.client.Requests#nodesStatsRequest(String...)\n     ",
      "vertexLabel": "void nodesStats()"
    },
    {
      "vertexName": "Method public void incomingRequestError(final HttpRequest httpRequest, final HttpChannel httpChannel, final Exception exception)  (AbstractHttpServerTransport.java)",
      "children": [
        {
          "name": "Method public void incomingRequest(final HttpRequest httpRequest, final HttpChannel httpChannel)  (AbstractHttpServerTransport.java)"
        }
      ],
      "comment": "\n     * This method handles an incoming http request that has encountered an error.\n     *\n     * @param httpRequest that is incoming\n     * @param httpChannel that received the http request\n     * @param exception   that was encountered\n     ",
      "vertexLabel": "void incomingRequestError()"
    },
    {
      "vertexName": "Method IndexingStats stats(boolean isThrottled, long currentThrottleInMillis, String... types)  (InternalIndexingStats.java)",
      "comment": "\n     * Returns the stats, including type specific stats. If the types are null/0 length, then nothing\n     * is returned for them. If they are set, then only types provided will be returned, or\n     * {@code _all} for all types.\n     ",
      "vertexLabel": "IndexingStats stats()"
    },
    {
      "vertexName": "Method public CreateIndexRequest waitForActiveShards(ActiveShardCount waitForActiveShards)  (CreateIndexRequest.java)",
      "children": [
        {
          "name": "Method public final Request waitForActiveShards(ActiveShardCount waitForActiveShards)  (ReplicationRequest.java)"
        }
      ],
      "comment": "\n     * Sets the number of shard copies that should be active for index creation to return.\n     * Defaults to {@link ActiveShardCount#DEFAULT}, which will wait for one shard copy\n     * (the primary) to become active. Set this value to {@link ActiveShardCount#ALL} to\n     * wait for all shards (primary and all replicas) to be active before returning.\n     * Otherwise, use {@link ActiveShardCount#from(int)} to set this value to any\n     * non-negative integer, up to the number of copies per shard (number of replicas + 1),\n     * to wait for the desired amount of shard copies to become active before returning.\n     * Index creation will only wait up until the timeout value for the number of shard copies\n     * to be active before returning.  Check {@link CreateIndexResponse#isShardsAcknowledged()} to\n     * determine if the requisite shard copies were all started before returning or timing out.\n     *\n     * @param waitForActiveShards number of active shard copies to wait on\n     ",
      "vertexLabel": "CreateIndexRequest waitForActiveShards()"
    },
    {
      "vertexName": "Method void shardStores(IndicesShardStoresRequest request, ActionListener<IndicesShardStoresResponse> listener)  (IndicesAdminClient.java)",
      "children": [
        {
          "name": "Method ActionFuture<IndicesShardStoresResponse> shardStores(IndicesShardStoresRequest request)  (IndicesAdminClient.java)"
        }
      ],
      "comment": "\n     * The shard stores info of one or more indices.\n     *\n     * @param request The indices shard stores request\n     * @param listener A listener to be notified with a result\n     * @see Requests#indicesShardStoresRequest(String...)\n     ",
      "vertexLabel": "void shardStores()"
    },
    {
      "vertexName": "Method public UpdateRequest routing(String routing)  (UpdateRequest.java)",
      "children": [
        {
          "name": "Method public GetRequest routing(String routing)  (GetRequest.java)"
        }
      ],
      "comment": "\n     * Controls the shard routing of the request. Using this value to hash the shard\n     * and not the id.\n     ",
      "vertexLabel": "UpdateRequest routing()"
    },
    {
      "vertexName": "Method ActionFuture<BulkResponse> bulk(BulkRequest request)  (Client.java)",
      "comment": "\n     * Executes a bulk of index / delete operations.\n     *\n     * @param request The bulk request\n     * @return The result future\n     * @see org.elasticsearch.client.Requests#bulkRequest()\n     ",
      "vertexLabel": "ActionFuture<BulkResponse> bulk()"
    },
    {
      "vertexName": "Method public static ShardPath loadShardPath(Logger logger, ShardId shardId, IndexSettings indexSettings, Path[] availableShardPaths, int nodeLockId, Path sharedDataPath) throws IOException  (ShardPath.java)",
      "children": [
        {
          "name": "Method public static ShardPath loadShardPath(Logger logger, NodeEnvironment env, ShardId shardId, IndexSettings indexSettings) throws IOException  (ShardPath.java)"
        }
      ],
      "comment": "\n     * This method walks through the nodes shard paths to find the data and state path for the given shard. If multiple\n     * directories with a valid shard state exist the one with the highest version will be used.\n     * <b>Note:</b> this method resolves custom data locations for the shard.\n     ",
      "vertexLabel": "ShardPath loadShardPath()"
    },
    {
      "vertexName": "Method public boolean autoGenerateSynonymsPhraseQuery()  (QueryStringQueryBuilder.java)",
      "children": [
        {
          "name": "Method public boolean autoGenerateSynonymsPhraseQuery()  (MatchQueryBuilder.java)"
        }
      ],
      "comment": "\n     * Whether phrase queries should be automatically generated for multi terms synonyms.\n     * Defaults to {@code true}.\n     ",
      "vertexLabel": "boolean autoGenerateSynonymsPhraseQuery()"
    },
    {
      "vertexName": "Method public void write(char[] cbuf, int off, int len) throws IOException  (UTF8StreamWriter.java)",
      "children": [
        {
          "name": "Method public void write(String str, int off, int len) throws IOException  (UTF8StreamWriter.java)"
        }
      ],
      "comment": "\n     * Writes a portion of an array of characters.\n     *\n     * @param cbuf the array of characters.\n     * @param off  the offset from which to start writing characters.\n     * @param len  the number of characters to write.\n     * @throws IOException if an I/O error occurs.\n     ",
      "vertexLabel": "void write()"
    },
    {
      "vertexName": "Method public UpdateRequestBuilder setUpsert(byte[] source, int offset, int length, XContentType xContentType)  (UpdateRequestBuilder.java)",
      "children": [
        {
          "name": "Method public UpdateRequest upsert(byte[] source, XContentType xContentType)  (UpdateRequest.java)"
        }
      ],
      "comment": "\n     * Sets the doc source of the update request to be used when the document does not exists.\n     ",
      "vertexLabel": "UpdateRequestBuilder setUpsert()"
    },
    {
      "vertexName": "Method public PlainActionFuture<BulkResponse> withBackoff(BiConsumer<BulkRequest, ActionListener<BulkResponse>> consumer, BulkRequest bulkRequest)  (Retry.java)",
      "comment": "\n     * Invokes #accept(BulkRequest, ActionListener). Backs off on the provided exception. Retries will be scheduled using\n     * the class's thread pool.\n     *\n     * @param consumer The consumer to which apply the request and listener\n     * @param bulkRequest The bulk request that should be executed.\n     * @return a future representing the bulk response returned by the client.\n     ",
      "vertexLabel": "PlainActionFuture<BulkResponse> withBackoff()"
    },
    {
      "vertexName": "Method public MapperService newIndexMapperService(NamedXContentRegistry xContentRegistry, MapperRegistry mapperRegistry, ScriptService scriptService) throws IOException  (IndexModule.java)",
      "comment": "\n     * creates a new mapper service to do administrative work like mapping updates. This *should not* be used for document parsing.\n     * doing so will result in an exception.\n     ",
      "vertexLabel": "MapperService newIndexMapperService()"
    },
    {
      "vertexName": "Method public UnassignedInfo(Reason reason, String message)  (UnassignedInfo.java)",
      "comment": "\n     * creates an UnassignedInfo object based on **current** time\n     *\n     * @param reason  the cause for making this shard unassigned. See {@link Reason} for more information.\n     * @param message more information about cause.\n     *",
      "vertexLabel": "UnassignedInfo()"
    },
    {
      "vertexName": "Method Object format(long value)  (DocValueFormat.java)",
      "children": [
        {
          "name": "Method Object format(BytesRef value)  (DocValueFormat.java)"
        }
      ],
      "comment": " Format a long value. This is used by terms and histogram aggregations\n     *  to format keys for fields that use longs as a doc value representation\n     *  such as the {@code long} and {@code date} fields. ",
      "vertexLabel": "Object format()"
    },
    {
      "vertexName": "Method public GeoBoundingBoxQueryBuilder ignoreUnmapped(boolean ignoreUnmapped)  (GeoBoundingBoxQueryBuilder.java)",
      "children": [
        {
          "name": "Method public boolean ignoreUnmapped()  (GeoBoundingBoxQueryBuilder.java)"
        }
      ],
      "comment": "\n     * Sets whether the query builder should ignore unmapped fields (and run a\n     * {@link MatchNoDocsQuery} in place of this query) or throw an exception if\n     * the field is unmapped.\n     ",
      "vertexLabel": "GeoBoundingBoxQueryBuilder ignoreUnmapped()"
    },
    {
      "vertexName": "Method public int getSize()  (AbstractBulkByScrollRequest.java)",
      "children": [
        {
          "name": "Field size  (AbstractBulkByScrollRequest.java)"
        }
      ],
      "comment": "\n     * Maximum number of processed documents. Defaults to -1 meaning process all\n     * documents.\n     ",
      "vertexLabel": "int getSize()"
    },
    {
      "vertexName": "Method public static BackoffPolicy exponentialBackoff()  (BackoffPolicy.java)",
      "comment": "\n     * Creates an new exponential backoff policy with a default configuration of 50 ms initial wait period and 8 retries taking\n     * roughly 5.1 seconds in total.\n     *\n     * @return A backoff policy with an exponential increase in wait time for retries. The returned instance is thread safe but each\n     * iterator created from it should only be used by a single thread.\n     ",
      "vertexLabel": "BackoffPolicy exponentialBackoff()"
    },
    {
      "vertexName": "Method IndexRequestBuilder prepareIndex(String index, String type, @Nullable String id)  (Client.java)",
      "children": [
        {
          "name": "Method IndexRequestBuilder prepareIndex(String index, String type)  (Client.java)"
        },
        {
          "name": "Method public DeleteRequest(String index, String type, String id)  (DeleteRequest.java)"
        }
      ],
      "comment": "\n     * Index a document associated with a given index and type.\n     * <p>\n     * The id is optional, if it is not provided, one will be generated automatically.\n     *\n     * @param index The index to index the document to\n     * @param type  The type to index the document to\n     * @param id    The id of the document\n     ",
      "vertexLabel": "IndexRequestBuilder prepareIndex()"
    },
    {
      "vertexName": "Method public static boolean isKeyDesc(BucketOrder order)  (InternalOrder.java)",
      "children": [
        {
          "name": "Method public static boolean isKeyAsc(BucketOrder order)  (InternalOrder.java)"
        }
      ],
      "comment": "\n     * Determine if the ordering strategy is sorting on bucket key descending.\n     *\n     * @param order bucket ordering strategy to check.\n     * @return {@code true} if the ordering strategy is sorting on bucket key descending, {@code false} otherwise.\n     ",
      "vertexLabel": "boolean isKeyDesc()"
    },
    {
      "vertexName": "Method void aliasesExist(GetAliasesRequest request, ActionListener<AliasesExistResponse> listener)  (IndicesAdminClient.java)",
      "children": [
        {
          "name": "Method void getIndex(GetIndexRequest request, ActionListener<GetIndexResponse> listener)  (IndicesAdminClient.java)"
        }
      ],
      "comment": "\n     * Check the existence of specified index aliases.\n     *\n     * @param request  The index aliases request\n     * @param listener A listener to be notified with a result\n     ",
      "vertexLabel": "void aliasesExist()"
    },
    {
      "vertexName": "Method public void writeBytes(byte[] b, int length) throws IOException  (StreamOutput.java)",
      "comment": "\n     * Writes an array of bytes.\n     *\n     * @param b      the bytes to write\n     * @param length the number of bytes to write\n     ",
      "vertexLabel": "void writeBytes()"
    },
    {
      "vertexName": "Method ActionFuture<ClearIndicesCacheResponse> clearCache(ClearIndicesCacheRequest request)  (IndicesAdminClient.java)",
      "comment": "\n     * Clear indices cache.\n     *\n     * @param request The clear indices cache request\n     * @return The result future\n     * @see Requests#clearIndicesCacheRequest(String...)\n     ",
      "vertexLabel": "ActionFuture<ClearIndicesCacheResponse> clearCache()"
    },
    {
      "vertexName": "Method public OpenIndexRequestBuilder setWaitForActiveShards(final int waitForActiveShards)  (OpenIndexRequestBuilder.java)",
      "children": [
        {
          "name": "Method public BulkRequest waitForActiveShards(final int waitForActiveShards)  (BulkRequest.java)"
        }
      ],
      "comment": "\n     * A shortcut for {@link #setWaitForActiveShards(ActiveShardCount)} where the numerical\n     * shard count is passed in, instead of having to first call {@link ActiveShardCount#from(int)}\n     * to get the ActiveShardCount.\n     ",
      "vertexLabel": "OpenIndexRequestBuilder setWaitForActiveShards()"
    },
    {
      "vertexName": "Method public StopWatch(String id)  (StopWatch.java)",
      "children": [
        {
          "name": "Field id  (StopWatch.java)"
        }
      ],
      "comment": "\n     * Construct a new stop watch with the given id.\n     * Does not start any task.\n     *\n     * @param id identifier for this stop watch.\n     *           Handy when we have output from multiple stop watches\n     *           and need to distinguish between them.\n     ",
      "vertexLabel": "StopWatch()"
    },
    {
      "vertexName": "Method public void addSearchOperationListener(SearchOperationListener listener)  (IndexModule.java)",
      "children": [
        {
          "name": "Method public void addIndexEventListener(IndexEventListener listener)  (IndexModule.java)"
        }
      ],
      "comment": "\n     * Adds an {@link SearchOperationListener} for this index. All listeners added here\n     * are maintained for the entire index lifecycle on this node. Once an index is closed or deleted these\n     * listeners go out of scope.\n     * <p>\n     * Note: an index might be created on a node multiple times. For instance if the last shard from an index is\n     * relocated to another node the internal representation will be destroyed which includes the registered listeners.\n     * Once the node holds at least one shard of an index all modules are reloaded and listeners are registered again.\n     * Listeners can't be unregistered they will stay alive for the entire time the index is allocated on a node.\n     * </p>\n     ",
      "vertexLabel": "void addSearchOperationListener()"
    },
    {
      "vertexName": "Method public static GeoDistanceSortBuilder geoDistanceSort(String fieldName, String... geohashes)  (SortBuilders.java)",
      "children": [
        {
          "name": "Method public GeoDistanceSortBuilder(String fieldName, String... geohashes)  (GeoDistanceSortBuilder.java)"
        }
      ],
      "comment": "\n     * Constructs a new distance based sort on a geo point like field.\n     *\n     * @param fieldName The geo point like field name.\n     * @param geohashes The points to create the range distance facets from.\n     ",
      "vertexLabel": "GeoDistanceSortBuilder geoDistanceSort()"
    },
    {
      "vertexName": "Method static void onFailure(Iterable<ActionListener<Response>> listeners, Exception failure)  (ActionListener.java)",
      "comment": "\n     * Notifies every given listener with the failure passed to {@link #onFailure(Exception)}. If a listener itself throws an exception\n     * all remaining listeners will be processed and the caught exception will be re-thrown.\n     ",
      "vertexLabel": "void onFailure()"
    },
    {
      "vertexName": "Method String get(String setting, String defaultValue, boolean isList)  (Settings.java)",
      "children": [
        {
          "name": "Method public String get(String setting, String defaultValue)  (Settings.java)"
        }
      ],
      "comment": "\n     * Returns the setting value associated with the setting key. If it does not exists,\n     * returns the default value provided.\n     ",
      "vertexLabel": "String get()"
    },
    {
      "vertexName": "Method public List<FileInfo> findPhysicalIndexFiles(String physicalName)  (BlobStoreIndexShardSnapshots.java)",
      "children": [
        {
          "name": "Method public FileInfo findNameFile(String name)  (BlobStoreIndexShardSnapshots.java)"
        }
      ],
      "comment": "\n     * Finds reference to a snapshotted file by its original name\n     *\n     * @param physicalName original name\n     * @return a list of file infos that match specified physical file or null if the file is not present in any of snapshots\n     ",
      "vertexLabel": "List<FileInfo> findPhysicalIndexFiles()"
    },
    {
      "vertexName": "Field index  (SingleShardRequest.java)",
      "comment": "\n     * The concrete index name\n     *\n     * Whether index property is optional depends on the concrete implementation. If index property is required the\n     * concrete implementation should use {@link #validateNonNullIndex()} to check if the index property has been set\n     ",
      "vertexLabel": "Field index"
    },
    {
      "vertexName": "Method public void registerAsDeprecatedHandler(RestRequest.Method method, String path, RestHandler handler, String deprecationMessage, DeprecationLogger logger)  (RestController.java)",
      "children": [
        {
          "name": "Method public void registerHandler(RestRequest.Method method, String path, RestHandler handler)  (RestController.java)"
        }
      ],
      "comment": "\n     * Registers a REST handler to be executed when the provided {@code method} and {@code path} match the request.\n     *\n     * @param method GET, POST, etc.\n     * @param path Path to handle (e.g., \"/{index}/{type}/_bulk\")\n     * @param handler The handler to actually execute\n     * @param deprecationMessage The message to log and send as a header in the response\n     * @param logger The existing deprecation logger to use\n     ",
      "vertexLabel": "void registerAsDeprecatedHandler()"
    },
    {
      "vertexName": "Method public ImmutableOpenMap<String, DiskUsage> getNodeLeastAvailableDiskUsages()  (ClusterInfo.java)",
      "children": [
        {
          "name": "Method public ImmutableOpenMap<String, DiskUsage> getNodeMostAvailableDiskUsages()  (ClusterInfo.java)"
        }
      ],
      "comment": "\n     * Returns a node id to disk usage mapping for the path that has the least available space on the node.\n     ",
      "vertexLabel": "ImmutableOpenMap<String, DiskUsage> getNodeLeastAvailableDiskUsages()"
    },
    {
      "vertexName": "Method public Set<String> availableIndexFoldersForPath(final NodePath nodePath, Predicate<String> excludeIndexPathIdsPredicate) throws IOException  (NodeEnvironment.java)",
      "children": [
        {
          "name": "Method public Set<String> availableIndexFoldersForPath(final NodePath nodePath) throws IOException  (NodeEnvironment.java)"
        }
      ],
      "comment": "\n     * Return directory names in the nodes/{node.id}/indices directory for the given node path that don't match the given predicate.\n     *\n     * @param nodePath the path\n     * @param excludeIndexPathIdsPredicate folder names to exclude\n     * @return all directories that could be indices for the given node path.\n     * @throws IOException if an I/O exception occurs traversing the filesystem\n     ",
      "vertexLabel": "Set<String> availableIndexFoldersForPath()"
    },
    {
      "vertexName": "Method public QueryStringQueryParser(QueryShardContext context, String defaultField)  (QueryStringQueryParser.java)",
      "comment": "\n     * @param context The query shard context.\n     * @param defaultField The default field for query terms.\n     ",
      "vertexLabel": "QueryStringQueryParser()"
    },
    {
      "vertexName": "Class BigByteArray  (BigByteArray.java)",
      "children": [
        {
          "name": "Class BigIntArray  (BigIntArray.java)"
        }
      ],
      "comment": "\n * Byte array abstraction able to support more than 2B values. This implementation slices data into fixed-sized blocks of\n * configurable length.\n ",
      "vertexLabel": "Class BigByteArray"
    },
    {
      "vertexName": "Method ActionFuture<UpgradeStatusResponse> upgradeStatus(UpgradeStatusRequest request)  (IndicesAdminClient.java)",
      "children": [
        {
          "name": "Method ActionFuture<UpgradeResponse> upgrade(UpgradeRequest request)  (IndicesAdminClient.java)"
        }
      ],
      "comment": "\n     * Check upgrade status of one or more indices\n     *\n     * @param request The upgrade request\n     * @return A result future\n     * @see org.elasticsearch.client.Requests#upgradeRequest(String...)\n     ",
      "vertexLabel": "ActionFuture<UpgradeStatusResponse> upgradeStatus()"
    },
    {
      "vertexName": "Method public DateHistogramAggregationBuilder interval(long interval)  (DateHistogramAggregationBuilder.java)",
      "comment": " Set the interval on this builder, and return the builder so that calls can be chained.\n     *  If both {@link #interval()} and {@link #dateHistogramInterval()} are set, then the\n     *  {@link #dateHistogramInterval()} wins. ",
      "vertexLabel": "DateHistogramAggregationBuilder interval()"
    },
    {
      "vertexName": "Method public SearchExtensionSpec(String name, Writeable.Reader<? extends W> reader, P parser)  (SearchPlugin.java)",
      "comment": "\n         * Build the spec with a String.\n         *\n         * @param name the name of the behavior. The parser and the reader are are registered under this name so be sure that that is the\n         *        name that W's {@link NamedWriteable#getWriteableName()} returns.\n         * @param reader reader that reads the behavior from the internode protocol\n         * @param parser parser that read the behavior from a REST request\n         ",
      "vertexLabel": "SearchExtensionSpec()"
    },
    {
      "vertexName": "Method public static void checkIndexClosing(ClusterState currentState, Set<IndexMetaData> indices)  (SnapshotsService.java)",
      "comment": "\n     * Check if any of the indices to be closed are currently being snapshotted. Fail as closing an index that is being\n     * snapshotted (with partial == false) makes the snapshot fail.\n     ",
      "vertexLabel": "void checkIndexClosing()"
    },
    {
      "vertexName": "Method public MultiSearchRequestBuilder add(SearchRequest request)  (MultiSearchRequestBuilder.java)",
      "children": [
        {
          "name": "Method public MultiSearchRequest add(SearchRequestBuilder request)  (MultiSearchRequest.java)"
        }
      ],
      "comment": "\n     * Add a search request to execute. Note, the order is important, the search response will be returned in the\n     * same order as the search requests.\n     * <p>\n     * If ignoreIndices has been set on the search request, then the indicesOptions of the multi search request\n     * will not be used (if set).\n     ",
      "vertexLabel": "MultiSearchRequestBuilder add()"
    },
    {
      "vertexName": "Method public GetRequestBuilder setPreference(String preference)  (GetRequestBuilder.java)",
      "children": [
        {
          "name": "Method public SearchRequest preference(String preference)  (SearchRequest.java)"
        }
      ],
      "comment": "\n     * Sets the preference to execute the search. Defaults to randomize across shards. Can be set to\n     * {@code _local} to prefer local shards or a custom value, which guarantees that the same order\n     * will be used across different requests.\n     ",
      "vertexLabel": "GetRequestBuilder setPreference()"
    },
    {
      "vertexName": "Method public int getMinTermFreq()  (XMoreLikeThis.java)",
      "children": [
        {
          "name": "Method public void setMinTermFreq(int minTermFreq)  (XMoreLikeThis.java)"
        }
      ],
      "comment": "\n     * Returns the frequency below which terms will be ignored in the source doc. The default\n     * frequency is the {@link #DEFAULT_MIN_TERM_FREQ}.\n     *\n     * @return the frequency below which terms will be ignored in the source doc.\n     ",
      "vertexLabel": "int getMinTermFreq()"
    },
    {
      "vertexName": "Method public static boolean hasText(String str)  (Strings.java)",
      "comment": "\n     * Check whether the given String has actual text.\n     * More specifically, returns <code>true</code> if the string not <code>null</code>,\n     * its length is greater than 0, and it contains at least one non-whitespace character.\n     *\n     * @param str the String to check (may be <code>null</code>)\n     * @return <code>true</code> if the String is not <code>null</code>, its length is\n     *         greater than 0, and it does not contain whitespace only\n     * @see #hasText(CharSequence)\n     ",
      "vertexLabel": "boolean hasText()"
    },
    {
      "vertexName": "Method static void onResponse(Iterable<ActionListener<Response>> listeners, Response response)  (ActionListener.java)",
      "children": [
        {
          "name": "Method static void onFailure(Iterable<ActionListener<Response>> listeners, Exception failure)  (ActionListener.java)"
        }
      ],
      "comment": "\n     * Notifies every given listener with the response passed to {@link #onResponse(Object)}. If a listener itself throws an exception\n     * the exception is forwarded to {@link #onFailure(Exception)}. If in turn {@link #onFailure(Exception)} fails all remaining\n     * listeners will be processed and the caught exception will be re-thrown.\n     ",
      "vertexLabel": "void onResponse()"
    },
    {
      "vertexName": "Method public abstract String explainConflictForWrites(long currentVersion, long expectedVersion, boolean deleted)  (VersionType.java)",
      "children": [
        {
          "name": "Method public abstract boolean isVersionConflictForWrites(long currentVersion, long expectedVersion, boolean deleted)  (VersionType.java)"
        }
      ],
      "comment": "\n     * Returns a human readable explanation for a version conflict on write.\n     *\n     * Note that this method is only called if {@link #isVersionConflictForWrites(long, long, boolean)} returns true;\n     *\n     * @param currentVersion  the current version for the document\n     * @param expectedVersion the version specified for the write operation\n     * @param deleted         true if the document is currently deleted (note that #currentVersion will typically be\n     *                        {@link Versions#NOT_FOUND}, but may be something else if the document was recently deleted\n     ",
      "vertexLabel": "abstract String explainConflictForWrites()"
    },
    {
      "vertexName": "Method public void addMetadata(String key, String... values)  (ElasticsearchException.java)",
      "comment": "\n     * Adds a new piece of metadata with the given key.\n     * If the provided key is already present, the corresponding metadata will be replaced\n     ",
      "vertexLabel": "void addMetadata()"
    },
    {
      "vertexName": "Method private synchronized boolean markAsFailed(String reason)  (PublishClusterStateAction.java)",
      "children": [
        {
          "name": "Method private synchronized boolean markAsFailed(String details, Exception reason)  (PublishClusterStateAction.java)"
        }
      ],
      "comment": "\n         * tries marking the publishing as failed, if a decision wasn't made yet\n         *\n         * @return true if the publishing was failed and the cluster state is *not* committed\n         *",
      "vertexLabel": "synchronized boolean markAsFailed()"
    },
    {
      "vertexName": "Method PageCacheRecycler createPageCacheRecycler(Settings settings)  (Node.java)",
      "children": [
        {
          "name": "Method BigArrays createBigArrays(PageCacheRecycler pageCacheRecycler, CircuitBreakerService circuitBreakerService)  (Node.java)"
        }
      ],
      "comment": "\n     * Creates a new {@link BigArrays} instance used for this node.\n     * This method can be overwritten by subclasses to change their {@link BigArrays} implementation for instance for testing\n     ",
      "vertexLabel": "PageCacheRecycler createPageCacheRecycler()"
    },
    {
      "vertexName": "Method public CreateIndexRequestBuilder addMapping(String type, XContentBuilder source)  (CreateIndexRequestBuilder.java)",
      "children": [
        {
          "name": "Method public CreateIndexRequest mapping(String type, XContentBuilder source)  (CreateIndexRequest.java)"
        }
      ],
      "comment": "\n     * Adds mapping that will be added when the index gets created.\n     *\n     * @param type   The mapping type\n     * @param source The mapping source\n     ",
      "vertexLabel": "CreateIndexRequestBuilder addMapping()"
    },
    {
      "vertexName": "Method public Query like(Terms... likeTerms) throws IOException  (XMoreLikeThis.java)",
      "comment": "\n     * Return a query that will return docs like the passed Terms.\n     *\n     * @return a query that will return docs like the passed Terms.\n     ",
      "vertexLabel": "Query like()"
    },
    {
      "vertexName": "Method protected void onNonChannelException(Exception exception)  (AbstractHttpServerTransport.java)",
      "children": [
        {
          "name": "Method protected void onNonChannelException(Exception exception)  (TcpTransport.java)"
        }
      ],
      "comment": "\n     * Exception handler for exceptions that are not associated with a specific channel.\n     *\n     * @param exception the exception\n     ",
      "vertexLabel": "void onNonChannelException()"
    },
    {
      "vertexName": "Method public static boolean hasText(CharSequence str)  (Strings.java)",
      "children": [
        {
          "name": "Method public static boolean hasText(String str)  (Strings.java)"
        },
        {
          "name": "Method public static boolean hasLength(CharSequence str)  (Strings.java)"
        }
      ],
      "comment": "\n     * Check whether the given CharSequence has actual text.\n     * More specifically, returns <code>true</code> if the string not <code>null</code>,\n     * its length is greater than 0, and it contains at least one non-whitespace character.\n     * <pre>\n     * StringUtils.hasText(null) = false\n     * StringUtils.hasText(\"\") = false\n     * StringUtils.hasText(\" \") = false\n     * StringUtils.hasText(\"12345\") = true\n     * StringUtils.hasText(\" 12345 \") = true\n     * </pre>\n     *\n     * @param str the CharSequence to check (may be <code>null</code>)\n     * @return <code>true</code> if the CharSequence is not <code>null</code>,\n     *         its length is greater than 0, and it does not contain whitespace only\n     * @see java.lang.Character#isWhitespace\n     ",
      "vertexLabel": "boolean hasText()"
    },
    {
      "vertexName": "Method public ClusterRerouteRequestBuilder setDryRun(boolean dryRun)  (ClusterRerouteRequestBuilder.java)",
      "children": [
        {
          "name": "Method public ClusterRerouteRequest dryRun(boolean dryRun)  (ClusterRerouteRequest.java)"
        }
      ],
      "comment": "\n     * Sets a dry run flag (defaults to {@code false}) allowing to run the commands without\n     * actually applying them to the cluster state, and getting the resulting cluster state back.\n     ",
      "vertexLabel": "ClusterRerouteRequestBuilder setDryRun()"
    },
    {
      "vertexName": "Method public long getConfiguredDelayInMillis()  (AllocateUnassignedDecision.java)",
      "children": [
        {
          "name": "Method public long getRemainingDelayInMillis()  (AllocateUnassignedDecision.java)"
        }
      ],
      "comment": "\n     * Gets the total configured delay for allocating the replica shard when a node holding the replica left\n     * the cluster and the deciders are waiting to see if the node returns before allocating the replica\n     * elsewhere.  Only returns a meaningful positive value if {@link #getAllocationStatus()} returns\n     * {@link AllocationStatus#DELAYED_ALLOCATION}.  If {@link #isDecisionTaken()} returns {@code false},\n     * then invoking this method will throw an {@code IllegalStateException}.\n     ",
      "vertexLabel": "long getConfiguredDelayInMillis()"
    },
    {
      "vertexName": "Interface TcpChannel  (TcpChannel.java)",
      "comment": "\n * This is a tcp channel representing a single channel connection to another node. It is the base channel\n * abstraction used by the {@link TcpTransport} and {@link TransportService}. All tcp transport\n * implementations must return channels that adhere to the required method contracts.\n ",
      "vertexLabel": "Interface TcpChannel"
    },
    {
      "vertexName": "Method public DeleteRequest setShardId(ShardId shardId)  (DeleteRequest.java)",
      "children": [
        {
          "name": "Method public IndexRequest setShardId(ShardId shardId)  (IndexRequest.java)"
        }
      ],
      "comment": "\n     * Override this method from ReplicationAction, this is where we are storing our state in the request object (which we really shouldn't\n     * do). Once the transport client goes away we can move away from making this available, but in the meantime this is dangerous to set or\n     * use because the DeleteRequest object will always be wrapped in a bulk request envelope, which is where this *should* be set.\n     ",
      "vertexLabel": "DeleteRequest setShardId()"
    },
    {
      "vertexName": "Field localNodeId  (NodeClient.java)",
      "comment": "\n     * The id of the local {@link DiscoveryNode}. Useful for generating task ids from tasks returned by\n     * {@link #executeLocally(Action, ActionRequest, TaskListener)}.\n     ",
      "vertexLabel": "Field localNodeId"
    },
    {
      "vertexName": "Method public static int readMessageLength(BytesReference networkBytes) throws IOException  (TcpTransport.java)",
      "comment": "\n     * Validates the first 6 bytes of the message header and returns the length of the message. If 6 bytes\n     * are not available, it returns -1.\n     *\n     * @param networkBytes the will be read\n     * @return the length of the message\n     * @throws StreamCorruptedException              if the message header format is not recognized\n     * @throws TcpTransport.HttpOnTransportException if the message header appears to be an HTTP message\n     * @throws IllegalArgumentException              if the message length is greater that the maximum allowed frame size.\n     *                                               This is dependent on the available memory.\n     ",
      "vertexLabel": "int readMessageLength()"
    },
    {
      "vertexName": "Method public ScriptSortBuilder setNestedPath(String nestedPath)  (ScriptSortBuilder.java)",
      "children": [
        {
          "name": "Method public String getNestedPath()  (FieldSortBuilder.java)"
        }
      ],
      "comment": "\n     * Sets the nested path if sorting occurs on a field that is inside a nested object. For sorting by script this\n     * needs to be specified.\n     *\n     * @deprecated set nested sort with {@link #setNestedSort(NestedSortBuilder)} and retrieve with {@link #getNestedSort()}\n     ",
      "vertexLabel": "ScriptSortBuilder setNestedPath()"
    },
    {
      "vertexName": "Method private void setOptions(Map<String, String> options)  (Script.java)",
      "children": [
        {
          "name": "Method private void setOptions(Map<String, String> options)  (StoredScriptSource.java)"
        }
      ],
      "comment": "\n         * Options may have already been added if an inline template was specified.\n         * Appends the user-defined compiler options with the internal compiler options.\n         ",
      "vertexLabel": "void setOptions()"
    },
    {
      "vertexName": "Method public SearchRequestBuilder addScriptField(String name, Script script)  (SearchRequestBuilder.java)",
      "children": [
        {
          "name": "Method public SearchRequestBuilder addDocValueField(String name, String format)  (SearchRequestBuilder.java)"
        }
      ],
      "comment": "\n     * Adds a script based field to load and return. The field does not have to be stored,\n     * but its recommended to use non analyzed or numeric fields.\n     *\n     * @param name   The name that will represent this value in the return hit\n     * @param script The script to use\n     ",
      "vertexLabel": "SearchRequestBuilder addScriptField()"
    },
    {
      "vertexName": "Method protected abstract double[] doPredict(Collection<Double> values, int numPredictions)  (MovAvgModel.java)",
      "children": [
        {
          "name": "Method public double[] predict(Collection<Double> values, int numPredictions)  (MovAvgModel.java)"
        }
      ],
      "comment": "\n     * Calls to the model-specific implementation which actually generates the predictions\n     *\n     * @param values            Collection of numerics to movingAvg, usually windowed\n     * @param numPredictions    Number of newly generated predictions to return\n     * @return                  Returns an array of doubles, since most smoothing methods operate on floating points\n     ",
      "vertexLabel": "abstract double[] doPredict()"
    },
    {
      "vertexName": "Method public DeleteRequestBuilder setRouting(String routing)  (DeleteRequestBuilder.java)",
      "children": [
        {
          "name": "Method public String routing()  (DeleteRequest.java)"
        }
      ],
      "comment": "\n     * Controls the shard routing of the delete request. Using this value to hash the shard\n     * and not the id.\n     ",
      "vertexLabel": "DeleteRequestBuilder setRouting()"
    },
    {
      "vertexName": "Method public SearchRequestBuilder addSort(String field, SortOrder order)  (SearchRequestBuilder.java)",
      "comment": "\n     * Adds a sort against the given field name and the sort ordering.\n     *\n     * @param field The name of the field\n     * @param order The sort ordering\n     ",
      "vertexLabel": "SearchRequestBuilder addSort()"
    },
    {
      "vertexName": "Method public Query like(String fieldName, Reader... readers) throws IOException  (XMoreLikeThis.java)",
      "children": [
        {
          "name": "Method public Query like(Fields... likeFields) throws IOException  (XMoreLikeThis.java)"
        }
      ],
      "comment": "\n     * Return a query that will return docs like the passed Readers.\n     * This was added in order to treat multi-value fields.\n     *\n     * @return a query that will return docs like the passed Readers.\n     ",
      "vertexLabel": "Query like()"
    },
    {
      "vertexName": "EnumConstant AVG  (SortMode.java)",
      "children": [
        {
          "name": "EnumConstant MEDIAN  (SortMode.java)"
        }
      ],
      "comment": " Use the average of all values as sort value. Only applicable for number based array fields. *",
      "vertexLabel": "EnumConstant AVG"
    },
    {
      "vertexName": "Method public ScheduledFuture<?> schedule(TimeValue delay, String executor, Runnable command)  (ThreadPool.java)",
      "comment": "\n     * Schedules a one-shot command to run after a given delay. The command is not run in the context of the calling thread. To preserve the\n     * context of the calling thread you may call <code>threadPool.getThreadContext().preserveContext</code> on the runnable before passing\n     * it to this method.\n     *\n     * @param delay delay before the task executes\n     * @param executor the name of the thread pool on which to execute this task. SAME means \"execute on the scheduler thread\" which changes the\n     *        meaning of the ScheduledFuture returned by this method. In that case the ScheduledFuture will complete only when the command\n     *        completes.\n     * @param command the command to run\n     * @return a ScheduledFuture who's get will return when the task is has been added to its target thread pool and throw an exception if\n     *         the task is canceled before it was added to its target thread pool. Once the task has been added to its target thread pool\n     *         the ScheduledFuture will cannot interact with it.\n     * @throws org.elasticsearch.common.util.concurrent.EsRejectedExecutionException if the task cannot be scheduled for execution\n     ",
      "vertexLabel": "ScheduledFuture<?> schedule()"
    },
    {
      "vertexName": "Method public static PlainListenableActionFuture<T> newListenableFuture()  (PlainListenableActionFuture.java)",
      "comment": "\n     * This method returns a listenable future. The listeners will be called on completion of the future.\n     * The listeners will be executed by the same thread that completes the future.\n     *\n     * @param <T> the result of the future\n     * @return a listenable future\n     ",
      "vertexLabel": "PlainListenableActionFuture<T> newListenableFuture()"
    },
    {
      "vertexName": "Method public static Map<String, Float> resolveMappingField(QueryShardContext context, String fieldOrPattern, float weight, boolean acceptAllTypes, boolean acceptMetadataField)  (QueryParserHelper.java)",
      "comment": "\n     * Resolves the provided pattern or field name from the {@link QueryShardContext} and return a map of\n     * the expanded fields with their original boost.\n     * @param context The context of the query\n     * @param fieldOrPattern The field name or the pattern to resolve\n     * @param weight The weight for the field\n     * @param acceptAllTypes Whether all field type should be added when a pattern is expanded.\n     *                       If false, only searchable field types are added.\n     * @param acceptMetadataField Whether metadata fields should be added when a pattern is expanded.\n     ",
      "vertexLabel": "Map<String, Float> resolveMappingField()"
    },
    {
      "vertexName": "Method public Builder put(String setting, long value, TimeUnit timeUnit)  (Settings.java)",
      "children": [
        {
          "name": "Method public Builder put(String setting, int value)  (Settings.java)"
        }
      ],
      "comment": "\n         * Sets the setting with the provided setting key and the time value.\n         *\n         * @param setting The setting key\n         * @param value   The time value\n         * @return The builder\n         ",
      "vertexLabel": "Builder put()"
    },
    {
      "vertexName": "Method void onResponseSent(long requestId, String action, Exception error)  (TransportMessageListener.java)",
      "comment": "*\n     * Called for every failed action response after the response has been passed to the underlying network implementation.\n     * @param requestId the request ID (unique per client)\n     * @param action the request action\n     * @param error the error sent back to the caller\n     ",
      "vertexLabel": "void onResponseSent()"
    },
    {
      "vertexName": "Method public IndexMetaData verifyIndexIsDeleted(final Index index, final ClusterState clusterState)  (IndicesService.java)",
      "comment": "\n     * Verify that the contents on disk for the given index is deleted; if not, delete the contents.\n     * This method assumes that an index is already deleted in the cluster state and/or explicitly\n     * through index tombstones.\n     * @param index {@code Index} to make sure its deleted from disk\n     * @param clusterState {@code ClusterState} to ensure the index is not part of it\n     * @return IndexMetaData for the index loaded from disk\n     ",
      "vertexLabel": "IndexMetaData verifyIndexIsDeleted()"
    },
    {
      "vertexName": "Method public final Request waitForActiveShards(final int waitForActiveShards)  (ReplicationRequest.java)",
      "children": [
        {
          "name": "Method public BulkRequest waitForActiveShards(final int waitForActiveShards)  (BulkRequest.java)"
        }
      ],
      "comment": "\n     * A shortcut for {@link #waitForActiveShards(ActiveShardCount)} where the numerical\n     * shard count is passed in, instead of having to first call {@link ActiveShardCount#from(int)}\n     * to get the ActiveShardCount.\n     ",
      "vertexLabel": "final Request waitForActiveShards()"
    },
    {
      "vertexName": "Method public String routing()  (DeleteRequest.java)",
      "comment": "\n     * Controls the shard routing of the delete request. Using this value to hash the shard\n     * and not the id.\n     ",
      "vertexLabel": "String routing()"
    },
    {
      "vertexName": "Method public ShardRouting removeRelocationSource()  (ShardRouting.java)",
      "children": [
        {
          "name": "Method private ShardRouting removeRelocationSource(ShardRouting shard)  (RoutingNodes.java)"
        }
      ],
      "comment": "\n     * Removes relocation source of a non-primary shard. The shard state must be <code>INITIALIZING</code>.\n     * This allows the non-primary shard to continue recovery from the primary even though its non-primary\n     * relocation source has failed.\n     ",
      "vertexLabel": "ShardRouting removeRelocationSource()"
    },
    {
      "vertexName": "Method public String routing()  (IndexRequest.java)",
      "children": [
        {
          "name": "Method public GetRequest routing(String routing)  (GetRequest.java)"
        }
      ],
      "comment": "\n     * Controls the shard routing of the request. Using this value to hash the shard\n     * and not the id.\n     ",
      "vertexLabel": "String routing()"
    },
    {
      "vertexName": "Method public synchronized void reset(Exception cause)  (ThreadBarrier.java)",
      "children": [
        {
          "name": "Method private synchronized void breakIfBroken() throws BrokenBarrierException  (ThreadBarrier.java)"
        }
      ],
      "comment": "\n     * Resets the barrier to its initial state.  If any parties are\n     * currently waiting at the barrier, they will return with a\n     * {@link BrokenBarrierException}. Note that resets <em>after</em>\n     * a breakage has occurred for other reasons can be complicated to\n     * carry out; threads need to re-synchronize in some other way,\n     * and choose one to perform the reset.  It may be preferable to\n     * instead create a new barrier for subsequent use.\n     *\n     * @param cause The cause of the BrokenBarrierException\n     ",
      "vertexLabel": "synchronized void reset()"
    },
    {
      "vertexName": "Method public Iterator<IntObjectCursor<VType>> iterator()  (ImmutableOpenIntMap.java)",
      "children": [
        {
          "name": "Method public Iterator<ObjectObjectCursor<KType, VType>> iterator()  (ImmutableOpenMap.java)"
        }
      ],
      "comment": "\n     * Returns a cursor over the entries (key-value pairs) in this map. The iterator is\n     * implemented as a cursor and it returns <b>the same cursor instance</b> on every\n     * call to {@link java.util.Iterator#next()}. To read the current key and value use the cursor's\n     * public fields. An example is shown below.\n     * <pre>\n     * for (IntShortCursor c : intShortMap)\n     * {\n     *     System.out.println(&quot;index=&quot; + c.index\n     *       + &quot; key=&quot; + c.key\n     *       + &quot; value=&quot; + c.value);\n     * }\n     * </pre>\n     * <p>\n     * The <code>index</code> field inside the cursor gives the internal index inside\n     * the container's implementation. The interpretation of this index depends on\n     * to the container.\n     ",
      "vertexLabel": "Iterator<IntObjectCursor<VType>> iterator()"
    },
    {
      "vertexName": "Method public String analyzer()  (QueryStringQueryBuilder.java)",
      "children": [
        {
          "name": "Method public QueryStringQueryBuilder analyzer(String analyzer)  (QueryStringQueryBuilder.java)"
        }
      ],
      "comment": "\n     * The optional analyzer used to analyze the query string. Note, if a field has search analyzer\n     * defined for it, then it will be used automatically. Defaults to the smart search analyzer.\n     ",
      "vertexLabel": "String analyzer()"
    },
    {
      "vertexName": "Class MemoryBasicInformation  (JNAKernel32Library.java)",
      "comment": "\n     * Contains information about a range of pages in the virtual address space of a process.\n     * The VirtualQuery and VirtualQueryEx functions use this structure.\n     *\n     * https://msdn.microsoft.com/en-us/library/windows/desktop/aa366775%28v=vs.85%29.aspx\n     ",
      "vertexLabel": "Class MemoryBasicInformation"
    },
    {
      "vertexName": "Method public CreateIndexRequest mapping(String type, XContentBuilder source)  (CreateIndexRequest.java)",
      "comment": "\n     * Adds mapping that will be added when the index gets created.\n     *\n     * @param type   The mapping type\n     * @param source The mapping source\n     ",
      "vertexLabel": "CreateIndexRequest mapping()"
    },
    {
      "vertexName": "Method public boolean metaDataChanged()  (ClusterChangedEvent.java)",
      "children": [
        {
          "name": "Method public boolean blocksChanged()  (ClusterChangedEvent.java)"
        }
      ],
      "comment": "\n     * Returns <code>true</code> iff the metadata for the cluster has changed between\n     * the previous cluster state and the new cluster state. Note that this is an object\n     * reference equality test, not an equals test.\n     ",
      "vertexLabel": "boolean metaDataChanged()"
    },
    {
      "vertexName": "Method LeafBucketCollector getLeafCollector(LeafReaderContext context, LeafBucketCollector in) throws IOException  (CompositeValuesCollectorQueue.java)",
      "comment": "\n     * Creates the collector that will visit the composite buckets of the matching documents.\n     * The provided collector <code>in</code> is called on each composite bucket.\n     ",
      "vertexLabel": "LeafBucketCollector getLeafCollector()"
    },
    {
      "vertexName": "Method public static double parse(String distance, DistanceUnit defaultUnit, DistanceUnit to)  (DistanceUnit.java)",
      "children": [
        {
          "name": "Method public double parse(String distance, DistanceUnit defaultUnit)  (DistanceUnit.java)"
        }
      ],
      "comment": "\n     * Parses a given distance and converts it to the specified unit.\n     * \n     * @param distance String defining a distance (value and unit)\n     * @param defaultUnit unit assumed if none is defined\n     * @param to unit of result\n     * @return parsed distance\n     ",
      "vertexLabel": "double parse()"
    },
    {
      "vertexName": "Method public QuerySpec(ParseField name, Writeable.Reader<T> reader, QueryParser<T> parser)  (SearchPlugin.java)",
      "children": [
        {
          "name": "Method public QuerySpec(String name, Writeable.Reader<T> reader, QueryParser<T> parser)  (SearchPlugin.java)"
        }
      ],
      "comment": "\n         * Specification of custom {@link Query}.\n         *\n         * @param name holds the names by which this query might be parsed. The {@link ParseField#getPreferredName()} is special as it\n         *        is the name by under which the reader is registered. So it is the name that the query should use as its\n         *        {@link NamedWriteable#getWriteableName()} too.\n         * @param reader the reader registered for this query's builder. Typically a reference to a constructor that takes a\n         *        {@link StreamInput}\n         * @param parser the parser the reads the query builder from xcontent\n         ",
      "vertexLabel": "QuerySpec()"
    },
    {
      "vertexName": "Method public ResizeRequestBuilder setWaitForActiveShards(ActiveShardCount waitForActiveShards)  (ResizeRequestBuilder.java)",
      "children": [
        {
          "name": "Method public void setWaitForActiveShards(ActiveShardCount waitForActiveShards)  (ResizeRequest.java)"
        }
      ],
      "comment": "\n     * Sets the number of shard copies that should be active for creation of the\n     * new shrunken index to return. Defaults to {@link ActiveShardCount#DEFAULT}, which will\n     * wait for one shard copy (the primary) to become active. Set this value to\n     * {@link ActiveShardCount#ALL} to wait for all shards (primary and all replicas) to be active\n     * before returning. Otherwise, use {@link ActiveShardCount#from(int)} to set this value to any\n     * non-negative integer, up to the number of copies per shard (number of replicas + 1),\n     * to wait for the desired amount of shard copies to become active before returning.\n     * Index creation will only wait up until the timeout value for the number of shard copies\n     * to be active before returning.  Check {@link ResizeResponse#isShardsAcknowledged()} to\n     * determine if the requisite shard copies were all started before returning or timing out.\n     *\n     * @param waitForActiveShards number of active shard copies to wait on\n     ",
      "vertexLabel": "ResizeRequestBuilder setWaitForActiveShards()"
    },
    {
      "vertexName": "Method public PutIndexTemplateRequest mapping(String type, Object... source)  (PutIndexTemplateRequest.java)",
      "children": [
        {
          "name": "Method public CreateIndexRequest mapping(String type, Object... source)  (CreateIndexRequest.java)"
        }
      ],
      "comment": "\n     * A specialized simplified mapping source method, takes the form of simple properties definition:\n     * (\"field1\", \"type=string,store=true\").\n     ",
      "vertexLabel": "PutIndexTemplateRequest mapping()"
    },
    {
      "vertexName": "Method public T getFieldValue(String path, Class<T> clazz)  (IngestDocument.java)",
      "children": [
        {
          "name": "Method public boolean hasField(String path)  (IngestDocument.java)"
        },
        {
          "name": "Method public void removeField(String path)  (IngestDocument.java)"
        }
      ],
      "comment": "\n     * Returns the value contained in the document for the provided path\n     * @param path The path within the document in dot-notation\n     * @param clazz The expected class of the field value\n     * @return the value for the provided path if existing, null otherwise\n     * @throws IllegalArgumentException if the path is null, empty, invalid, if the field doesn't exist\n     * or if the field that is found at the provided path is not of the expected type.\n     ",
      "vertexLabel": "T getFieldValue()"
    },
    {
      "vertexName": "Method public SearchSourceBuilder rewrite(QueryRewriteContext context) throws IOException  (SearchSourceBuilder.java)",
      "children": [
        {
          "name": "Method QueryBuilder rewrite(QueryRewriteContext queryShardContext) throws IOException  (QueryBuilder.java)"
        }
      ],
      "comment": "\n     * Rewrites this search source builder into its primitive form. e.g. by\n     * rewriting the QueryBuilder. If the builder did not change the identity\n     * reference must be returned otherwise the builder will be rewritten\n     * infinitely.\n     ",
      "vertexLabel": "SearchSourceBuilder rewrite()"
    },
    {
      "vertexName": "Method public void setBatchedReduceSize(int batchedReduceSize)  (SearchRequest.java)",
      "comment": "\n     * Sets the number of shard results that should be reduced at once on the coordinating node. This value should be used as a protection\n     * mechanism to reduce the memory overhead per search request if the potential number of shards in the request can be large.\n     ",
      "vertexLabel": "void setBatchedReduceSize()"
    },
    {
      "vertexName": "Method public Decision canAllocate(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation)  (AllocationDecider.java)",
      "comment": "\n     * Returns a {@link Decision} whether the given shard routing can be\n     * allocated on the given node. The default is {@link Decision#ALWAYS}.\n     ",
      "vertexLabel": "Decision canAllocate()"
    },
    {
      "vertexName": "Method public String getBase64UUID(Random random)  (RandomBasedUUIDGenerator.java)",
      "children": [
        {
          "name": "Method public static String randomBase64UUID(Random random)  (UUIDs.java)"
        }
      ],
      "comment": "\n     * Returns a Base64 encoded version of a Version 4.0 compatible UUID\n     * randomly initialized by the given {@link java.util.Random} instance\n     * as defined here: http://www.ietf.org/rfc/rfc4122.txt\n     ",
      "vertexLabel": "String getBase64UUID()"
    },
    {
      "vertexName": "Method public Builder storeScript(String id, StoredScriptSource source)  (ScriptMetaData.java)",
      "children": [
        {
          "name": "Method public Builder deleteScript(String id)  (ScriptMetaData.java)"
        }
      ],
      "comment": "\n         * Add a new script to the existing stored scripts based on a user-specified id.  If\n         * a script with the same id already exists it will be overwritten.\n         * @param id The user-specified id to use for the look up.\n         * @param source The user-specified stored script data held in {@link StoredScriptSource}.\n         ",
      "vertexLabel": "Builder storeScript()"
    },
    {
      "vertexName": "Method public void registerRequestHandler(String action, Supplier<Request> request, String executor, boolean forceExecution, boolean canTripCircuitBreaker, TransportRequestHandler<Request> handler)  (TransportService.java)",
      "children": [
        {
          "name": "Method public void registerRequestHandler(String action, Supplier<Request> requestFactory, String executor, TransportRequestHandler<Request> handler)  (TransportService.java)"
        }
      ],
      "comment": "\n     * Registers a new request handler\n     *\n     * @param action                The action the request handler is associated with\n     * @param request               The request class that will be used to construct new instances for streaming\n     * @param executor              The executor the request handling will be executed on\n     * @param forceExecution        Force execution on the executor queue and never reject it\n     * @param canTripCircuitBreaker Check the request size and raise an exception in case the limit is breached.\n     * @param handler               The handler itself that implements the request handling\n     ",
      "vertexLabel": "void registerRequestHandler()"
    },
    {
      "vertexName": "Method public void addLowPriorityApplier(ClusterStateApplier applier)  (ClusterApplierService.java)",
      "comment": "\n     * Adds an applier which will be called after all high priority and normal appliers have been called.\n     ",
      "vertexLabel": "void addLowPriorityApplier()"
    },
    {
      "vertexName": "Method public abstract int docValueCount()  (SortedBinaryDocValues.java)",
      "comment": " \n     * Retrieves the number of values for the current document.  This must always\n     * be greater than zero.\n     * It is illegal to call this method after {@link #advanceExact(int)}\n     * returned {@code false}.\n     ",
      "vertexLabel": "abstract int docValueCount()"
    },
    {
      "vertexName": "Method void onFailure(Task task, Throwable e)  (TaskListener.java)",
      "comment": "\n     * A failure caused by an exception at some phase of the task.\n     *\n     * @param task\n     *            the task being executed. May be null if the action doesn't\n     *            create a task\n     * @param e\n     *            the failure\n     ",
      "vertexLabel": "void onFailure()"
    },
    {
      "vertexName": "Method IndexRequestBuilder prepareIndex()  (Client.java)",
      "comment": "\n     * Index a document associated with a given index and type.\n     * <p>\n     * The id is optional, if it is not provided, one will be generated automatically.\n     ",
      "vertexLabel": "IndexRequestBuilder prepareIndex()"
    },
    {
      "vertexName": "Method public CoordinatesBuilder coordinate(double longitude, double latitude)  (CoordinatesBuilder.java)",
      "comment": "\n     * Add a new coordinate to the collection\n     * @param longitude longitude of the coordinate\n     * @param latitude latitude of the coordinate\n     * @return this\n     ",
      "vertexLabel": "CoordinatesBuilder coordinate()"
    },
    {
      "vertexName": "Method public AnalysisProvider<TokenFilterFactory> getTokenFilterProvider(String tokenFilter, IndexSettings indexSettings)  (AnalysisRegistry.java)",
      "children": [
        {
          "name": "Method public AnalysisProvider<CharFilterFactory> getCharFilterProvider(String charFilter, IndexSettings indexSettings)  (AnalysisRegistry.java)"
        }
      ],
      "comment": "\n     * Returns a registered {@link TokenFilterFactory} provider by {@link IndexSettings}\n     *  or a registered {@link TokenFilterFactory} provider by predefined name\n     *  or <code>null</code> if the tokenFilter was not registered\n     * @param tokenFilter global or defined tokenFilter name\n     * @param indexSettings an index settings\n     * @return {@link TokenFilterFactory} provider or <code>null</code>\n     ",
      "vertexLabel": "AnalysisProvider<TokenFilterFactory> getTokenFilterProvider()"
    },
    {
      "vertexName": "Method public RestoreSnapshotRequest(String repository, String snapshot)  (RestoreSnapshotRequest.java)",
      "children": [
        {
          "name": "Method public CreateSnapshotRequest(String repository, String snapshot)  (CreateSnapshotRequest.java)"
        }
      ],
      "comment": "\n     * Constructs a new put repository request with the provided repository and snapshot names.\n     *\n     * @param repository repository name\n     * @param snapshot   snapshot name\n     ",
      "vertexLabel": "RestoreSnapshotRequest()"
    },
    {
      "vertexName": "Class JodaDateMathParser  (JodaDateMathParser.java)",
      "comment": "\n * A parser for date/time formatted text with optional date math.\n *\n * The format of the datetime is configurable, and unix timestamps can also be used. Datemath\n * is appended to a datetime with the following syntax:\n * <code>||[+-/](\\d+)?[yMwdhHms]</code>.\n ",
      "vertexLabel": "Class JodaDateMathParser"
    },
    {
      "vertexName": "Method public double compression()  (PercentileRanksAggregationBuilder.java)",
      "children": [
        {
          "name": "Method public PercentileRanksAggregationBuilder compression(double compression)  (PercentileRanksAggregationBuilder.java)"
        }
      ],
      "comment": "\n     * Expert: get the compression. Higher values improve accuracy but also\n     * memory usage. Only relevant when using {@link PercentilesMethod#TDIGEST}.\n     ",
      "vertexLabel": "double compression()"
    },
    {
      "vertexName": "Method public static ElasticsearchException[] guessRootCauses(Throwable t)  (ElasticsearchException.java)",
      "children": [
        {
          "name": "Method public ElasticsearchException[] guessRootCauses()  (ElasticsearchException.java)"
        }
      ],
      "comment": "\n     * Returns the root cause of this exception or multiple if different shards caused different exceptions.\n     * If the given exception is not an instance of {@link org.elasticsearch.ElasticsearchException} an empty array\n     * is returned.\n     ",
      "vertexLabel": "ElasticsearchException[] guessRootCauses()"
    },
    {
      "vertexName": "Method public void deprecatedAndMaybeLog(final String key, final String msg, final Object... params)  (DeprecationLogger.java)",
      "children": [
        {
          "name": "Method public void deprecated(String msg, Object... params)  (DeprecationLogger.java)"
        }
      ],
      "comment": "\n     * Adds a formatted warning message as a response header on the thread context, and logs a deprecation message if the associated key has\n     * not recently been seen.\n     *\n     * @param key    the key used to determine if this deprecation should be logged\n     * @param msg    the message to log\n     * @param params parameters to the message\n     ",
      "vertexLabel": "void deprecatedAndMaybeLog()"
    },
    {
      "vertexName": "Method public static SnapshotState fromValue(byte value)  (SnapshotState.java)",
      "comment": "\n     * Generate snapshot state from code\n     *\n     * @param value the state code\n     * @return state\n     ",
      "vertexLabel": "SnapshotState fromValue()"
    },
    {
      "vertexName": "Method public SearchSourceBuilder storedField(String name)  (SearchSourceBuilder.java)",
      "children": [
        {
          "name": "Method public SearchSourceBuilder storedFields(List<String> fields)  (SearchSourceBuilder.java)"
        }
      ],
      "comment": "\n     * Adds a stored field to load and return as part of the\n     * search request. If none are specified, the source of the document will be\n     * return.\n     ",
      "vertexLabel": "SearchSourceBuilder storedField()"
    },
    {
      "vertexName": "Method public void registerRequestHandler(String action, Supplier<Request> requestFactory, String executor, TransportRequestHandler<Request> handler)  (TransportService.java)",
      "comment": "\n     * Registers a new request handler\n     *\n     * @param action         The action the request handler is associated with\n     * @param requestFactory a callable to be used construct new instances for streaming\n     * @param executor       The executor the request handling will be executed on\n     * @param handler        The handler itself that implements the request handling\n     ",
      "vertexLabel": "void registerRequestHandler()"
    },
    {
      "vertexName": "Method public static Setting<ByteSizeValue> memorySizeSetting(String key, String defaultPercentage, Property... properties)  (Setting.java)",
      "children": [
        {
          "name": "Method public static Setting<ByteSizeValue> memorySizeSetting(String key, ByteSizeValue defaultValue, Property... properties)  (Setting.java)"
        }
      ],
      "comment": "\n     * Creates a setting which specifies a memory size. This can either be\n     * specified as an absolute bytes value or as a percentage of the heap\n     * memory.\n     *\n     * @param key the key for the setting\n     * @param defaultPercentage the default value of this setting as a percentage of the heap memory\n     * @param properties properties properties for this setting like scope, filtering...\n     * @return the setting object\n     ",
      "vertexLabel": "Setting<ByteSizeValue> memorySizeSetting()"
    },
    {
      "vertexName": "Method public SearchRequestBuilder setPostFilter(QueryBuilder postFilter)  (SearchRequestBuilder.java)",
      "comment": "\n     * Sets a filter that will be executed after the query has been executed and only has affect on the search hits\n     * (not aggregations). This filter is always executed as last filtering mechanism.\n     ",
      "vertexLabel": "SearchRequestBuilder setPostFilter()"
    },
    {
      "vertexName": "Method public SearchRequestBuilder setRescorer(RescorerBuilder<?> rescorer)  (SearchRequestBuilder.java)",
      "comment": "\n     * Clears all rescorers on the builder and sets the first one.  To use multiple rescore windows use\n     * {@link #addRescorer(org.elasticsearch.search.rescore.RescorerBuilder, int)}.\n     *\n     * @param rescorer rescorer configuration\n     * @return this for chaining\n     ",
      "vertexLabel": "SearchRequestBuilder setRescorer()"
    },
    {
      "vertexName": "Method public void bootstrapNewHistory() throws IOException  (Store.java)",
      "comment": "\n     * Marks an existing lucene index with a new history uuid.\n     * This is used to make sure no existing shard will recovery from this index using ops based recovery.\n     ",
      "vertexLabel": "void bootstrapNewHistory()"
    },
    {
      "vertexName": "Method public MultiMatchQueryBuilder cutoffFrequency(Float cutoff)  (MultiMatchQueryBuilder.java)",
      "children": [
        {
          "name": "Method public MatchQueryBuilder cutoffFrequency(float cutoff)  (MatchQueryBuilder.java)"
        }
      ],
      "comment": "\n     * Set a cutoff value in [0..1] (or absolute number &gt;=1) representing the\n     * maximum threshold of a terms document frequency to be considered a low\n     * frequency term.\n     ",
      "vertexLabel": "MultiMatchQueryBuilder cutoffFrequency()"
    },
    {
      "vertexName": "Method static ActionListener<Response> wrap(Runnable runnable)  (ActionListener.java)",
      "comment": "\n     * Creates a listener that listens for a response (or failure) and executes the\n     * corresponding runnable when the response (or failure) is received.\n     *\n     * @param runnable the runnable that will be called in event of success or failure\n     * @param <Response> the type of the response\n     * @return a listener that listens for responses and invokes the runnable when received\n     ",
      "vertexLabel": "ActionListener<Response> wrap()"
    },
    {
      "vertexName": "Method public MatchQueryBuilder fuzziness(Object fuzziness)  (MatchQueryBuilder.java)",
      "comment": " Sets the fuzziness used when evaluated to a fuzzy query type. Defaults to \"AUTO\". ",
      "vertexLabel": "MatchQueryBuilder fuzziness()"
    },
    {
      "vertexName": "Method public static AllocateUnassignedDecision no(AllocationStatus allocationStatus, @Nullable List<NodeAllocationResult> decisions, boolean reuseStore)  (AllocateUnassignedDecision.java)",
      "children": [
        {
          "name": "Method public static AllocateUnassignedDecision no(AllocationStatus allocationStatus, @Nullable List<NodeAllocationResult> decisions)  (AllocateUnassignedDecision.java)"
        }
      ],
      "comment": "\n     * Returns a NO decision with the given {@link AllocationStatus}, and the individual node-level\n     * decisions that comprised the final NO decision if in explain mode.\n     ",
      "vertexLabel": "AllocateUnassignedDecision no()"
    },
    {
      "vertexName": "Method public GeoDistanceQueryBuilder ignoreUnmapped(boolean ignoreUnmapped)  (GeoDistanceQueryBuilder.java)",
      "children": [
        {
          "name": "Method public GeoBoundingBoxQueryBuilder ignoreUnmapped(boolean ignoreUnmapped)  (GeoBoundingBoxQueryBuilder.java)"
        }
      ],
      "comment": "\n     * Sets whether the query builder should ignore unmapped fields (and run a\n     * {@link MatchNoDocsQuery} in place of this query) or throw an exception if\n     * the field is unmapped.\n     ",
      "vertexLabel": "GeoDistanceQueryBuilder ignoreUnmapped()"
    },
    {
      "vertexName": "Method public SearchSourceBuilder fetchSource(@Nullable String include, @Nullable String exclude)  (SearchSourceBuilder.java)",
      "children": [
        {
          "name": "Method public SearchRequestBuilder setFetchSource(@Nullable String include, @Nullable String exclude)  (SearchRequestBuilder.java)"
        }
      ],
      "comment": "\n     * Indicate that _source should be returned with every hit, with an\n     * \"include\" and/or \"exclude\" set which can include simple wildcard\n     * elements.\n     *\n     * @param include\n     *            An optional include (optionally wildcarded) pattern to filter\n     *            the returned _source\n     * @param exclude\n     *            An optional exclude (optionally wildcarded) pattern to filter\n     *            the returned _source\n     ",
      "vertexLabel": "SearchSourceBuilder fetchSource()"
    },
    {
      "vertexName": "Method public static PreConfiguredTokenizer luceneVersion(String name, Function<org.apache.lucene.util.Version, Tokenizer> create, @Nullable Function<org.apache.lucene.util.Version, TokenFilterFactory> multiTermComponent)  (PreConfiguredTokenizer.java)",
      "children": [
        {
          "name": "Method public static PreConfiguredTokenizer singleton(String name, Supplier<Tokenizer> create, @Nullable Supplier<TokenFilterFactory> multiTermComponent)  (PreConfiguredTokenizer.java)"
        }
      ],
      "comment": "\n     * Create a pre-configured tokenizer that may vary based on the Lucene version.\n     * \n     * @param name the name of the tokenizer in the api\n     * @param create builds the tokenizer\n     * @param multiTermComponent null if this tokenizer shouldn't be used for multi-term queries, otherwise a supplier for the\n     *        {@link TokenFilterFactory} that stands in for this tokenizer in multi-term queries.\n     ",
      "vertexLabel": "PreConfiguredTokenizer luceneVersion()"
    },
    {
      "vertexName": "Method public RestoreSnapshotRequestBuilder setSettings(Map<String, Object> source)  (RestoreSnapshotRequestBuilder.java)",
      "children": [
        {
          "name": "Method public RestoreSnapshotRequest settings(Map<String, Object> source)  (RestoreSnapshotRequest.java)"
        }
      ],
      "comment": "\n     * Sets repository-specific restore settings\n     * <p>\n     * See repository documentation for more information.\n     *\n     * @param source repository-specific snapshot settings\n     * @return this builder\n     ",
      "vertexLabel": "RestoreSnapshotRequestBuilder setSettings()"
    },
    {
      "vertexName": "Method public UpdateRequest doc(Object... source)  (UpdateRequest.java)",
      "comment": "\n     * Sets the doc to use for updates when a script is not specified, the doc provided\n     * is a field and value pairs.\n     ",
      "vertexLabel": "UpdateRequest doc()"
    },
    {
      "vertexName": "Method public static int quadTreeLevelsForPrecision(double meters)  (GeoUtils.java)",
      "comment": "\n     * Calculate the number of levels needed for a specific precision. Quadtree\n     * cells will not exceed the specified size (diagonal) of the precision.\n     * @param meters Maximum size of cells in meters (must greater than zero)\n     * @return levels need to achieve precision\n     ",
      "vertexLabel": "int quadTreeLevelsForPrecision()"
    },
    {
      "vertexName": "Method public ClusterRerouteRequest dryRun(boolean dryRun)  (ClusterRerouteRequest.java)",
      "children": [
        {
          "name": "Method public boolean dryRun()  (ClusterRerouteRequest.java)"
        }
      ],
      "comment": "\n     * Sets a dry run flag (defaults to {@code false}) allowing to run the commands without\n     * actually applying them to the cluster state, and getting the resulting cluster state back.\n     ",
      "vertexLabel": "ClusterRerouteRequest dryRun()"
    },
    {
      "vertexName": "Method public CreateIndexRequest mapping(String type, Map<String, ?> source)  (CreateIndexRequest.java)",
      "children": [
        {
          "name": "Method public CreateIndexRequest mapping(String type, XContentBuilder source)  (CreateIndexRequest.java)"
        }
      ],
      "comment": "\n     * Adds mapping that will be added when the index gets created.\n     *\n     * @param type   The mapping type\n     * @param source The mapping source\n     ",
      "vertexLabel": "CreateIndexRequest mapping()"
    },
    {
      "vertexName": "Method protected final void consumeBucketsAndMaybeBreak(int count)  (BucketsAggregator.java)",
      "comment": "\n     * Adds {@code count} buckets to the global count for the request and fails if this number is greater than\n     * the maximum number of buckets allowed in a response\n     ",
      "vertexLabel": "final void consumeBucketsAndMaybeBreak()"
    },
    {
      "vertexName": "Method public boolean explicit()  (Explicit.java)",
      "comment": "\n     * \n     * @return true if the value passed is a conscious decision, false if using some kind of default\n     ",
      "vertexLabel": "boolean explicit()"
    },
    {
      "vertexName": "Method public GeoBoundingBoxQueryBuilder setCornersOGC(String bottomLeft, String topRight)  (GeoBoundingBoxQueryBuilder.java)",
      "comment": "\n     * Adds corners in OGC standard bbox/ envelop format.\n     *\n     * @param bottomLeft bottom left corner geohash.\n     * @param topRight top right corner geohash.\n     ",
      "vertexLabel": "GeoBoundingBoxQueryBuilder setCornersOGC()"
    },
    {
      "vertexName": "Method static ShapeBuilder parse(XContentParser parser) throws IOException  (ShapeParser.java)",
      "comment": "\n     * Create a new {@link ShapeBuilder} from {@link XContent}\n     * @param parser parser to read the GeoShape from\n     * @return {@link ShapeBuilder} read from the parser or null\n     *          if the parsers current token has been <code>null</code>\n     * @throws IOException if the input could not be read\n     ",
      "vertexLabel": "ShapeBuilder parse()"
    },
    {
      "vertexName": "Method public ClusterSearchShardsRequest routing(String routing)  (ClusterSearchShardsRequest.java)",
      "children": [
        {
          "name": "Method public SearchRequestBuilder setRouting(String routing)  (SearchRequestBuilder.java)"
        }
      ],
      "comment": "\n     * A comma separated list of routing values to control the shards the search will be executed on.\n     ",
      "vertexLabel": "ClusterSearchShardsRequest routing()"
    },
    {
      "vertexName": "Method public static void removeThreadContext(ThreadContext threadContext)  (DeprecationLogger.java)",
      "children": [
        {
          "name": "Method public static void setThreadContext(ThreadContext threadContext)  (DeprecationLogger.java)"
        }
      ],
      "comment": "\n     * Remove the {@link ThreadContext} used to add deprecation headers to network responses.\n     * <p>\n     * This is expected to <em>only</em> be invoked by the {@code Node}'s {@code close} method (therefore once outside of tests).\n     *\n     * @param threadContext The thread context owned by the {@code ThreadPool} (and implicitly a {@code Node})\n     * @throws IllegalStateException if this {@code threadContext} is unknown (and presumably already unset before)\n     ",
      "vertexLabel": "void removeThreadContext()"
    },
    {
      "vertexName": "Method public AggregationSpec(String name, Writeable.Reader<? extends AggregationBuilder> reader, Aggregator.Parser parser)  (SearchPlugin.java)",
      "children": [
        {
          "name": "Method public QuerySpec(String name, Writeable.Reader<T> reader, QueryParser<T> parser)  (SearchPlugin.java)"
        }
      ],
      "comment": "\n         * Specification for an {@link Aggregation}.\n         *\n         * @param name the name by which this aggregation might be parsed or deserialized. Make sure that the {@link AggregationBuilder}\n         *        returns this from {@link NamedWriteable#getWriteableName()}.\n         * @param reader the reader registered for this aggregation's builder. Typically a reference to a constructor that takes a\n         *        {@link StreamInput}\n         * @param parser the parser the reads the aggregation builder from xcontent\n         ",
      "vertexLabel": "AggregationSpec()"
    },
    {
      "vertexName": "Method public static StoredScriptSource fromXContent(XContentParser parser, boolean ignoreEmpty)  (StoredScriptSource.java)",
      "children": [
        {
          "name": "Method public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException  (StoredScriptSource.java)"
        },
        {
          "name": "Method private StoredScriptSource build(boolean ignoreEmpty)  (StoredScriptSource.java)"
        }
      ],
      "comment": "\n     * This will parse XContent into a {@link StoredScriptSource}. The following format is what will be parsed:\n     *\n     * {@code\n     * {\n     *     \"script\" : {\n     *         \"lang\" : \"<lang>\",\n     *         \"source\" : \"<source>\",\n     *         \"options\" : {\n     *             \"option0\" : \"<option0>\",\n     *             \"option1\" : \"<option1>\",\n     *             ...\n     *         }\n     *     }\n     * }\n     * }\n     *\n     * Note that the \"source\" parameter can also handle template parsing including from\n     * a complex JSON object.\n     *\n     * @param ignoreEmpty Specify as {@code true} to ignoreEmpty the empty source check.\n     *                    This allows empty templates to be loaded for backwards compatibility.\n     ",
      "vertexLabel": "StoredScriptSource fromXContent()"
    },
    {
      "vertexName": "Method public BlockingClusterStatePublishResponseHandler(Set<DiscoveryNode> publishingToNodes)  (BlockingClusterStatePublishResponseHandler.java)",
      "comment": "\n     * Creates a new BlockingClusterStatePublishResponseHandler\n     * @param publishingToNodes the set of nodes to which the cluster state will be published and should respond\n     ",
      "vertexLabel": "BlockingClusterStatePublishResponseHandler()"
    },
    {
      "vertexName": "Method public CreateSnapshotRequest indices(String... indices)  (CreateSnapshotRequest.java)",
      "comment": "\n     * Sets a list of indices that should be included into the snapshot\n     * <p>\n     * The list of indices supports multi-index syntax. For example: \"+test*\" ,\"-test42\" will index all indices with\n     * prefix \"test\" except index \"test42\". Aliases are supported. An empty list or {\"_all\"} will snapshot all open\n     * indices in the cluster.\n     *\n     * @return this request\n     ",
      "vertexLabel": "CreateSnapshotRequest indices()"
    },
    {
      "vertexName": "Method public Setting(Key key, Function<Settings, String> defaultValue, Function<String, T> parser, Validator<T> validator, Property... properties)  (Setting.java)",
      "children": [
        {
          "name": "Method public Setting(Key key, Function<Settings, String> defaultValue, Function<String, T> parser, Property... properties)  (Setting.java)"
        }
      ],
      "comment": "\n     * Creates a new {@code Setting} instance.\n     *\n     * @param key          the settings key for this setting\n     * @param defaultValue a default value function that results a string representation of the default value\n     * @param parser       a parser that parses a string representation into the concrete type for this setting\n     * @param validator    a {@link Validator} for validating this setting\n     * @param properties   properties for this setting\n     ",
      "vertexLabel": "Setting()"
    },
    {
      "vertexName": "Method public int maxConcurrentSearchRequests()  (MultiSearchRequest.java)",
      "children": [
        {
          "name": "Method public MultiSearchRequest maxConcurrentSearchRequests(int maxConcurrentSearchRequests)  (MultiSearchRequest.java)"
        }
      ],
      "comment": "\n     * Returns the amount of search requests specified in this multi search requests are allowed to be ran concurrently.\n     ",
      "vertexLabel": "int maxConcurrentSearchRequests()"
    },
    {
      "vertexName": "Method public IndicesStatsRequestBuilder setTypes(String... types)  (IndicesStatsRequestBuilder.java)",
      "children": [
        {
          "name": "Method public IndicesStatsRequest types(String... types)  (IndicesStatsRequest.java)"
        }
      ],
      "comment": "\n     * Document types to return stats for. Mainly affects {@link #setIndexing(boolean)} when\n     * enabled, returning specific indexing stats for those types.\n     ",
      "vertexLabel": "IndicesStatsRequestBuilder setTypes()"
    },
    {
      "vertexName": "Method public static Integer readIntProperty(String processorType, String processorTag, Map<String, Object> configuration, String propertyName, Integer defaultValue)  (ConfigurationUtils.java)",
      "children": [
        {
          "name": "Method public static String readOptionalStringOrIntProperty(String processorType, String processorTag, Map<String, Object> configuration, String propertyName)  (ConfigurationUtils.java)"
        }
      ],
      "comment": "\n     * Returns and removes the specified property from the specified configuration map.\n     *\n     * If the property value isn't of type int a {@link ElasticsearchParseException} is thrown.\n     * If the property is missing an {@link ElasticsearchParseException} is thrown\n     ",
      "vertexLabel": "Integer readIntProperty()"
    },
    {
      "vertexName": "Method public TermsQueryBuilder(String fieldName, Object... values)  (TermsQueryBuilder.java)",
      "children": [
        {
          "name": "Method public TermsQueryBuilder(String fieldName, String... values)  (TermsQueryBuilder.java)"
        }
      ],
      "comment": "\n     * A filter for a field based on several terms matching on any of them.\n     *\n     * @param fieldName The field name\n     * @param values The terms\n     ",
      "vertexLabel": "TermsQueryBuilder()"
    },
    {
      "vertexName": "Method public RestoreSnapshotRequestBuilder setSettings(Settings.Builder settings)  (RestoreSnapshotRequestBuilder.java)",
      "children": [
        {
          "name": "Method public RestoreSnapshotRequestBuilder setSettings(Settings settings)  (RestoreSnapshotRequestBuilder.java)"
        }
      ],
      "comment": "\n     * Sets repository-specific restore settings.\n     * <p>\n     * See repository documentation for more information.\n     *\n     * @param settings repository-specific snapshot settings\n     * @return this builder\n     ",
      "vertexLabel": "RestoreSnapshotRequestBuilder setSettings()"
    },
    {
      "vertexName": "Method public SignificanceHeuristic rewrite(SearchContext context)  (SignificanceHeuristic.java)",
      "comment": "\n     * Provides a hook for subclasses to provide a version of the heuristic\n     * prepared for execution on data on a shard. \n     * @param context the search context on the data node\n     * @return a version of this heuristic suitable for execution\n     ",
      "vertexLabel": "SignificanceHeuristic rewrite()"
    },
    {
      "vertexName": "Method boolean addConsoleCtrlHandler(ConsoleCtrlHandler handler)  (JNAKernel32Library.java)",
      "comment": "\n     * Adds a Console Ctrl Handler.\n     *\n     * @return true if the handler is correctly set\n     * @throws java.lang.UnsatisfiedLinkError if the Kernel32 library is not loaded or if the native function is not found\n     * @throws java.lang.NoClassDefFoundError if the library for native calls is missing\n     ",
      "vertexLabel": "boolean addConsoleCtrlHandler()"
    },
    {
      "vertexName": "Method public AB subAggregations(AggregatorFactories.Builder subFactories)  (AbstractAggregationBuilder.java)",
      "comment": "\n     * Registers sub-factories with this factory. The sub-factory will be\n     * responsible for the creation of sub-aggregators under the aggregator\n     * created by this factory.\n     *\n     * @param subFactories\n     *            The sub-factories\n     * @return this factory (fluent interface)\n     ",
      "vertexLabel": "AB subAggregations()"
    },
    {
      "vertexName": "Method public SimpleQueryStringBuilder fuzzyTranspositions(boolean fuzzyTranspositions)  (SimpleQueryStringBuilder.java)",
      "children": [
        {
          "name": "Method public MatchQueryBuilder fuzzyTranspositions(boolean fuzzyTranspositions)  (MatchQueryBuilder.java)"
        }
      ],
      "comment": "\n     * Sets whether transpositions are supported in fuzzy queries.<p>\n     * The default metric used by fuzzy queries to determine a match is the Damerau-Levenshtein\n     * distance formula which supports transpositions. Setting transposition to false will\n     * switch to classic Levenshtein distance.<br>\n     * If not set, Damerau-Levenshtein distance metric will be used.\n     ",
      "vertexLabel": "SimpleQueryStringBuilder fuzzyTranspositions()"
    },
    {
      "vertexName": "Method public TopHitsAggregationBuilder storedField(String field)  (TopHitsAggregationBuilder.java)",
      "children": [
        {
          "name": "Method public SearchRequestBuilder storedFields(String... fields)  (SearchRequestBuilder.java)"
        }
      ],
      "comment": "\n     * Adds a stored field to load and return (note, it must be stored) as part of the search request.\n     * To disable the stored fields entirely (source and metadata fields) use {@code storedField(\"_none_\")}.\n     ",
      "vertexLabel": "TopHitsAggregationBuilder storedField()"
    },
    {
      "vertexName": "Method B setRefreshPolicy(RefreshPolicy refreshPolicy)  (WriteRequestBuilder.java)",
      "children": [
        {
          "name": "Method R setRefreshPolicy(RefreshPolicy refreshPolicy)  (WriteRequest.java)"
        }
      ],
      "comment": "\n     * Should this request trigger a refresh ({@linkplain RefreshPolicy#IMMEDIATE}), wait for a refresh (\n     * {@linkplain RefreshPolicy#WAIT_UNTIL}), or proceed ignore refreshes entirely ({@linkplain RefreshPolicy#NONE}, the default).\n     ",
      "vertexLabel": "B setRefreshPolicy()"
    },
    {
      "vertexName": "Method public SnapshotsStatusRequestBuilder setIgnoreUnavailable(boolean ignoreUnavailable)  (SnapshotsStatusRequestBuilder.java)",
      "children": [
        {
          "name": "Method public SnapshotsStatusRequest ignoreUnavailable(boolean ignoreUnavailable)  (SnapshotsStatusRequest.java)"
        }
      ],
      "comment": "\n     * Set to <code>true</code> to ignore unavailable snapshots, instead of throwing an exception.\n     * Defaults to <code>false</code>, which means unavailable snapshots cause an exception to be thrown.\n     *\n     * @param ignoreUnavailable whether to ignore unavailable snapshots.\n     * @return this builder\n     ",
      "vertexLabel": "SnapshotsStatusRequestBuilder setIgnoreUnavailable()"
    },
    {
      "vertexName": "Method private Map<String, String> getControlGroups() throws IOException  (OsProbe.java)",
      "children": [
        {
          "name": "Method private long getCgroupCpuAcctUsageNanos(final String controlGroup) throws IOException  (OsProbe.java)"
        }
      ],
      "comment": "\n     * A map of the control groups to which the Elasticsearch process belongs. Note that this is a map because the control groups can vary\n     * from subsystem to subsystem. Additionally, this map can not be cached because a running process can be reclassified.\n     *\n     * @return a map from subsystems to the control group for the Elasticsearch process.\n     * @throws IOException if an I/O exception occurs reading {@code /proc/self/cgroup}\n     ",
      "vertexLabel": "Map<String, String> getControlGroups()"
    },
    {
      "vertexName": "Method void onResponseSent(long requestId, String action, TransportResponse response, TransportResponseOptions finalOptions)  (TransportMessageListener.java)",
      "children": [
        {
          "name": "Method void onResponseSent(long requestId, String action, Exception error)  (TransportMessageListener.java)"
        }
      ],
      "comment": "\n     * Called for every action response sent after the response has been passed to the underlying network implementation.\n     * @param requestId the request ID (unique per client)\n     * @param action the request action\n     * @param response the response send\n     * @param finalOptions the response options\n     ",
      "vertexLabel": "void onResponseSent()"
    },
    {
      "vertexName": "Method public ClusterUpdateSettingsRequestBuilder setPersistentSettings(String settings, XContentType xContentType)  (ClusterUpdateSettingsRequestBuilder.java)",
      "children": [
        {
          "name": "Method public ClusterUpdateSettingsRequest persistentSettings(String source, XContentType xContentType)  (ClusterUpdateSettingsRequest.java)"
        }
      ],
      "comment": "\n     * Sets the source containing the persistent settings to be updated. They will get applied cross restarts\n     ",
      "vertexLabel": "ClusterUpdateSettingsRequestBuilder setPersistentSettings()"
    },
    {
      "vertexName": "Method public SignificantTextAggregationBuilder minDocCount(long minDocCount)  (SignificantTextAggregationBuilder.java)",
      "children": [
        {
          "name": "Method public TermsAggregationBuilder minDocCount(long minDocCount)  (TermsAggregationBuilder.java)"
        }
      ],
      "comment": "\n     * Set the minimum document count terms should have in order to appear in\n     * the response.\n     ",
      "vertexLabel": "SignificantTextAggregationBuilder minDocCount()"
    },
    {
      "vertexName": "Method public int getMaxNumTokensParsed()  (XMoreLikeThis.java)",
      "children": [
        {
          "name": "Method public void setMaxNumTokensParsed(int i)  (XMoreLikeThis.java)"
        }
      ],
      "comment": "\n     * @return The maximum number of tokens to parse in each example doc field that is not stored with TermVector support\n     * @see #DEFAULT_MAX_NUM_TOKENS_PARSED\n     ",
      "vertexLabel": "int getMaxNumTokensParsed()"
    },
    {
      "vertexName": "Method void pendingClusterTasks(PendingClusterTasksRequest request, ActionListener<PendingClusterTasksResponse> listener)  (ClusterAdminClient.java)",
      "comment": "\n     * Returns a list of the pending cluster tasks, that are scheduled to be executed. This includes operations\n     * that update the cluster state (for example, a create index operation)\n     ",
      "vertexLabel": "void pendingClusterTasks()"
    },
    {
      "vertexName": "Method public SignificantTextAggregationBuilder shardMinDocCount(long shardMinDocCount)  (SignificantTextAggregationBuilder.java)",
      "children": [
        {
          "name": "Method public TermsAggregationBuilder shardMinDocCount(long shardMinDocCount)  (TermsAggregationBuilder.java)"
        }
      ],
      "comment": "\n     * Set the minimum document count terms should have on the shard in order to\n     * appear in the response.\n     ",
      "vertexLabel": "SignificantTextAggregationBuilder shardMinDocCount()"
    },
    {
      "vertexName": "Method public UpdateRequest doc(XContentType xContentType, Object... source)  (UpdateRequest.java)",
      "children": [
        {
          "name": "Method public UpdateRequest doc(Object... source)  (UpdateRequest.java)"
        }
      ],
      "comment": "\n     * Sets the doc to use for updates when a script is not specified, the doc provided\n     * is a field and value pairs.\n     ",
      "vertexLabel": "UpdateRequest doc()"
    },
    {
      "vertexName": "Method public BytesReference getResponse()  (TaskResult.java)",
      "children": [
        {
          "name": "Method public BytesReference getError()  (TaskResult.java)"
        }
      ],
      "comment": "\n     * Get the response that this task finished with. Will return null if the task was finished by an error, it hasn't yet finished, or\n     * didn't store its result.\n     ",
      "vertexLabel": "BytesReference getResponse()"
    },
    {
      "vertexName": "Method public Double getAsDouble(String setting, Double defaultValue)  (Settings.java)",
      "children": [
        {
          "name": "Method public Integer getAsInt(String setting, Integer defaultValue)  (Settings.java)"
        }
      ],
      "comment": "\n     * Returns the setting value (as double) associated with the setting key. If it does not exists,\n     * returns the default value provided.\n     ",
      "vertexLabel": "Double getAsDouble()"
    },
    {
      "vertexName": "Method public synchronized long getTranslogGenerationOfLastCommit()  (TranslogDeletionPolicy.java)",
      "children": [
        {
          "name": "Field translogGenerationOfLastCommit  (TranslogDeletionPolicy.java)"
        }
      ],
      "comment": "\n     * Returns a translog generation that will be used to calculate the number of uncommitted operations since the last index commit.\n     ",
      "vertexLabel": "synchronized long getTranslogGenerationOfLastCommit()"
    },
    {
      "vertexName": "Field beta  (HoltWintersModel.java)",
      "children": [
        {
          "name": "Field beta  (HoltLinearModel.java)"
        }
      ],
      "comment": "\n     * Controls smoothing of trend.\n     * Beta = 1 retains no memory of past values\n     * (e.g. random walk), while alpha = 0 retains infinite memory of past values (e.g.\n     * mean of the series).\n     ",
      "vertexLabel": "Field beta"
    },
    {
      "vertexName": "Method public HighlightBuilder field(String name, int fragmentSize, int numberOfFragments, int fragmentOffset)  (HighlightBuilder.java)",
      "children": [
        {
          "name": "Method public HighlightBuilder field(String name, int fragmentSize, int numberOfFragments)  (HighlightBuilder.java)"
        }
      ],
      "comment": "\n     * Adds a field to be highlighted with a provided fragment size (in characters), and\n     * a provided (maximum) number of fragments.\n     *\n     * @param name              The field to highlight\n     * @param fragmentSize      The size of a fragment in characters\n     * @param numberOfFragments The (maximum) number of fragments\n     * @param fragmentOffset    The offset from the start of the fragment to the start of the highlight\n     ",
      "vertexLabel": "HighlightBuilder field()"
    },
    {
      "vertexName": "Method public int maxExpansions()  (MatchQueryBuilder.java)",
      "comment": "\n     * Get the (optional) number of term expansions when using fuzzy or prefix type query.\n     ",
      "vertexLabel": "int maxExpansions()"
    },
    {
      "vertexName": "Class BoostingQueryBuilder  (BoostingQueryBuilder.java)",
      "children": [
        {
          "name": "Method public static BoostingQueryBuilder boostingQuery(QueryBuilder positiveQuery, QueryBuilder negativeQuery)  (QueryBuilders.java)"
        }
      ],
      "comment": "\n * The BoostingQuery class can be used to effectively demote results that match a given query.\n * Unlike the \"NOT\" clause, this still selects documents that contain undesirable terms,\n * but reduces their overall score:\n * <p>\n * Query balancedQuery = new BoostingQuery(positiveQuery, negativeQuery, 0.01f);\n * In this scenario the positiveQuery contains the mandatory, desirable criteria which is used to\n * select all matching documents, and the negativeQuery contains the undesirable elements which\n * are simply used to lessen the scores. Documents that match the negativeQuery have their score\n * multiplied by the supplied \"boost\" parameter, so this should be less than 1 to achieve a\n * demoting effect\n ",
      "vertexLabel": "Class BoostingQueryBuilder"
    },
    {
      "vertexName": "Method public Translog.Snapshot getHistoryOperations(String source, long startingSeqNo) throws IOException  (IndexShard.java)",
      "children": [
        {
          "name": "Method public Translog.Snapshot readHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException  (InternalEngine.java)"
        }
      ],
      "comment": "\n     * Creates a new history snapshot for reading operations since the provided starting seqno (inclusive).\n     * The returned snapshot can be retrieved from either Lucene index or translog files.\n     ",
      "vertexLabel": "Translog.Snapshot getHistoryOperations()"
    },
    {
      "vertexName": "Method public final void incRef()  (Store.java)",
      "comment": "\n     * Increments the refCount of this Store instance.  RefCounts are used to determine when a\n     * Store can be closed safely, i.e. as soon as there are no more references. Be sure to always call a\n     * corresponding {@link #decRef}, in a finally clause; otherwise the store may never be closed.  Note that\n     * {@link #close} simply calls decRef(), which means that the Store will not really be closed until {@link\n     * #decRef} has been called for all outstanding references.\n     * <p>\n     * Note: Close can safely be called multiple times.\n     *\n     * @throws AlreadyClosedException iff the reference counter can not be incremented.\n     * @see #decRef\n     * @see #tryIncRef()\n     ",
      "vertexLabel": "final void incRef()"
    },
    {
      "vertexName": "Method void clearCache(ClearIndicesCacheRequest request, ActionListener<ClearIndicesCacheResponse> listener)  (IndicesAdminClient.java)",
      "children": [
        {
          "name": "Method ActionFuture<ClearIndicesCacheResponse> clearCache(ClearIndicesCacheRequest request)  (IndicesAdminClient.java)"
        }
      ],
      "comment": "\n     * Clear indices cache.\n     *\n     * @param request  The clear indices cache request\n     * @param listener A listener to be notified with a result\n     * @see Requests#clearIndicesCacheRequest(String...)\n     ",
      "vertexLabel": "void clearCache()"
    },
    {
      "vertexName": "Method public static boolean terminate(ExecutorService service, long timeout, TimeUnit timeUnit)  (ThreadPool.java)",
      "children": [
        {
          "name": "Method public static boolean terminate(ThreadPool pool, long timeout, TimeUnit timeUnit)  (ThreadPool.java)"
        }
      ],
      "comment": "\n     * Returns <code>true</code> if the given service was terminated successfully. If the termination timed out,\n     * the service is <code>null</code> this method will return <code>false</code>.\n     ",
      "vertexLabel": "boolean terminate()"
    },
    {
      "vertexName": "Method public int getNumReducePhases()  (SearchResponse.java)",
      "comment": "\n     * Returns the number of reduce phases applied to obtain this search response\n     ",
      "vertexLabel": "int getNumReducePhases()"
    },
    {
      "vertexName": "Field MAX_INNER_RESULT_WINDOW_SETTING  (IndexSettings.java)",
      "children": [
        {
          "name": "Field MAX_DOCVALUE_FIELDS_SEARCH_SETTING  (IndexSettings.java)"
        }
      ],
      "comment": "\n     * Index setting describing the maximum value of from + size on an individual inner hit definition or\n     * top hits aggregation. The default maximum of 100 is defensive for the reason that the number of inner hit responses\n     * and number of top hits buckets returned is unbounded. Profile your cluster when increasing this setting.\n     ",
      "vertexLabel": "Field MAX_INNER_RESULT_WINDOW_SETTING"
    },
    {
      "vertexName": "Method public ShardRouting initializeShard(ShardRouting unassignedShard, String nodeId, @Nullable String existingAllocationId, long expectedSize, RoutingChangesObserver routingChangesObserver)  (RoutingNodes.java)",
      "children": [
        {
          "name": "Method public ShardRouting initialize(String nodeId, @Nullable String existingAllocationId, long expectedShardSize)  (ShardRouting.java)"
        }
      ],
      "comment": "\n     * Moves a shard from unassigned to initialize state\n     *\n     * @param existingAllocationId allocation id to use. If null, a fresh allocation id is generated.\n     * @return                     the initialized shard\n     ",
      "vertexLabel": "ShardRouting initializeShard()"
    },
    {
      "vertexName": "Method public void registerRequestHandler(String action, String executor, Writeable.Reader<Request> requestReader, TransportRequestHandler<Request> handler)  (TransportService.java)",
      "children": [
        {
          "name": "Method public void registerRequestHandler(String action, Supplier<Request> requestFactory, String executor, TransportRequestHandler<Request> handler)  (TransportService.java)"
        }
      ],
      "comment": "\n     * Registers a new request handler\n     *\n     * @param action         The action the request handler is associated with\n     * @param requestReader  a callable to be used construct new instances for streaming\n     * @param executor       The executor the request handling will be executed on\n     * @param handler        The handler itself that implements the request handling\n     ",
      "vertexLabel": "void registerRequestHandler()"
    },
    {
      "vertexName": "Method public static IndicesOptions strictExpandOpen()  (IndicesOptions.java)",
      "children": [
        {
          "name": "Method public static IndicesOptions lenientExpandOpen()  (IndicesOptions.java)"
        }
      ],
      "comment": "\n     * @return indices options that requires every specified index to exist, expands wildcards only to open indices and\n     *         allows that no indices are resolved from wildcard expressions (not returning an error).\n     ",
      "vertexLabel": "IndicesOptions strictExpandOpen()"
    },
    {
      "vertexName": "Method private static Distribution parseDistribution(Settings settings)  (SimilarityProviders.java)",
      "children": [
        {
          "name": "Method private static Lambda parseLambda(Settings settings)  (SimilarityProviders.java)"
        }
      ],
      "comment": "\n     * Parses the given Settings and creates the appropriate {@link Distribution}\n     *\n     * @param settings Settings to parse\n     * @return {@link Normalization} referred to in the Settings\n     ",
      "vertexLabel": "Distribution parseDistribution()"
    },
    {
      "vertexName": "Method public BulkRequestBuilder setWaitForActiveShards(ActiveShardCount waitForActiveShards)  (BulkRequestBuilder.java)",
      "children": [
        {
          "name": "Method public BulkRequest waitForActiveShards(ActiveShardCount waitForActiveShards)  (BulkRequest.java)"
        }
      ],
      "comment": "\n     * Sets the number of shard copies that must be active before proceeding with the write.\n     * See {@link ReplicationRequest#waitForActiveShards(ActiveShardCount)} for details.\n     ",
      "vertexLabel": "BulkRequestBuilder setWaitForActiveShards()"
    },
    {
      "vertexName": "Interface ProviderKeyBinding  (ProviderKeyBinding.java)",
      "comment": "\n * A binding to a provider key. To resolve injections, the provider key is first resolved, then that\n * provider's {@code get} method is invoked.\n *\n * @author jessewilson@google.com (Jesse Wilson)\n * @since 2.0\n ",
      "vertexLabel": "Interface ProviderKeyBinding"
    },
    {
      "vertexName": "Method void upgradeStatus(UpgradeStatusRequest request, ActionListener<UpgradeStatusResponse> listener)  (IndicesAdminClient.java)",
      "children": [
        {
          "name": "Method void upgrade(UpgradeRequest request, ActionListener<UpgradeResponse> listener)  (IndicesAdminClient.java)"
        }
      ],
      "comment": "\n     * Check upgrade status of one or more indices\n     *\n     * @param request  The upgrade request\n     * @param listener A listener to be notified with a result\n     * @see org.elasticsearch.client.Requests#upgradeRequest(String...)\n     ",
      "vertexLabel": "void upgradeStatus()"
    },
    {
      "vertexName": "Method public void updateGlobalCheckpointForShard(final String allocationId, final long globalCheckpoint)  (IndexShard.java)",
      "children": [
        {
          "name": "Method public synchronized void updateGlobalCheckpointForShard(final String allocationId, final long globalCheckpoint)  (ReplicationTracker.java)"
        }
      ],
      "comment": "\n     * Update the local knowledge of the global checkpoint for the specified allocation ID.\n     *\n     * @param allocationId     the allocation ID to update the global checkpoint for\n     * @param globalCheckpoint the global checkpoint\n     ",
      "vertexLabel": "void updateGlobalCheckpointForShard()"
    },
    {
      "vertexName": "Method public TermVectorsRequestBuilder setPreference(String preference)  (TermVectorsRequestBuilder.java)",
      "children": [
        {
          "name": "Method public MultiGetRequest preference(String preference)  (MultiGetRequest.java)"
        }
      ],
      "comment": "\n     * Sets the preference to execute the search. Defaults to randomize across shards. Can be set to\n     * {@code _local} to prefer local shards or a custom value, which guarantees that the same order\n     * will be used across different requests.\n     ",
      "vertexLabel": "TermVectorsRequestBuilder setPreference()"
    },
    {
      "vertexName": "Method public MatchQueryBuilder cutoffFrequency(float cutoff)  (MatchQueryBuilder.java)",
      "comment": "\n     * Set a cutoff value in [0..1] (or absolute number &gt;=1) representing the\n     * maximum threshold of a terms document frequency to be considered a low\n     * frequency term.\n     ",
      "vertexLabel": "MatchQueryBuilder cutoffFrequency()"
    },
    {
      "vertexName": "Method public ByteSizeValue getAsMemory(String setting, String defaultValue) throws SettingsException  (Settings.java)",
      "children": [
        {
          "name": "Method public RatioValue getAsRatio(String setting, String defaultValue) throws SettingsException  (Settings.java)"
        }
      ],
      "comment": "\n     * Returns the setting value (as size) associated with the setting key. Provided values can either be\n     * absolute values (interpreted as a number of bytes), byte sizes (eg. 1mb) or percentage of the heap size\n     * (eg. 12%). If it does not exists, parses the default value provided.\n     ",
      "vertexLabel": "ByteSizeValue getAsMemory()"
    },
    {
      "vertexName": "Field API_AND_SNAPSHOT  (MetaData.java)",
      "children": [
        {
          "name": "Field ALL_CONTEXTS  (MetaData.java)"
        }
      ],
      "comment": "\n     * Indicates that this custom metadata will be returned as part of an API call and stored as a part of\n     * a snapshot global state, but will not be persisted between node restarts\n     ",
      "vertexLabel": "Field API_AND_SNAPSHOT"
    },
    {
      "vertexName": "Method protected RerouteExplanation explainOrThrowRejectedCommand(boolean explain, RoutingAllocation allocation, String reason)  (AbstractAllocateAllocationCommand.java)",
      "comment": "\n     * Utility method for rejecting the current allocation command based on provided reason\n     ",
      "vertexLabel": "RerouteExplanation explainOrThrowRejectedCommand()"
    },
    {
      "vertexName": "Method public Version getMaxNodeVersion()  (DiscoveryNodes.java)",
      "comment": "\n     * Returns the version of the node with the youngest version in the cluster\n     *\n     * @return the youngest version in the cluster\n     ",
      "vertexLabel": "Version getMaxNodeVersion()"
    },
    {
      "vertexName": "Method public void appendFieldValue(TemplateScript.Factory fieldPathTemplate, ValueSource valueSource)  (IngestDocument.java)",
      "children": [
        {
          "name": "Method public void appendFieldValue(String path, Object value)  (IngestDocument.java)"
        },
        {
          "name": "Method public void setFieldValue(TemplateScript.Factory fieldPathTemplate, ValueSource valueSource)  (IngestDocument.java)"
        }
      ],
      "comment": "\n     * Appends the provided value to the provided path in the document.\n     * Any non existing path element will be created.\n     * If the path identifies a list, the value will be appended to the existing list.\n     * If the path identifies a scalar, the scalar will be converted to a list and\n     * the provided value will be added to the newly created list.\n     * Supports multiple values too provided in forms of list, in that case all the values will be appended to the\n     * existing (or newly created) list.\n     * @param fieldPathTemplate Resolves to the path with dot-notation within the document\n     * @param valueSource The value source that will produce the value or values to append to the existing ones\n     * @throws IllegalArgumentException if the path is null, empty or invalid.\n     ",
      "vertexLabel": "void appendFieldValue()"
    },
    {
      "vertexName": "Method protected double[] doPredict(Collection<Double> values, int numPredictions)  (HoltWintersModel.java)",
      "children": [
        {
          "name": "Method protected double[] doPredict(Collection<Double> values, int numPredictions)  (HoltLinearModel.java)"
        }
      ],
      "comment": "\n     * Predicts the next `n` values in the series, using the smoothing model to generate new values.\n     * Unlike the other moving averages, HoltWinters has forecasting/prediction built into the algorithm.\n     * Prediction is more than simply adding the next prediction to the window and repeating.  HoltWinters\n     * will extrapolate into the future by applying the trend and seasonal information to the smoothed data.\n     *\n     * @param values            Collection of numerics to movingAvg, usually windowed\n     * @param numPredictions    Number of newly generated predictions to return\n     * @return                  Returns an array of doubles, since most smoothing methods operate on floating points\n     ",
      "vertexLabel": "double[] doPredict()"
    },
    {
      "vertexName": "Method public static double geoHashCellHeight(int level)  (GeoUtils.java)",
      "children": [
        {
          "name": "Method public static double geoHashCellSize(int level)  (GeoUtils.java)"
        }
      ],
      "comment": "\n     * Calculate the height (in meters) of geohash cells at a specific level\n     * @param level geohash level must be greater or equal to zero\n     * @return the height of cells at level in meters\n     ",
      "vertexLabel": "double geoHashCellHeight()"
    },
    {
      "vertexName": "Method public ResizeRequestBuilder setWaitForActiveShards(final int waitForActiveShards)  (ResizeRequestBuilder.java)",
      "children": [
        {
          "name": "Method public BulkRequest waitForActiveShards(final int waitForActiveShards)  (BulkRequest.java)"
        }
      ],
      "comment": "\n     * A shortcut for {@link #setWaitForActiveShards(ActiveShardCount)} where the numerical\n     * shard count is passed in, instead of having to first call {@link ActiveShardCount#from(int)}\n     * to get the ActiveShardCount.\n     ",
      "vertexLabel": "ResizeRequestBuilder setWaitForActiveShards()"
    },
    {
      "vertexName": "Method public Set<InjectionPoint> getInjectionPoints() throws ConfigurationException  (StaticInjectionRequest.java)",
      "children": [
        {
          "name": "Method public static Set<InjectionPoint> forStaticMethodsAndFields(TypeLiteral type)  (InjectionPoint.java)"
        }
      ],
      "comment": "\n     * Returns the static methods and fields of {@code type} that will be injected to fulfill this\n     * request.\n     *\n     * @return a possibly empty set of injection points. The set has a specified iteration order. All\n     *         fields are returned and then all methods. Within the fields, supertype fields are returned\n     *         before subtype fields. Similarly, supertype methods are returned before subtype methods.\n     * @throws ConfigurationException if there is a malformed injection point on {@code type}, such as\n     *                                a field with multiple binding annotations. The exception's {@link\n     *                                ConfigurationException#getPartialValue() partial value} is a {@code Set<InjectionPoint>}\n     *                                of the valid injection points.\n     ",
      "vertexLabel": "Set<InjectionPoint> getInjectionPoints()"
    },
    {
      "vertexName": "Method public static double sum(double[] values)  (MovingFunctions.java)",
      "comment": "\n     * Find the sum of a window of values\n     * If all values are missing/null/NaN, the return value will be 0.0\n     ",
      "vertexLabel": "double sum()"
    },
    {
      "vertexName": "Method protected abstract ClusterBlockException checkGlobalBlock(ClusterState state, Request request)  (TransportBroadcastByNodeAction.java)",
      "comment": "\n     * Executes a global block check before polling the cluster state.\n     *\n     * @param state   the cluster state\n     * @param request the underlying request\n     * @return a non-null exception if the operation is blocked\n     ",
      "vertexLabel": "abstract ClusterBlockException checkGlobalBlock()"
    },
    {
      "vertexName": "Method native boolean AssignProcessToJobObject(Pointer job, Pointer process)  (JNAKernel32Library.java)",
      "comment": "\n     * Associates a process with an existing job\n     *\n     * https://msdn.microsoft.com/en-us/library/windows/desktop/ms681949%28v=vs.85%29.aspx\n     *\n     * @param job job handle\n     * @param process process handle\n     * @return true if the function succeeds\n     ",
      "vertexLabel": "native boolean AssignProcessToJobObject()"
    },
    {
      "vertexName": "Method void flush(FlushRequest request, ActionListener<FlushResponse> listener)  (IndicesAdminClient.java)",
      "children": [
        {
          "name": "Method ActionFuture<FlushResponse> flush(FlushRequest request)  (IndicesAdminClient.java)"
        }
      ],
      "comment": "\n     * Explicitly flush one or more indices (releasing memory from the node).\n     *\n     * @param request  The flush request\n     * @param listener A listener to be notified with a result\n     * @see org.elasticsearch.client.Requests#flushRequest(String...)\n     ",
      "vertexLabel": "void flush()"
    },
    {
      "vertexName": "Field fieldsAndWeights  (QueryStringQueryBuilder.java)",
      "children": [
        {
          "name": "Field fieldsAndWeights  (SimpleQueryStringBuilder.java)"
        }
      ],
      "comment": "\n     * Fields to query against. If left empty will query default field,\n     * currently _ALL. Uses a TreeMap to hold the fields so boolean clauses are\n     * always sorted in same order for generated Lucene query for easier\n     * testing.\n     *\n     * Can be changed back to HashMap once https://issues.apache.org/jira/browse/LUCENE-6305 is fixed.\n     ",
      "vertexLabel": "Field fieldsAndWeights"
    },
    {
      "vertexName": "Method public boolean ignoreUnmapped()  (GeoPolygonQueryBuilder.java)",
      "children": [
        {
          "name": "Method public boolean ignoreUnmapped()  (GeoBoundingBoxQueryBuilder.java)"
        }
      ],
      "comment": "\n     * Gets whether the query builder will ignore unmapped fields (and run a\n     * {@link MatchNoDocsQuery} in place of this query) or throw an exception if\n     * the field is unmapped.\n     ",
      "vertexLabel": "boolean ignoreUnmapped()"
    },
    {
      "vertexName": "Method public GetSnapshotsRequest verbose(boolean verbose)  (GetSnapshotsRequest.java)",
      "comment": "\n     * Set to {@code false} to only show the snapshot names and the indices they contain.\n     * This is useful when the snapshots belong to a cloud-based repository where each\n     * blob read is a concern (cost wise and performance wise), as the snapshot names and\n     * indices they contain can be retrieved from a single index blob in the repository,\n     * whereas the rest of the information requires reading a snapshot metadata file for\n     * each snapshot requested.  Defaults to {@code true}, which returns all information\n     * about each requested snapshot.\n     ",
      "vertexLabel": "GetSnapshotsRequest verbose()"
    },
    {
      "vertexName": "Method public abstract AggregationBuilder subAggregations(AggregatorFactories.Builder subFactories)  (AggregationBuilder.java)",
      "children": [
        {
          "name": "Method public AB subAggregations(AggregatorFactories.Builder subFactories)  (AbstractAggregationBuilder.java)"
        }
      ],
      "comment": "\n     * Internal: Registers sub-factories with this factory. The sub-factory will\n     * be responsible for the creation of sub-aggregators under the aggregator\n     * created by this factory. This is only for use by\n     * {@link AggregatorFactories#parseAggregators(XContentParser)}.\n     *\n     * @param subFactories\n     *            The sub-factories\n     * @return this factory (fluent interface)\n     ",
      "vertexLabel": "abstract AggregationBuilder subAggregations()"
    },
    {
      "vertexName": "Method MembersInjector<T> getMembersInjector(TypeLiteral<T> typeLiteral)  (Injector.java)",
      "comment": "\n     * Returns the members injector used to inject dependencies into methods and fields on instances\n     * of the given type {@code T}.\n     *\n     * @param typeLiteral type to get members injector for\n     * @see Binder#getMembersInjector(TypeLiteral) for an alternative that offers up front error\n     *      detection\n     * @since 2.0\n     ",
      "vertexLabel": "MembersInjector<T> getMembersInjector()"
    },
    {
      "vertexName": "Method PipelineAggregationBuilder parse(String pipelineAggregatorName, XContentParser parser) throws IOException  (PipelineAggregator.java)",
      "comment": "\n         * Returns the pipeline aggregator factory with which this parser is\n         * associated.\n         *\n         * @param pipelineAggregatorName\n         *            The name of the pipeline aggregation\n         * @param parser the parser\n         * @return The resolved pipeline aggregator factory\n         * @throws java.io.IOException\n         *             When parsing fails\n         ",
      "vertexLabel": "PipelineAggregationBuilder parse()"
    },
    {
      "vertexName": "Method public RestoreSnapshotRequestBuilder setRestoreGlobalState(boolean restoreGlobalState)  (RestoreSnapshotRequestBuilder.java)",
      "children": [
        {
          "name": "Method public RestoreSnapshotRequest includeGlobalState(boolean includeGlobalState)  (RestoreSnapshotRequest.java)"
        }
      ],
      "comment": "\n     * If set to true the restore procedure will restore global cluster state.\n     * <p>\n     * The global cluster state includes persistent settings and index template definitions.\n     *\n     * @param restoreGlobalState true if global state should be restored from the snapshot\n     * @return this builder\n     ",
      "vertexLabel": "RestoreSnapshotRequestBuilder setRestoreGlobalState()"
    },
    {
      "vertexName": "Method public SearchRequestBuilder setTypes(String... types)  (SearchRequestBuilder.java)",
      "children": [
        {
          "name": "Method public SearchRequest types(String... types)  (SearchRequest.java)"
        }
      ],
      "comment": "\n     * The document types to execute the search against. Defaults to be executed against\n     * all types.\n     * @deprecated Types are going away, prefer filtering on a field.\n     ",
      "vertexLabel": "SearchRequestBuilder setTypes()"
    },
    {
      "vertexName": "Method public IndexRequest source(Map<String, ?> source, XContentType contentType) throws ElasticsearchGenerationException  (IndexRequest.java)",
      "comment": "\n     * Index the Map as the provided content type.\n     *\n     * @param source The map to index\n     ",
      "vertexLabel": "IndexRequest source()"
    },
    {
      "vertexName": "Method String readSysFsCgroupCpuAcctCpuCfsPeriod(final String controlGroup) throws IOException  (OsProbe.java)",
      "children": [
        {
          "name": "Method String readSysFsCgroupCpuAcctCpuAcctUsage(final String controlGroup) throws IOException  (OsProbe.java)"
        },
        {
          "name": "Method private long getCgroupCpuAcctCpuCfsQuotaMicros(final String controlGroup) throws IOException  (OsProbe.java)"
        }
      ],
      "comment": "\n     * Returns the line from {@code cpu.cfs_period_us} for the control group to which the Elasticsearch process belongs for the {@code cpu}\n     * subsystem. This line represents the period of time in microseconds for how frequently the control group's access to CPU resources\n     * will be reallocated.\n     *\n     * @param controlGroup the control group to which the Elasticsearch process belongs for the {@code cpu} subsystem\n     * @return the line from {@code cpu.cfs_period_us}\n     * @throws IOException if an I/O exception occurs reading {@code cpu.cfs_period_us} for the control group\n     ",
      "vertexLabel": "String readSysFsCgroupCpuAcctCpuCfsPeriod()"
    },
    {
      "vertexName": "Method public static MatchQueryBuilder matchQuery(String name, Object text)  (QueryBuilders.java)",
      "children": [
        {
          "name": "Method public static MatchPhraseQueryBuilder matchPhraseQuery(String name, Object text)  (QueryBuilders.java)"
        }
      ],
      "comment": "\n     * Creates a match query with type \"BOOLEAN\" for the provided field name and text.\n     *\n     * @param name The field name.\n     * @param text The query text (to be analyzed).\n     ",
      "vertexLabel": "MatchQueryBuilder matchQuery()"
    },
    {
      "vertexName": "Method public MultiMatchQueryBuilder fuzziness(Object fuzziness)  (MultiMatchQueryBuilder.java)",
      "children": [
        {
          "name": "Method public MatchQueryBuilder fuzziness(Object fuzziness)  (MatchQueryBuilder.java)"
        }
      ],
      "comment": "\n     * Sets the fuzziness used when evaluated to a fuzzy query type. Defaults to \"AUTO\".\n     ",
      "vertexLabel": "MultiMatchQueryBuilder fuzziness()"
    },
    {
      "vertexName": "Method public static ConcurrentMap<K, V> newConcurrentMapWithAggressiveConcurrency(int initalCapacity)  (ConcurrentCollections.java)",
      "children": [
        {
          "name": "Method public static ConcurrentMap<K, V> newConcurrentMapWithAggressiveConcurrency()  (ConcurrentCollections.java)"
        }
      ],
      "comment": "\n     * Creates a new CHM with an aggressive concurrency level, aimed at high concurrent update rate long living maps.\n     ",
      "vertexLabel": "ConcurrentMap<K, V> newConcurrentMapWithAggressiveConcurrency()"
    },
    {
      "vertexName": "Method public void consumeBucketsAndMaybeBreak(int size)  (InternalAggregation.java)",
      "children": [
        {
          "name": "Method protected final void consumeBucketsAndMaybeBreak(int count)  (BucketsAggregator.java)"
        }
      ],
      "comment": "\n         * Adds {@code count} buckets to the global count for the request and fails if this number is greater than\n         * the maximum number of buckets allowed in a response\n         ",
      "vertexLabel": "void consumeBucketsAndMaybeBreak()"
    },
    {
      "vertexName": "Method public ScriptSortBuilder sortMode(SortMode sortMode)  (ScriptSortBuilder.java)",
      "children": [
        {
          "name": "Method public GeoDistanceSortBuilder sortMode(SortMode sortMode)  (GeoDistanceSortBuilder.java)"
        }
      ],
      "comment": "\n     * Defines which distance to use for sorting in the case a document contains multiple values.<br>\n     * For {@link ScriptSortType#STRING}, the set of possible values is restricted to {@link SortMode#MIN} and {@link SortMode#MAX}\n     ",
      "vertexLabel": "ScriptSortBuilder sortMode()"
    },
    {
      "vertexName": "Method public static FuzzyQueryBuilder fuzzyQuery(String name, String value)  (QueryBuilders.java)",
      "comment": "\n     * A Query that matches documents using fuzzy query.\n     *\n     * @param name  The name of the field\n     * @param value The value of the term\n     *\n     * @see #matchQuery(String, Object)\n     * @see #rangeQuery(String)\n     ",
      "vertexLabel": "FuzzyQueryBuilder fuzzyQuery()"
    },
    {
      "vertexName": "Method public int getMinWordLen()  (XMoreLikeThis.java)",
      "children": [
        {
          "name": "Method public void setMinWordLen(int minWordLen)  (XMoreLikeThis.java)"
        }
      ],
      "comment": "\n     * Returns the minimum word length below which words will be ignored. Set this to 0 for no\n     * minimum word length. The default is {@link #DEFAULT_MIN_WORD_LENGTH}.\n     *\n     * @return the minimum word length below which words will be ignored.\n     ",
      "vertexLabel": "int getMinWordLen()"
    },
    {
      "vertexName": "Method public ScalingExecutorBuilder(final String name, final int core, final int max, final TimeValue keepAlive, final String prefix)  (ScalingExecutorBuilder.java)",
      "children": [
        {
          "name": "Method public ScalingExecutorBuilder(final String name, final int core, final int max, final TimeValue keepAlive)  (ScalingExecutorBuilder.java)"
        }
      ],
      "comment": "\n     * Construct a scaling executor builder; the settings will have the\n     * specified key prefix.\n     *\n     * @param name      the name of the executor\n     * @param core      the minimum number of threads in the pool\n     * @param max       the maximum number of threads in the pool\n     * @param keepAlive the time that spare threads above {@code core}\n     *                  threads will be kept alive\n     * @param prefix    the prefix for the settings keys\n     ",
      "vertexLabel": "ScalingExecutorBuilder()"
    },
    {
      "vertexName": "Method public static final E addNeighbors(String geohash, E neighbors)  (GeoHashUtils.java)",
      "comment": "\n     * Add all geohashes of the cells next to a given geohash to a list.\n     *\n     * @param geohash   Geohash of a specified cell\n     * @param neighbors list to add the neighbors to\n     * @return the given list\n     ",
      "vertexLabel": "final E addNeighbors()"
    },
    {
      "vertexName": "Method public ImmutableOpenMap<String, List<AliasMetaData>> findAliases(final AliasesRequest aliasesRequest, final String[] concreteIndices)  (MetaData.java)",
      "children": [
        {
          "name": "Method public ImmutableOpenMap<String, List<AliasMetaData>> findAllAliases(final String[] concreteIndices)  (MetaData.java)"
        },
        {
          "name": "Method public boolean hasAliases(final String[] aliases, String[] concreteIndices)  (MetaData.java)"
        }
      ],
      "comment": "\n     * Finds the specific index aliases that match with the specified aliases directly or partially via wildcards, and\n     * that point to the specified concrete indices (directly or matching indices via wildcards).\n     *\n     * @param aliasesRequest The request to find aliases for\n     * @param concreteIndices The concrete indices that the aliases must point to in order to be returned.\n     * @return A map of index name to the list of aliases metadata. If a concrete index does not have matching\n     * aliases then the result will <b>not</b> include the index's key.\n     ",
      "vertexLabel": "ImmutableOpenMap<String, List<AliasMetaData>> findAliases()"
    },
    {
      "vertexName": "Method public static ConstantScoreQueryBuilder constantScoreQuery(QueryBuilder queryBuilder)  (QueryBuilders.java)",
      "children": [
        {
          "name": "Class ConstantScoreQueryBuilder  (ConstantScoreQueryBuilder.java)"
        }
      ],
      "comment": "\n     * A query that wraps another query and simply returns a constant score equal to the\n     * query boost for every document in the query.\n     *\n     * @param queryBuilder The query to wrap in a constant score query\n     ",
      "vertexLabel": "ConstantScoreQueryBuilder constantScoreQuery()"
    },
    {
      "vertexName": "Method public Translog.Snapshot readHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException  (InternalEngine.java)",
      "comment": "\n     * Creates a new history snapshot for reading operations since the provided seqno.\n     * The returned snapshot can be retrieved from either Lucene index or translog files.\n     ",
      "vertexLabel": "Translog.Snapshot readHistoryOperations()"
    },
    {
      "vertexName": "Method static int[] ids()  (ElasticsearchException.java)",
      "comment": "\n     * Returns an array of all registered handle IDs. These are the IDs for every registered\n     * exception.\n     *\n     * @return an array of all registered handle IDs\n     ",
      "vertexLabel": "int[] ids()"
    },
    {
      "vertexName": "Method public DiscoveryNode handshake(final Transport.Connection connection, final long handshakeTimeout) throws ConnectTransportException  (TransportService.java)",
      "comment": "\n     * Executes a high-level handshake using the given connection\n     * and returns the discovery node of the node the connection\n     * was established with. The handshake will fail if the cluster\n     * name on the target node mismatches the local cluster name.\n     *\n     * @param connection       the connection to a specific node\n     * @param handshakeTimeout handshake timeout\n     * @return the connected node\n     * @throws ConnectTransportException if the connection failed\n     * @throws IllegalStateException if the handshake failed\n     ",
      "vertexLabel": "DiscoveryNode handshake()"
    },
    {
      "vertexName": "Method public String[] indexAliases(ClusterState state, String index, Predicate<AliasMetaData> requiredAlias, boolean skipIdentity, String... expressions)  (IndexNameExpressionResolver.java)",
      "children": [
        {
          "name": "Method public String[] filteringAliases(ClusterState state, String index, String... expressions)  (IndexNameExpressionResolver.java)"
        }
      ],
      "comment": "\n     * Iterates through the list of indices and selects the effective list of required aliases for the given index.\n     * <p>Only aliases where the given predicate tests successfully are returned. If the indices list contains a non-required reference to\n     * the index itself - null is returned. Returns {@code null} if no filtering is required.\n     ",
      "vertexLabel": "String[] indexAliases()"
    },
    {
      "vertexName": "Method public ShardRouting initialize(String nodeId, @Nullable String existingAllocationId, long expectedShardSize)  (ShardRouting.java)",
      "comment": "\n     * Initializes an unassigned shard on a node.\n     *\n     * @param existingAllocationId allocation id to use. If null, a fresh allocation id is generated.\n     ",
      "vertexLabel": "ShardRouting initialize()"
    },
    {
      "vertexName": "Method private static double cost(MovAvgModel model, EvictingQueue<Double> train, double[] test)  (SimulatedAnealingMinimizer.java)",
      "comment": "\n     * Calculates the \"cost\" of a model.  E.g. when run on the training data, how closely do the  predictions\n     * match the test data\n     *\n     * Uses Least Absolute Differences to calculate error.  Note that this is not scale free, but seems\n     * to work fairly well in practice\n     *\n     * @param model     The MovAvgModel we are fitting\n     * @param train     A training set of data given to the model, which will then generate predictions from\n     * @param test      A test set of data to compare against the predictions\n     * @return          A cost, or error, of the model\n     ",
      "vertexLabel": "double cost()"
    },
    {
      "vertexName": "Method public T read(BlobContainer blobContainer, String name) throws IOException  (BlobStoreFormat.java)",
      "children": [
        {
          "name": "Method public abstract T readBlob(BlobContainer blobContainer, String blobName) throws IOException  (BlobStoreFormat.java)"
        }
      ],
      "comment": "\n     * Reads and parses the blob with given name, applying name translation using the {link #blobName} method\n     *\n     * @param blobContainer blob container\n     * @param name          name to be translated into\n     * @return parsed blob object\n     ",
      "vertexLabel": "T read()"
    },
    {
      "vertexName": "Method public AnalysisProvider<TokenizerFactory> getTokenizerProvider(String tokenizer, IndexSettings indexSettings)  (AnalysisRegistry.java)",
      "comment": "\n     * Returns a registered {@link TokenizerFactory} provider by {@link IndexSettings}\n     *  or a registered {@link TokenizerFactory} provider by predefined name\n     *  or <code>null</code> if the tokenizer was not registered\n     * @param tokenizer global or defined tokenizer name\n     * @param indexSettings an index settings\n     * @return {@link TokenizerFactory} provider or <code>null</code>\n     ",
      "vertexLabel": "AnalysisProvider<TokenizerFactory> getTokenizerProvider()"
    },
    {
      "vertexName": "Method public FunctionScoreQuery(Query subQuery, Float minScore, float maxBoost)  (FunctionScoreQuery.java)",
      "comment": "\n     * Creates a FunctionScoreQuery without function.\n     * @param subQuery The query to match.\n     * @param minScore The minimum score to consider a document.\n     * @param maxBoost The maximum applicable boost.\n     ",
      "vertexLabel": "FunctionScoreQuery()"
    },
    {
      "vertexName": "Method public UpdateRequestBuilder setUpsert(Object... source)  (UpdateRequestBuilder.java)",
      "children": [
        {
          "name": "Method public UpdateRequest upsert(Object... source)  (UpdateRequest.java)"
        }
      ],
      "comment": "\n     * Sets the doc source of the update request to be used when the document does not exists. The doc\n     * includes field and value pairs.\n     ",
      "vertexLabel": "UpdateRequestBuilder setUpsert()"
    },
    {
      "vertexName": "Method private void removeSnapshotFromClusterState(final Snapshot snapshot, final SnapshotInfo snapshotInfo, final Exception e)  (SnapshotsService.java)",
      "comment": "\n     * Removes record of running snapshot from cluster state\n     *  @param snapshot       snapshot\n     * @param snapshotInfo   snapshot info if snapshot was successful\n     * @param e              exception if snapshot failed\n     ",
      "vertexLabel": "void removeSnapshotFromClusterState()"
    },
    {
      "vertexName": "Method SingleDimensionValuesSource(BigArrays bigArrays, DocValueFormat format, @Nullable MappedFieldType fieldType, boolean missingBucket, int size, int reverseMul)  (SingleDimensionValuesSource.java)",
      "children": [
        {
          "name": "Method CompositeValuesSourceConfig(String name, @Nullable MappedFieldType fieldType, ValuesSource vs, DocValueFormat format, SortOrder order, boolean missingBucket)  (CompositeValuesSourceConfig.java)"
        }
      ],
      "comment": "\n     * Creates a new {@link SingleDimensionValuesSource}.\n     *\n     * @param bigArrays The big arrays object.\n     * @param format The format of the source.\n     * @param fieldType The field type or null if the source is a script.\n     * @param missingBucket If true, an explicit `null bucket represents documents with missing values.\n     * @param size The number of values to record.\n     * @param reverseMul -1 if the natural order ({@link SortOrder#ASC} should be reversed.\n     ",
      "vertexLabel": "SingleDimensionValuesSource()"
    },
    {
      "vertexName": "Method public static boolean isExplicitAllType(String[] types)  (MetaData.java)",
      "children": [
        {
          "name": "Method public static boolean isAllTypes(String[] types)  (MetaData.java)"
        }
      ],
      "comment": "\n     * Identifies whether the array containing type names given as argument explicitly refers to all types\n     * The empty or null array doesn't explicitly map to all types\n     *\n     * @param types the array containing index names\n     * @return true if the provided array explicitly maps to all types, false otherwise\n     ",
      "vertexLabel": "boolean isExplicitAllType()"
    },
    {
      "vertexName": "Method public ShardIterator activeInitializingShardsIt(int seed)  (IndexShardRoutingTable.java)",
      "children": [
        {
          "name": "Method public ShardIterator activeInitializingShardsRandomIt()  (IndexShardRoutingTable.java)"
        }
      ],
      "comment": "\n     * Returns an iterator over active and initializing shards. Making sure though that\n     * its random within the active shards, and initializing shards are the last to iterate through.\n     ",
      "vertexLabel": "ShardIterator activeInitializingShardsIt()"
    },
    {
      "vertexName": "Method public IndicesOptions indicesOptions()  (CloseIndexRequest.java)",
      "children": [
        {
          "name": "Method public IndicesOptions indicesOptions()  (RestoreSnapshotRequest.java)"
        }
      ],
      "comment": "\n     * Specifies what type of requested indices to ignore and how to deal with wildcard expressions.\n     * For example indices that don't exist.\n     *\n     * @return the desired behaviour regarding indices to ignore and wildcard indices expressions\n     ",
      "vertexLabel": "IndicesOptions indicesOptions()"
    },
    {
      "vertexName": "Method public TermsQueryBuilder(String fieldName, Iterable<?> values)  (TermsQueryBuilder.java)",
      "children": [
        {
          "name": "Method public TermsQueryBuilder(String fieldName, String... values)  (TermsQueryBuilder.java)"
        }
      ],
      "comment": "\n     * A filter for a field based on several terms matching on any of them.\n     *\n     * @param fieldName The field name\n     * @param values The terms\n     ",
      "vertexLabel": "TermsQueryBuilder()"
    },
    {
      "vertexName": "Method DeleteRequestBuilder prepareDelete(String index, String type, String id)  (Client.java)",
      "children": [
        {
          "name": "Method public GetRequest(String index, String type, String id)  (GetRequest.java)"
        }
      ],
      "comment": "\n     * Deletes a document from the index based on the index, type and id.\n     *\n     * @param index The index to delete the document from\n     * @param type  The type of the document to delete\n     * @param id    The id of the document to delete\n     ",
      "vertexLabel": "DeleteRequestBuilder prepareDelete()"
    },
    {
      "vertexName": "Method public static FieldSortBuilder fromXContent(XContentParser parser, String fieldName) throws IOException  (FieldSortBuilder.java)",
      "children": [
        {
          "name": "Method QB fromXContent(XContentParser parser) throws IOException  (QueryParser.java)"
        }
      ],
      "comment": "\n     * Creates a new {@link FieldSortBuilder} from the query held by the {@link XContentParser} in\n     * {@link org.elasticsearch.common.xcontent.XContent} format.\n     *\n     * @param parser the input parser. The state on the parser contained in this context will be changed as a side effect of this\n     *        method call\n     * @param fieldName in some sort syntax variations the field name precedes the xContent object that specifies further parameters, e.g.\n     *        in '{ \"foo\": { \"order\" : \"asc\"} }'. When parsing the inner object, the field name can be passed in via this argument\n     ",
      "vertexLabel": "FieldSortBuilder fromXContent()"
    },
    {
      "vertexName": "Method public OpenIndexRequestBuilder setIndicesOptions(IndicesOptions indicesOptions)  (OpenIndexRequestBuilder.java)",
      "children": [
        {
          "name": "Method public OpenIndexRequest indicesOptions(IndicesOptions indicesOptions)  (OpenIndexRequest.java)"
        }
      ],
      "comment": "\n     * Specifies what type of requested indices to ignore and how to deal with wildcard indices expressions.\n     * For example indices that don't exist.\n     *\n     * @param indicesOptions the desired behaviour regarding indices to ignore and wildcard indices expressions\n     * @return the request itself\n     ",
      "vertexLabel": "OpenIndexRequestBuilder setIndicesOptions()"
    },
    {
      "vertexName": "Method public OpenIndexRequestBuilder setIndices(String... indices)  (OpenIndexRequestBuilder.java)",
      "children": [
        {
          "name": "Method public OpenIndexRequest indices(String... indices)  (OpenIndexRequest.java)"
        }
      ],
      "comment": "\n     * Sets the indices to be opened\n     *\n     * @param indices the indices to be opened\n     * @return the request itself\n     ",
      "vertexLabel": "OpenIndexRequestBuilder setIndices()"
    },
    {
      "vertexName": "Method public static FuzzyQueryBuilder fuzzyQuery(String name, Object value)  (QueryBuilders.java)",
      "children": [
        {
          "name": "Method public static FuzzyQueryBuilder fuzzyQuery(String name, String value)  (QueryBuilders.java)"
        }
      ],
      "comment": "\n     * A Query that matches documents using fuzzy query.\n     *\n     * @param name  The name of the field\n     * @param value The value of the term\n     *\n     * @see #matchQuery(String, Object)\n     * @see #rangeQuery(String)\n     ",
      "vertexLabel": "FuzzyQueryBuilder fuzzyQuery()"
    },
    {
      "vertexName": "Method public static RestRequest requestWithoutParameters(NamedXContentRegistry xContentRegistry, HttpRequest httpRequest, HttpChannel httpChannel)  (RestRequest.java)",
      "comment": "\n     * Creates a new REST request. The path is not decoded so this constructor will not throw a\n     * {@link BadParameterException}.\n     *\n     * @param xContentRegistry the content registry\n     * @param httpRequest      the http request\n     * @param httpChannel      the http channel\n     * @throws ContentTypeHeaderException if the Content-Type header can not be parsed\n     ",
      "vertexLabel": "RestRequest requestWithoutParameters()"
    },
    {
      "vertexName": "Method Runnable preserveContext(Runnable command)  (Scheduler.java)",
      "comment": "\n     * Does nothing by default but can be used by subclasses to save the current thread context and wraps the command in a Runnable\n     * that restores that context before running the command.\n     ",
      "vertexLabel": "Runnable preserveContext()"
    },
    {
      "vertexName": "Method public void invalidate(K key, V value)  (Cache.java)",
      "children": [
        {
          "name": "Method public void invalidate(K key)  (Cache.java)"
        }
      ],
      "comment": "\n     * Invalidate the entry for the specified key and value. If the value provided is not equal to the value in\n     * the cache, no removal will occur. A removal notification will be issued for invalidated\n     * entries with {@link org.elasticsearch.common.cache.RemovalNotification.RemovalReason} INVALIDATED.\n     *\n     * @param key the key whose mapping is to be invalidated from the cache\n     * @param value the expected value that should be associated with the key\n     ",
      "vertexLabel": "void invalidate()"
    },
    {
      "vertexName": "Method ScheduledFuture<?> schedule(TimeValue delay, String executor, Runnable command)  (Scheduler.java)",
      "children": [
        {
          "name": "Method Cancellable scheduleWithFixedDelay(Runnable command, TimeValue interval, String executor)  (Scheduler.java)"
        },
        {
          "name": "Method public ScheduledFuture<?> schedule(TimeValue delay, String executor, Runnable command)  (ThreadPool.java)"
        }
      ],
      "comment": "\n     * Schedules a one-shot command to be run after a given delay. The command is not run in the context of the calling thread.\n     * To preserve the context of the calling thread you may call {@link #preserveContext(Runnable)} on the runnable before passing\n     * it to this method.\n     * The command runs on scheduler thread. Do not run blocking calls on the scheduler thread. Subclasses may allow\n     * to execute on a different executor, in which case blocking calls are allowed.\n     *\n     * @param delay delay before the task executes\n     * @param executor the name of the executor that has to execute this task. Ignored in the default implementation but can be used\n     *                 by subclasses that support multiple executors.\n     * @param command the command to run\n     * @return a ScheduledFuture who's get will return when the task has been added to its target thread pool and throws an exception if\n     *         the task is canceled before it was added to its target thread pool. Once the task has been added to its target thread pool\n     *         the ScheduledFuture cannot interact with it.\n     * @throws EsRejectedExecutionException if the task cannot be scheduled for execution\n     ",
      "vertexLabel": "ScheduledFuture<?> schedule()"
    },
    {
      "vertexName": "Method public void executeIO(IOInterruptable interruptable) throws IOException  (CancellableThreads.java)",
      "children": [
        {
          "name": "Method public void execute(Interruptable interruptable)  (CancellableThreads.java)"
        }
      ],
      "comment": "\n     * run the Interruptable, capturing the executing thread. Concurrent calls to {@link #cancel(String)} will interrupt this thread\n     * causing the call to prematurely return.\n     *\n     * @param interruptable code to run\n     ",
      "vertexLabel": "void executeIO()"
    },
    {
      "vertexName": "Method public T getDefault(Settings settings)  (Setting.java)",
      "comment": "\n     * Returns the default value for this setting.\n     * @param settings a settings object for settings that has a default value depending on another setting if available\n     ",
      "vertexLabel": "T getDefault()"
    },
    {
      "vertexName": "Method public String[] retrieveInterestingTerms(Reader r, String fieldName) throws IOException  (XMoreLikeThis.java)",
      "comment": "\n     * Convenience routine to make it easy to return the most interesting words in a document.\n     * More advanced users will call {@link #retrieveTerms(Reader, String) retrieveTerms()} directly.\n     *\n     * @param r the source document\n     * @param fieldName field passed to analyzer to use when analyzing the content\n     * @return the most interesting words in the document\n     * @see #retrieveTerms(java.io.Reader, String)\n     * @see #setMaxQueryTerms\n     ",
      "vertexLabel": "String[] retrieveInterestingTerms()"
    },
    {
      "vertexName": "Class Bucket  (UnmappedTerms.java)",
      "comment": "\n     * Concrete type that can't be built because Java needs a concrete type so {@link InternalTerms.Bucket} can have a self type but\n     * {@linkplain UnmappedTerms} doesn't ever need to build it because it never returns any buckets.\n     ",
      "vertexLabel": "Class Bucket"
    },
    {
      "vertexName": "Method void addError(String message, Object... arguments)  (Binder.java)",
      "comment": "\n     * Records an error message which will be presented to the user at a later\n     * time. Unlike throwing an exception, this enable us to continue\n     * configuring the Injector and discover more errors. Uses {@link\n     * String#format(String, Object[])} to insert the arguments into the\n     * message.\n     ",
      "vertexLabel": "void addError()"
    },
    {
      "vertexName": "Method public long getMaxSeqNoOfUpdatesOrDeletes()  (IndexShard.java)",
      "comment": "\n     * Returns the maximum sequence number of either update or delete operations have been processed in this shard\n     * or the sequence number from {@link #advanceMaxSeqNoOfUpdatesOrDeletes(long)}. An index request is considered\n     * as an update operation if it overwrites the existing documents in Lucene index with the same document id.\n     * <p>\n     * The primary captures this value after executes a replication request, then transfers it to a replica before\n     * executing that replication request on a replica.\n     ",
      "vertexLabel": "long getMaxSeqNoOfUpdatesOrDeletes()"
    },
    {
      "vertexName": "Method void blockOperations(final long timeout, final TimeUnit timeUnit, final CheckedRunnable<E> onBlocked) throws InterruptedException, TimeoutException, E  (IndexShardOperationPermits.java)",
      "children": [
        {
          "name": "Method public void asyncBlockOperations(final ActionListener<Releasable> onAcquired, final long timeout, final TimeUnit timeUnit)  (IndexShardOperationPermits.java)"
        }
      ],
      "comment": "\n     * Wait for in-flight operations to finish and executes {@code onBlocked} under the guarantee that no new operations are started. Queues\n     * operations that are occurring in the meanwhile and runs them once {@code onBlocked} has executed.\n     *\n     * @param timeout   the maximum time to wait for the in-flight operations block\n     * @param timeUnit  the time unit of the {@code timeout} argument\n     * @param onBlocked the action to run once the block has been acquired\n     * @param <E>       the type of checked exception thrown by {@code onBlocked}\n     * @throws InterruptedException      if calling thread is interrupted\n     * @throws TimeoutException          if timed out waiting for in-flight operations to finish\n     * @throws IndexShardClosedException if operation permit has been closed\n     ",
      "vertexLabel": "void blockOperations()"
    },
    {
      "vertexName": "Method public IndicesShardStoresRequest shardStatuses(String... shardStatuses)  (IndicesShardStoresRequest.java)",
      "children": [
        {
          "name": "Method public IndicesShardStoreRequestBuilder setShardStatuses(String... shardStatuses)  (IndicesShardStoreRequestBuilder.java)"
        }
      ],
      "comment": "\n     * Set statuses to filter shards to get stores info on.\n     * see {@link ClusterHealthStatus} for details.\n     * Defaults to \"yellow\" and \"red\" status\n     * @param shardStatuses acceptable values are \"green\", \"yellow\", \"red\" and \"all\"\n     ",
      "vertexLabel": "IndicesShardStoresRequest shardStatuses()"
    },
    {
      "vertexName": "Method public QueryBuilder getNestedFilter()  (FieldSortBuilder.java)",
      "children": [
        {
          "name": "Method public FieldSortBuilder setNestedFilter(QueryBuilder nestedFilter)  (FieldSortBuilder.java)"
        }
      ],
      "comment": "\n     * Returns the nested filter that the nested objects should match with in\n     * order to be taken into account for sorting.\n     *\n     * @deprecated set nested sort with {@link #setNestedSort(NestedSortBuilder)} and retrieve with {@link #getNestedSort()}\n     ",
      "vertexLabel": "QueryBuilder getNestedFilter()"
    },
    {
      "vertexName": "Method protected abstract ClusterBlockException checkRequestBlock(ClusterState state, Request request, String[] concreteIndices)  (TransportBroadcastByNodeAction.java)",
      "children": [
        {
          "name": "Method protected abstract ClusterBlockException checkGlobalBlock(ClusterState state, Request request)  (TransportBroadcastByNodeAction.java)"
        }
      ],
      "comment": "\n     * Executes a global request-level check before polling the cluster state.\n     *\n     * @param state           the cluster state\n     * @param request         the underlying request\n     * @param concreteIndices the concrete indices on which to execute the operation\n     * @return a non-null exception if the operation if blocked\n     ",
      "vertexLabel": "abstract ClusterBlockException checkRequestBlock()"
    },
    {
      "vertexName": "Method public DirectCandidateGeneratorBuilder suggestMode(String suggestMode)  (DirectCandidateGeneratorBuilder.java)",
      "children": [
        {
          "name": "EnumConstant ALWAYS  (TermSuggestionBuilder.java)"
        }
      ],
      "comment": "\n     * The global suggest mode controls what suggested terms are included or\n     * controls for what suggest text tokens, terms should be suggested for.\n     * Three possible values can be specified:\n     * <ol>\n     * <li><code>missing</code> - Only suggest terms in the suggest text\n     * that aren't in the index. This is the default.\n     * <li><code>popular</code> - Only suggest terms that occur in more docs\n     * then the original suggest text term.\n     * <li><code>always</code> - Suggest any matching suggest terms based on\n     * tokens in the suggest text.\n     * </ol>\n     ",
      "vertexLabel": "DirectCandidateGeneratorBuilder suggestMode()"
    },
    {
      "vertexName": "Method static void rewriteAndFetch(T original, QueryRewriteContext context, ActionListener<T> rewriteResponse, int iteration)  (Rewriteable.java)",
      "children": [
        {
          "name": "Method static void rewriteAndFetch(T original, QueryRewriteContext context, ActionListener<T> rewriteResponse)  (Rewriteable.java)"
        }
      ],
      "comment": "\n     * Rewrites the given rewriteable and fetches pending async tasks for each round before rewriting again.\n     ",
      "vertexLabel": "void rewriteAndFetch()"
    },
    {
      "vertexName": "Method public int maxNumSegments()  (ForceMergeRequest.java)",
      "comment": "\n     * Will merge the index down to &lt;= maxNumSegments. By default, will cause the merge\n     * process to merge down to half the configured number of segments.\n     ",
      "vertexLabel": "int maxNumSegments()"
    },
    {
      "vertexName": "Method private boolean updateSettings(Settings toApply, Settings.Builder target, Settings.Builder updates, String type, boolean onlyDynamic)  (AbstractScopedSettings.java)",
      "children": [
        {
          "name": "Method public boolean updateSettings(Settings toApply, Settings.Builder target, Settings.Builder updates, String type)  (AbstractScopedSettings.java)"
        }
      ],
      "comment": "\n     * Updates a target settings builder with new, updated or deleted settings from a given settings builder.\n     *\n     * @param toApply the new settings to apply\n     * @param target the target settings builder that the updates are applied to. All keys that have explicit null value in toApply will be\n     *        removed from this builder\n     * @param updates a settings builder that holds all updates applied to target\n     * @param type a free text string to allow better exceptions messages\n     * @param onlyDynamic if <code>false</code> all settings are updated otherwise only dynamic settings are updated. if set to\n     *        <code>true</code> and a non-dynamic setting is updated an exception is thrown.\n     * @return <code>true</code> if the target has changed otherwise <code>false</code>\n     ",
      "vertexLabel": "boolean updateSettings()"
    },
    {
      "vertexName": "Method public FunctionScoreQueryBuilder(ScoreFunctionBuilder<?> scoreFunctionBuilder)  (FunctionScoreQueryBuilder.java)",
      "comment": "\n     * Creates a function_score query that will execute the function provided on all documents\n     *\n     * @param scoreFunctionBuilder score function that is executed\n     ",
      "vertexLabel": "FunctionScoreQueryBuilder()"
    },
    {
      "vertexName": "Method public DateRangeAggregationBuilder addUnboundedFrom(String key, double from)  (DateRangeAggregationBuilder.java)",
      "children": [
        {
          "name": "Method public DateRangeAggregationBuilder addUnboundedFrom(String key, String from)  (DateRangeAggregationBuilder.java)"
        }
      ],
      "comment": "\n     * Add a new range with no upper bound.\n     *\n     * @param key\n     *            the key to use for this range in the response\n     * @param from\n     *            the lower bound on the distances, inclusive\n     ",
      "vertexLabel": "DateRangeAggregationBuilder addUnboundedFrom()"
    },
    {
      "vertexName": "Method public RestoreSnapshotRequestBuilder setIndicesOptions(IndicesOptions indicesOptions)  (RestoreSnapshotRequestBuilder.java)",
      "children": [
        {
          "name": "Method public RestoreSnapshotRequest indicesOptions(IndicesOptions indicesOptions)  (RestoreSnapshotRequest.java)"
        }
      ],
      "comment": "\n     * Specifies what type of requested indices to ignore and how to deal with wildcard expressions.\n     * For example indices that don't exist.\n     *\n     * @param indicesOptions the desired behaviour regarding indices to ignore and wildcard indices expressions\n     * @return this builder\n     ",
      "vertexLabel": "RestoreSnapshotRequestBuilder setIndicesOptions()"
    },
    {
      "vertexName": "Method public NumericDoubleValues select(final SortedNumericDoubleValues values)  (MultiValueMode.java)",
      "children": [
        {
          "name": "Method public NumericDocValues select(final SortedNumericDocValues values)  (MultiValueMode.java)"
        }
      ],
      "comment": "\n     * Return a {@link NumericDoubleValues} instance that can be used to sort documents\n     * with this mode and the provided values. When a document has no value,\n     * <code>missingValue</code> is returned.\n     *\n     * Allowed Modes: SUM, AVG, MEDIAN, MIN, MAX\n     ",
      "vertexLabel": "NumericDoubleValues select()"
    },
    {
      "vertexName": "Method public static void registerProxyAction(TransportService service, String action, Writeable.Reader<? extends TransportResponse> reader)  (TransportActionProxy.java)",
      "comment": "\n     * Registers a proxy request handler that allows to forward requests for the given action to another node. To be used when the\n     * response type is always the same (most of the cases).\n     ",
      "vertexLabel": "void registerProxyAction()"
    },
    {
      "vertexName": "Method public synchronized void waitForOpsToComplete(final long seqNo) throws InterruptedException  (LocalCheckpointTracker.java)",
      "children": [
        {
          "name": "Method public abstract void waitForOpsToComplete(long seqNo) throws InterruptedException  (Engine.java)"
        }
      ],
      "comment": "\n     * Waits for all operations up to the provided sequence number to complete.\n     *\n     * @param seqNo the sequence number that the checkpoint must advance to before this method returns\n     * @throws InterruptedException if the thread was interrupted while blocking on the condition\n     ",
      "vertexLabel": "synchronized void waitForOpsToComplete()"
    },
    {
      "vertexName": "Method public RestoreSnapshotRequestBuilder(ElasticsearchClient client, RestoreSnapshotAction action, String repository, String name)  (RestoreSnapshotRequestBuilder.java)",
      "comment": "\n     * Constructs new restore snapshot request builder with specified repository and snapshot names\n     ",
      "vertexLabel": "RestoreSnapshotRequestBuilder()"
    },
    {
      "vertexName": "Method public ClusterRerouteRequestBuilder setRetryFailed(boolean retryFailed)  (ClusterRerouteRequestBuilder.java)",
      "children": [
        {
          "name": "Method public ClusterRerouteRequest setRetryFailed(boolean retryFailed)  (ClusterRerouteRequest.java)"
        }
      ],
      "comment": "\n     * Sets the retry failed flag (defaults to {@code false}). If true, the\n     * request will retry allocating shards that can't currently be allocated due to too many allocation failures.\n     ",
      "vertexLabel": "ClusterRerouteRequestBuilder setRetryFailed()"
    },
    {
      "vertexName": "Method RefreshRequestBuilder prepareRefresh(String... indices)  (IndicesAdminClient.java)",
      "comment": "\n     * Explicitly refresh one or more indices (making the content indexed since the last refresh searchable).\n     ",
      "vertexLabel": "RefreshRequestBuilder prepareRefresh()"
    },
    {
      "vertexName": "Method public String getMemoryLimitInBytes()  (OsStats.java)",
      "comment": "\n         * The maximum amount of user memory (including file cache).\n         * This is stored as a <code>String</code> because the value can be too big to fit in a\n         * <code>long</code>.  (The alternative would have been <code>BigInteger</code> but then\n         * it would not be possible to index the OS stats document into Elasticsearch without\n         * losing information, as <code>BigInteger</code> is not a supported Elasticsearch type.)\n         *\n         * @return the maximum amount of user memory (including file cache).\n         ",
      "vertexLabel": "String getMemoryLimitInBytes()"
    },
    {
      "vertexName": "Method public boolean includeGlobalState()  (CreateSnapshotRequest.java)",
      "comment": "\n     * Returns true if global state should be stored as part of the snapshot\n     *\n     * @return true if global state should be stored as part of the snapshot\n     ",
      "vertexLabel": "boolean includeGlobalState()"
    },
    {
      "vertexName": "Method public FloatArray grow(FloatArray array, long minSize)  (BigArrays.java)",
      "children": [
        {
          "name": "Method public ByteArray grow(ByteArray array, long minSize)  (BigArrays.java)"
        }
      ],
      "comment": " Grow an array to a size that is larger than <code>minSize</code>,\n     * preserving content, and potentially reusing part of the provided array. ",
      "vertexLabel": "FloatArray grow()"
    },
    {
      "vertexName": "Method public SearchSourceBuilder docValueField(String name, @Nullable String format)  (SearchSourceBuilder.java)",
      "children": [
        {
          "name": "Method public TopHitsAggregationBuilder docValueField(String docValueField, String format)  (TopHitsAggregationBuilder.java)"
        }
      ],
      "comment": "\n     * Adds a field to load from the doc values and return as part of the\n     * search request.\n     ",
      "vertexLabel": "SearchSourceBuilder docValueField()"
    },
    {
      "vertexName": "Enum MultiValueMode  (MultiValueMode.java)",
      "comment": "\n * Defines what values to pick in the case a document contains multiple values for a particular field.\n ",
      "vertexLabel": "Enum MultiValueMode"
    },
    {
      "vertexName": "Method public boolean hasAliases(final String[] aliases, String[] concreteIndices)  (MetaData.java)",
      "comment": "\n     * Checks if at least one of the specified aliases exists in the specified concrete indices. Wildcards are supported in the\n     * alias names for partial matches.\n     *\n     * @param aliases         The names of the index aliases to find\n     * @param concreteIndices The concrete indexes the index aliases must point to order to be returned.\n     * @return whether at least one of the specified aliases exists in one of the specified concrete indices.\n     ",
      "vertexLabel": "boolean hasAliases()"
    },
    {
      "vertexName": "Method public abstract LinkedBindingBuilder<T> addBinding()  (Multibinder.java)",
      "children": [
        {
          "name": "Method public abstract LinkedBindingBuilder<V> addBinding(K key)  (MapBinder.java)"
        }
      ],
      "comment": "\n     * Returns a binding builder used to add a new element in the set. Each\n     * bound element must have a distinct value. Bound providers will be\n     * evaluated each time the set is injected.\n     * <p>\n     * It is an error to call this method without also calling one of the\n     * {@code to} methods on the returned binding builder.\n     * <p>\n     * Scoping elements independently is supported. Use the {@code in} method\n     * to specify a binding scope.\n     ",
      "vertexLabel": "abstract LinkedBindingBuilder<T> addBinding()"
    },
    {
      "vertexName": "Method private String getCgroupMemoryLimitInBytes(final String controlGroup) throws IOException  (OsProbe.java)",
      "children": [
        {
          "name": "Method public String getMemoryLimitInBytes()  (OsStats.java)"
        },
        {
          "name": "Method String readSysFsCgroupMemoryUsageInBytes(final String controlGroup) throws IOException  (OsProbe.java)"
        }
      ],
      "comment": "\n     * The maximum amount of user memory (including file cache).\n     * If there is no limit then some Linux versions return the maximum value that can be stored in an\n     * unsigned 64 bit number, and this will overflow a long, hence the result type is <code>String</code>.\n     * (The alternative would have been <code>BigInteger</code> but then it would not be possible to index\n     * the OS stats document into Elasticsearch without losing information, as <code>BigInteger</code> is\n     * not a supported Elasticsearch type.)\n     *\n     * @param controlGroup the control group for the Elasticsearch process for the {@code memory} subsystem\n     * @return the maximum amount of user memory (including file cache)\n     * @throws IOException if an I/O exception occurs reading {@code memory.limit_in_bytes} for the control group\n     ",
      "vertexLabel": "String getCgroupMemoryLimitInBytes()"
    },
    {
      "vertexName": "Method public Self setMaxRetries(int maxRetries)  (AbstractBulkByScrollRequestBuilder.java)",
      "children": [
        {
          "name": "Field maxRetries  (AbstractBulkByScrollRequest.java)"
        }
      ],
      "comment": "\n     * Total number of retries attempted for rejections. There is no way to ask for unlimited retries.\n     ",
      "vertexLabel": "Self setMaxRetries()"
    },
    {
      "vertexName": "Method public void addMetadata(String key, List<String> values)  (ElasticsearchException.java)",
      "children": [
        {
          "name": "Method public void addMetadata(String key, String... values)  (ElasticsearchException.java)"
        }
      ],
      "comment": "\n     * Adds a new piece of metadata with the given key.\n     * If the provided key is already present, the corresponding metadata will be replaced\n     ",
      "vertexLabel": "void addMetadata()"
    },
    {
      "vertexName": "Method public String quoteAnalyzer()  (QueryStringQueryBuilder.java)",
      "children": [
        {
          "name": "Method public QueryStringQueryBuilder analyzer(String analyzer)  (QueryStringQueryBuilder.java)"
        }
      ],
      "comment": "\n     * The optional analyzer used to analyze the query string for phrase searches. Note, if a field has search (quote) analyzer\n     * defined for it, then it will be used automatically. Defaults to the smart search analyzer.\n     ",
      "vertexLabel": "String quoteAnalyzer()"
    },
    {
      "vertexName": "Method public QueryStringQueryBuilder quoteAnalyzer(String quoteAnalyzer)  (QueryStringQueryBuilder.java)",
      "children": [
        {
          "name": "Method public String quoteAnalyzer()  (QueryStringQueryBuilder.java)"
        }
      ],
      "comment": "\n     * The optional analyzer used to analyze the query string for phrase searches. Note, if a field has search (quote) analyzer\n     * defined for it, then it will be used automatically. Defaults to the smart search analyzer.\n     ",
      "vertexLabel": "QueryStringQueryBuilder quoteAnalyzer()"
    },
    {
      "vertexName": "Class WildcardQueryBuilder  (WildcardQueryBuilder.java)",
      "comment": "\n * Implements the wildcard search query. Supported wildcards are {@code *}, which\n * matches any character sequence (including the empty one), and {@code ?},\n * which matches any single character. Note this query can be slow, as it\n * needs to iterate over many terms. In order to prevent extremely slow WildcardQueries,\n * a Wildcard term should not start with one of the wildcards {@code *} or\n * {@code ?}.\n ",
      "vertexLabel": "Class WildcardQueryBuilder"
    },
    {
      "vertexName": "Method public Long getShardSize(ShardRouting shardRouting)  (ClusterInfo.java)",
      "comment": "\n     * Returns the shard size for the given shard routing or <code>null</code> it that metric is not available.\n     ",
      "vertexLabel": "Long getShardSize()"
    },
    {
      "vertexName": "Method public static MoreLikeThisQueryBuilder moreLikeThisQuery(String[] likeTexts)  (QueryBuilders.java)",
      "comment": "\n     * A more like this query that finds documents that are \"like\" the provided texts\n     * which is checked against the \"_all\" field.\n     * @param likeTexts the text to use when generating the 'More Like This' query.\n     ",
      "vertexLabel": "MoreLikeThisQueryBuilder moreLikeThisQuery()"
    },
    {
      "vertexName": "Method protected Key(Annotation annotation)  (Key.java)",
      "children": [
        {
          "name": "Method protected Key(Class<? extends Annotation> annotationType)  (Key.java)"
        }
      ],
      "comment": "\n     * Constructs a new key. Derives the type from this class's type parameter.\n     * <p>\n     * Clients create an empty anonymous subclass. Doing so embeds the type\n     * parameter in the anonymous class's type hierarchy so we can reconstitute it\n     * at runtime despite erasure.\n     * <p>\n     * Example usage for a binding of type {@code Foo} annotated with\n     * {@code @Bar}:\n     * <p>\n     * {@code new Key<Foo>(new Bar()) {}}.\n     ",
      "vertexLabel": "Key()"
    },
    {
      "vertexName": "Method public int consumeNetworkReads(TcpChannel channel, BytesReference bytesReference) throws IOException  (TcpTransport.java)",
      "children": [
        {
          "name": "Method public static int readMessageLength(BytesReference networkBytes) throws IOException  (TcpTransport.java)"
        }
      ],
      "comment": "\n     * Consumes bytes that are available from network reads. This method returns the number of bytes consumed\n     * in this call.\n     *\n     * @param channel        the channel read from\n     * @param bytesReference the bytes available to consume\n     * @return the number of bytes consumed\n     * @throws StreamCorruptedException              if the message header format is not recognized\n     * @throws TcpTransport.HttpOnTransportException if the message header appears to be an HTTP message\n     * @throws IllegalArgumentException              if the message length is greater that the maximum allowed frame size.\n     *                                               This is dependent on the available memory.\n     ",
      "vertexLabel": "int consumeNetworkReads()"
    },
    {
      "vertexName": "Method public void setMaxQueryTerms(int maxQueryTerms)  (XMoreLikeThis.java)",
      "children": [
        {
          "name": "Method public MoreLikeThisQueryBuilder maxQueryTerms(int maxQueryTerms)  (MoreLikeThisQueryBuilder.java)"
        }
      ],
      "comment": "\n     * Sets the maximum number of query terms that will be included in any generated query.\n     *\n     * @param maxQueryTerms the maximum number of query terms that will be included in any\n     * generated query.\n     ",
      "vertexLabel": "void setMaxQueryTerms()"
    },
    {
      "vertexName": "Method public UpdateRequest script(String script)  (UpdateRequest.java)",
      "children": [
        {
          "name": "Method public UpdateRequest script(String script, ScriptType scriptType)  (UpdateRequest.java)"
        }
      ],
      "comment": "\n     * The script to execute. Note, make sure not to send different script each\n     * times and instead use script params if possible with the same\n     * (automatically compiled) script.\n     *\n     * @deprecated Use {@link #script(Script)} instead\n     ",
      "vertexLabel": "UpdateRequest script()"
    },
    {
      "vertexName": "EnumConstant ALWAYS  (TermSuggestionBuilder.java)",
      "comment": " Suggest any matching suggest terms based on tokens in the suggest text. ",
      "vertexLabel": "EnumConstant ALWAYS"
    },
    {
      "vertexName": "Enum AllocationStatus  (UnassignedInfo.java)",
      "children": [
        {
          "name": "Enum Reason  (UnassignedInfo.java)"
        }
      ],
      "comment": "\n     * Captures the status of an unsuccessful allocation attempt for the shard,\n     * causing it to remain in the unassigned state.\n     *\n     * Note, ordering of the enum is important, make sure to add new values\n     * at the end and handle version serialization properly.\n     ",
      "vertexLabel": "Enum AllocationStatus"
    },
    {
      "vertexName": "Method public Set<DiscoveryNode> getNodes()  (NodesFaultDetection.java)",
      "comment": "\n     * Gets the current set of nodes involved in node fault detection.\n     * NB: For testing purposes.\n     ",
      "vertexLabel": "Set<DiscoveryNode> getNodes()"
    },
    {
      "vertexName": "Method public void setMinimumShouldMatch(String minimumShouldMatch)  (MoreLikeThisQuery.java)",
      "children": [
        {
          "name": "Method public MoreLikeThisQueryBuilder minimumShouldMatch(String minimumShouldMatch)  (MoreLikeThisQueryBuilder.java)"
        }
      ],
      "comment": "\n     * Number of terms that must match the generated query expressed in the\n     * common syntax for minimum should match. Defaults to {@code 30%}.\n     *\n     * @see    org.elasticsearch.common.lucene.search.Queries#calculateMinShouldMatch(int, String)\n     ",
      "vertexLabel": "void setMinimumShouldMatch()"
    },
    {
      "vertexName": "Method public FieldSortBuilder setNestedFilter(QueryBuilder nestedFilter)  (FieldSortBuilder.java)",
      "comment": "\n     * Sets the nested filter that the nested objects should match with in order\n     * to be taken into account for sorting.\n     *\n     * @deprecated set nested sort with {@link #setNestedSort(NestedSortBuilder)} and retrieve with {@link #getNestedSort()}\n     ",
      "vertexLabel": "FieldSortBuilder setNestedFilter()"
    },
    {
      "vertexName": "Method public void deleteSnapshot(final String repositoryName, final String snapshotName, final DeleteSnapshotListener listener, final boolean immediatePriority)  (SnapshotsService.java)",
      "children": [
        {
          "name": "Method private void deleteSnapshot(final Snapshot snapshot, final DeleteSnapshotListener listener, final long repositoryStateId, final boolean immediatePriority)  (SnapshotsService.java)"
        }
      ],
      "comment": "\n     * Deletes a snapshot from the repository, looking up the {@link Snapshot} reference before deleting.\n     * If the snapshot is still running cancels the snapshot first and then deletes it from the repository.\n     *\n     * @param repositoryName  repositoryName\n     * @param snapshotName    snapshotName\n     * @param listener        listener\n     ",
      "vertexLabel": "void deleteSnapshot()"
    },
    {
      "vertexName": "Method public DateHistogramAggregationBuilder minDocCount(long minDocCount)  (DateHistogramAggregationBuilder.java)",
      "comment": " Set the minimum count of matching documents that buckets need to have\n     *  and return this builder so that calls can be chained. ",
      "vertexLabel": "DateHistogramAggregationBuilder minDocCount()"
    },
    {
      "vertexName": "Method boolean mightMatchNonNestedDocs(String field, String nestedPath)  (NestedHelper.java)",
      "children": [
        {
          "name": "Method public boolean mightMatchNonNestedDocs(Query query, String nestedPath)  (NestedHelper.java)"
        }
      ],
      "comment": " Returns true if a query on the given field might match parent documents\n     *  or documents that are nested under a different path. ",
      "vertexLabel": "boolean mightMatchNonNestedDocs()"
    },
    {
      "vertexName": "Method public boolean enoughShardsActive(final ClusterState clusterState, final String... indices)  (ActiveShardCount.java)",
      "comment": "\n     * Returns true iff the given cluster state's routing table contains enough active\n     * shards for the given indices to meet the required shard count represented by this instance.\n     ",
      "vertexLabel": "boolean enoughShardsActive()"
    },
    {
      "vertexName": "Method public static int readFromFileChannel(FileChannel channel, long channelPosition, byte[] dest, int destOffset, int length) throws IOException  (Channels.java)",
      "children": [
        {
          "name": "Method public static int readFromFileChannel(FileChannel channel, long channelPosition, ByteBuffer dest) throws IOException  (Channels.java)"
        },
        {
          "name": "Method public static void readFromFileChannelWithEofException(FileChannel channel, long channelPosition, byte[] dest, int destOffset, int length) throws IOException  (Channels.java)"
        }
      ],
      "comment": "\n     * read <i>length</i> bytes from <i>position</i> of a file channel.\n     *\n     * @param channel         channel to read from\n     * @param channelPosition position to read from\n     * @param dest            destination byte array to put data in\n     * @param destOffset      offset in dest to read into\n     * @param length          number of bytes to read\n     * @return total bytes read or -1 if an attempt was made to read past EOF. The method always tries to read all the bytes\n     * that will fit in the destination byte buffer.\n     ",
      "vertexLabel": "int readFromFileChannel()"
    },
    {
      "vertexName": "Method public static Set<InjectionPoint> forStaticMethodsAndFields(TypeLiteral type)  (InjectionPoint.java)",
      "children": [
        {
          "name": "Method Set<InjectionPoint> getInjectableMembers()  (ConstructorBinding.java)"
        }
      ],
      "comment": "\n     * Returns all static method and field injection points on {@code type}.\n     *\n     * @return a possibly empty set of injection points. The set has a specified iteration order. All\n     *         fields are returned and then all methods. Within the fields, supertype fields are returned\n     *         before subtype fields. Similarly, supertype methods are returned before subtype methods.\n     * @throws ConfigurationException if there is a malformed injection point on {@code type}, such as\n     *                                a field with multiple binding annotations. The exception's {@link\n     *                                ConfigurationException#getPartialValue() partial value} is a {@code Set<InjectionPoint>}\n     *                                of the valid injection points.\n     ",
      "vertexLabel": "Set<InjectionPoint> forStaticsAndFields()"
    },
    {
      "vertexName": "Method public boolean forceMove()  (MoveDecision.java)",
      "children": [
        {
          "name": "Method public boolean canRemain()  (MoveDecision.java)"
        }
      ],
      "comment": "\n     * Returns {@code true} if the shard cannot remain on its current node and can be moved,\n     * returns {@code false} otherwise.  If {@link #isDecisionTaken()} returns {@code false},\n     * then invoking this method will throw an {@code IllegalStateException}.\n     ",
      "vertexLabel": "boolean forceMove()"
    },
    {
      "vertexName": "Method public TermSuggestionBuilder prefixLength(int prefixLength)  (TermSuggestionBuilder.java)",
      "children": [
        {
          "name": "Method public DirectCandidateGeneratorBuilder prefixLength(int prefixLength)  (DirectCandidateGeneratorBuilder.java)"
        }
      ],
      "comment": "\n     * Sets the number of minimal prefix characters that must match in order be\n     * a candidate suggestion. Defaults to 1. Increasing this number improves\n     * suggest performance. Usually misspellings don't occur in the beginning of\n     * terms.\n     ",
      "vertexLabel": "TermSuggestionBuilder prefixLength()"
    },
    {
      "vertexName": "Method public RestoreSnapshotRequest ignoreIndexSettings(List<String> ignoreIndexSettings)  (RestoreSnapshotRequest.java)",
      "children": [
        {
          "name": "Method public RestoreSnapshotRequest ignoreIndexSettings(String... ignoreIndexSettings)  (RestoreSnapshotRequest.java)"
        }
      ],
      "comment": "\n     * Sets the list of index settings and index settings groups that shouldn't be restored from snapshot\n     ",
      "vertexLabel": "RestoreSnapshotRequest ignoreIndexSettings()"
    },
    {
      "vertexName": "Method static void check(final BootstrapContext context, final BoundTransportAddress boundTransportAddress, List<BootstrapCheck> additionalChecks) throws NodeValidationException  (BootstrapChecks.java)",
      "children": [
        {
          "name": "Class BootstrapChecks  (BootstrapChecks.java)"
        }
      ],
      "comment": "\n     * Executes the bootstrap checks if the node has the transport protocol bound to a non-loopback interface. If the system property\n     * {@code es.enforce.bootstrap.checks} is set to {@code true} then the bootstrap checks will be enforced regardless of whether or not\n     * the transport protocol is bound to a non-loopback interface.\n     *\n     * @param context              the current node bootstrap context\n     * @param boundTransportAddress the node network bindings\n     ",
      "vertexLabel": "void check()"
    },
    {
      "vertexName": "Class TypeConverterBinding  (TypeConverterBinding.java)",
      "comment": "\n * Registration of type converters for matching target types. Instances are created\n * explicitly in a module using {@link org.elasticsearch.common.inject.Binder#convertToTypes(Matcher,\n * TypeConverter) convertToTypes()} statements:\n * <pre>\n *     convertToTypes(Matchers.only(DateTime.class), new DateTimeConverter());</pre>\n *\n * @author jessewilson@google.com (Jesse Wilson)\n * @since 2.0\n ",
      "vertexLabel": "Class TypeConverterBinding"
    },
    {
      "vertexName": "Method public boolean cancel(String reason)  (TaskManager.java)",
      "children": [
        {
          "name": "Method public boolean cancel(String reason, Runnable listener)  (TaskManager.java)"
        }
      ],
      "comment": "\n         * Marks task as cancelled.\n         * <p>\n         * Returns true if cancellation was successful, false otherwise.\n         ",
      "vertexLabel": "boolean cancel()"
    },
    {
      "vertexName": "Method public void setForceQuoteAnalyzer(Analyzer analyzer)  (QueryStringQueryParser.java)",
      "children": [
        {
          "name": "Method public void setForceAnalyzer(Analyzer analyzer)  (QueryStringQueryParser.java)"
        }
      ],
      "comment": "\n     * @param analyzer Force the provided analyzer to be used for all phrase query analysis regardless of the field.\n     ",
      "vertexLabel": "void setForceQuoteAnalyzer()"
    },
    {
      "vertexName": "Method public UpdateRequestBuilder setUpsert(XContentBuilder source)  (UpdateRequestBuilder.java)",
      "children": [
        {
          "name": "Method public UpdateRequest upsert(byte[] source, XContentType xContentType)  (UpdateRequest.java)"
        }
      ],
      "comment": "\n     * Sets the doc source of the update request to be used when the document does not exists.\n     ",
      "vertexLabel": "UpdateRequestBuilder setUpsert()"
    },
    {
      "vertexName": "Field size  (AbstractBulkByScrollRequest.java)",
      "comment": "\n     * Maximum number of processed documents. Defaults to -1 meaning process all\n     * documents.\n     ",
      "vertexLabel": "Field size"
    },
    {
      "vertexName": "Method static GeometryCollectionBuilder parseGeometries(XContentParser parser, GeoShapeFieldMapper mapper) throws IOException  (GeoJsonParser.java)",
      "comment": "\n     * Parse the geometries array of a GeometryCollection\n     *\n     * @param parser Parser that will be read from\n     * @return Geometry[] geometries of the GeometryCollection\n     * @throws IOException Thrown if an error occurs while reading from the XContentParser\n     ",
      "vertexLabel": "GeometryCollectionBuilder parseGeometries()"
    },
    {
      "vertexName": "Method public static MapDiff<Integer, T, ImmutableOpenIntMap<T>> readImmutableOpenIntMapDiff(StreamInput in, KeySerializer<Integer> keySerializer, Reader<T> reader, Reader<Diff<T>> diffReader) throws IOException  (DiffableUtils.java)",
      "children": [
        {
          "name": "Method public static MapDiff<K, T, Map<K, T>> readJdkMapDiff(StreamInput in, KeySerializer<K> keySerializer, Reader<T> reader, Reader<Diff<T>> diffReader) throws IOException  (DiffableUtils.java)"
        }
      ],
      "comment": "\n     * Loads an object that represents difference between two ImmutableOpenIntMaps of Diffable objects using Diffable proto object\n     ",
      "vertexLabel": "MapDiff<Integer, T, ImmutableOpenIntMap<T>> readImmutableOpenIntMapDiff()"
    },
    {
      "vertexName": "Method public Builder updateNumberOfReplicas(final int numberOfReplicas, final String[] indices)  (MetaData.java)",
      "children": [
        {
          "name": "Method public Builder updateNumberOfReplicas(final int numberOfReplicas, final String[] indices)  (RoutingTable.java)"
        }
      ],
      "comment": "\n         * Update the number of replicas for the specified indices.\n         *\n         * @param numberOfReplicas the number of replicas\n         * @param indices          the indices to update the number of replicas for\n         * @return the builder\n         ",
      "vertexLabel": "Builder updateNumberOfReplicas()"
    },
    {
      "vertexName": "Class ConstantScoreQueryBuilder  (ConstantScoreQueryBuilder.java)",
      "comment": "\n * A query that wraps a filter and simply returns a constant score equal to the\n * query boost for every document in the filter.\n ",
      "vertexLabel": "Class ConstantScoreQueryBuilder"
    },
    {
      "vertexName": "Method public TermsQueryBuilder(String fieldName, long... values)  (TermsQueryBuilder.java)",
      "children": [
        {
          "name": "Method public TermsQueryBuilder(String fieldName, String... values)  (TermsQueryBuilder.java)"
        }
      ],
      "comment": "\n     * A filter for a field based on several terms matching on any of them.\n     *\n     * @param fieldName The field name\n     * @param values The terms\n     ",
      "vertexLabel": "TermsQueryBuilder()"
    },
    {
      "vertexName": "Method public FuzzyQueryBuilder(String fieldName, float value)  (FuzzyQueryBuilder.java)",
      "children": [
        {
          "name": "Method public FuzzyQueryBuilder(String fieldName, String value)  (FuzzyQueryBuilder.java)"
        }
      ],
      "comment": "\n     * Constructs a new fuzzy query.\n     *\n     * @param fieldName  The name of the field\n     * @param value The value of the text\n     ",
      "vertexLabel": "FuzzyQueryBuilder()"
    },
    {
      "vertexName": "Method private static void addSocketPermissionForHttp(final Permissions policy, final Settings settings)  (Security.java)",
      "comment": "\n     * Add dynamic {@link SocketPermission} based on HTTP settings.\n     *\n     * @param policy the {@link Permissions} instance to apply the dynamic {@link SocketPermission}s to.\n     * @param settings the {@link Settings} instance to read the HTTP settings from\n     ",
      "vertexLabel": "void addSocketPermissionForHttp()"
    },
    {
      "vertexName": "Method void addError(Throwable t)  (TypeEncounter.java)",
      "children": [
        {
          "name": "Method void addError(Throwable t)  (Binder.java)"
        }
      ],
      "comment": "\n     * Records an exception for type {@code I}, the full details of which will be logged, and the\n     * message of which will be presented to the user at a later time. If your type listener calls\n     * something that you worry may fail, you should catch the exception and pass it to this method.\n     ",
      "vertexLabel": "void addError()"
    },
    {
      "vertexName": "Class Builder  (DocWriteResponse.java)",
      "children": [
        {
          "name": "Class Builder  (IndexResponse.java)"
        }
      ],
      "comment": "\n     * Base class of all {@link DocWriteResponse} builders. These {@link DocWriteResponse.Builder} are used during\n     * xcontent parsing to temporarily store the parsed values, then the {@link Builder#build()} method is called to\n     * instantiate the appropriate {@link DocWriteResponse} with the parsed values.\n     ",
      "vertexLabel": "Class Builder"
    },
    {
      "vertexName": "Method public ClusterHealthRequest waitForNoInitializingShards(boolean waitForNoInitializingShards)  (ClusterHealthRequest.java)",
      "children": [
        {
          "name": "Method public ClusterHealthRequest waitForNoRelocatingShards(boolean waitForNoRelocatingShards)  (ClusterHealthRequest.java)"
        }
      ],
      "comment": "\n     * Sets whether the request should wait for there to be no initializing shards before\n     * retrieving the cluster health status.  Defaults to {@code false}, meaning the\n     * operation does not wait on there being no more initializing shards.  Set to <code>true</code>\n     * to wait until the number of initializing shards in the cluster is 0.\n     ",
      "vertexLabel": "ClusterHealthRequest waitForNoInitializingShards()"
    },
    {
      "vertexName": "Method public void submitStateUpdateTasks(final String source, final Map<T, ClusterStateTaskListener> tasks, final ClusterStateTaskConfig config, final ClusterStateTaskExecutor<T> executor)  (ClusterService.java)",
      "comment": "\n     * Submits a batch of cluster state update tasks; submitted updates are guaranteed to be processed together,\n     * potentially with more tasks of the same executor.\n     *\n     * @param source   the source of the cluster state update task\n     * @param tasks    a map of update tasks and their corresponding listeners\n     * @param config   the cluster state update task configuration\n     * @param executor the cluster state update task executor; tasks\n     *                 that share the same executor will be executed\n     *                 batches on this executor\n     * @param <T>      the type of the cluster state update task state\n     *\n     ",
      "vertexLabel": "void submitStateUpdateTasks()"
    },
    {
      "vertexName": "Method public ObjectArray<T> grow(ObjectArray<T> array, long minSize)  (BigArrays.java)",
      "children": [
        {
          "name": "Method public ByteArray grow(ByteArray array, long minSize)  (BigArrays.java)"
        }
      ],
      "comment": " Grow an array to a size that is larger than <code>minSize</code>,\n     * preserving content, and potentially reusing part of the provided array. ",
      "vertexLabel": "ObjectArray<T> grow()"
    },
    {
      "vertexName": "Interface WriteResponse  (WriteResponse.java)",
      "children": [
        {
          "name": "Interface WriteRequest  (WriteRequest.java)"
        }
      ],
      "comment": "\n * Interface implemented by responses for actions that modify the documents in an index like {@link IndexResponse}, {@link UpdateResponse},\n * and {@link BulkResponse}. Rather than implement this directly most implementers should extend {@link DocWriteResponse}.\n ",
      "vertexLabel": "Interface WriteResponse"
    },
    {
      "vertexName": "Method public static TermQueryBuilder termQuery(String name, Object value)  (QueryBuilders.java)",
      "children": [
        {
          "name": "Method public static TermQueryBuilder termQuery(String name, String value)  (QueryBuilders.java)"
        }
      ],
      "comment": "\n     * A Query that matches documents containing a term.\n     *\n     * @param name  The name of the field\n     * @param value The value of the term\n     ",
      "vertexLabel": "TermQueryBuilder termQuery()"
    },
    {
      "vertexName": "Method public static MessageDigest sha256()  (MessageDigests.java)",
      "children": [
        {
          "name": "Method public static MessageDigest md5()  (MessageDigests.java)"
        }
      ],
      "comment": "\n     * Returns a {@link MessageDigest} instance for SHA-256 digests;\n     * note that the instance returned is thread local and must not be\n     * shared amongst threads.\n     *\n     * @return a thread local {@link MessageDigest} instance that\n     * provides SHA-256 message digest functionality.\n     ",
      "vertexLabel": "MessageDigest sha256()"
    },
    {
      "vertexName": "Method public BaseTermQueryBuilder(String fieldName, Object value)  (BaseTermQueryBuilder.java)",
      "children": [
        {
          "name": "Method public Object to()  (RangeQueryBuilder.java)"
        }
      ],
      "comment": "\n     * Constructs a new base term query.\n     * In case value is assigned to a string, we internally convert it to a {@link BytesRef}\n     * because in {@link TermQueryBuilder} and {@link SpanTermQueryBuilder} string values are parsed to {@link BytesRef}\n     * and we want internal representation of query to be equal regardless of whether it was created from XContent or via Java API.\n     *\n     * @param fieldName  The name of the field\n     * @param value The value of the term\n     ",
      "vertexLabel": "BaseTermQueryBuilder()"
    },
    {
      "vertexName": "Method public MultiGetShardRequest preference(String preference)  (MultiGetShardRequest.java)",
      "children": [
        {
          "name": "Method public MultiGetRequest preference(String preference)  (MultiGetRequest.java)"
        }
      ],
      "comment": "\n     * Sets the preference to execute the search. Defaults to randomize across shards. Can be set to\n     * {@code _local} to prefer local shards or a custom value, which guarantees that the same order\n     * will be used across different requests.\n     ",
      "vertexLabel": "MultiGetShardRequest preference()"
    },
    {
      "vertexName": "Method AnnotatedElementBuilder expose(TypeLiteral<?> type)  (PrivateBinder.java)",
      "comment": "\n     * Makes a binding for {@code type} available to the enclosing environment. Use {@link\n     * AnnotatedElementBuilder#annotatedWith(Class) annotatedWith()} to expose {@code type} with a\n     * binding annotation.\n     ",
      "vertexLabel": "AnnotatedElementBuilder expose()"
    },
    {
      "vertexName": "Method public static boolean isEmpty(CharSequence str)  (Strings.java)",
      "comment": "\n     * Check that the given CharSequence is either <code>null</code> or of length 0.\n     * Note: Will return <code>false</code> for a CharSequence that purely consists of whitespace.\n     * <pre>\n     * StringUtils.isEmpty(null) = true\n     * StringUtils.isEmpty(\"\") = true\n     * StringUtils.isEmpty(\" \") = false\n     * StringUtils.isEmpty(\"Hello\") = false\n     * </pre>\n     *\n     * @param str the CharSequence to check (may be <code>null</code>)\n     * @return <code>true</code> if the CharSequence is either null or has a zero length\n     ",
      "vertexLabel": "boolean isEmpty()"
    },
    {
      "vertexName": "Method Provider<T> getProvider(Key<T> key)  (Binder.java)",
      "children": [
        {
          "name": "Method Provider<T> getProvider(Key<T> key)  (TypeEncounter.java)"
        }
      ],
      "comment": "\n     * Returns the provider used to obtain instances for the given injection key.\n     * The returned will not be valid until the {@link Injector} has been\n     * created. The provider will throw an {@code IllegalStateException} if you\n     * try to use it beforehand.\n     *\n     * @since 2.0\n     ",
      "vertexLabel": "Provider<T> getProvider()"
    },
    {
      "vertexName": "Method public String getNestedPath()  (GeoDistanceSortBuilder.java)",
      "children": [
        {
          "name": "Method public GeoDistanceSortBuilder setNestedPath(String nestedPath)  (GeoDistanceSortBuilder.java)"
        }
      ],
      "comment": "\n     * Returns the nested path if sorting occurs on a field that is inside a nested object. By default when sorting on a\n     * field inside a nested object, the nearest upper nested object is selected as nested path.\n     * @deprecated set nested sort with {@link #setNestedSort(NestedSortBuilder)}\n     *             and retrieve with {@link #getNestedSort()}\n     *",
      "vertexLabel": "String getNestedPath()"
    },
    {
      "vertexName": "Method public MovAvgPipelineAggregationBuilder model(MovAvgModel model)  (MovAvgPipelineAggregationBuilder.java)",
      "children": [
        {
          "name": "Method public MovAvgPipelineAggregationBuilder modelBuilder(MovAvgModelBuilder model)  (MovAvgPipelineAggregationBuilder.java)"
        }
      ],
      "comment": "\n     * Sets a MovAvgModel for the Moving Average. The model is used to\n     * define what type of moving average you want to use on the series\n     *\n     * @param model\n     *            A MovAvgModel which has been prepopulated with settings\n     ",
      "vertexLabel": "MovAvgPipelineAggregationBuilder model()"
    },
    {
      "vertexName": "Method public ClusterStateHealth(final ClusterState clusterState)  (ClusterStateHealth.java)",
      "comment": "\n     * Creates a new <code>ClusterStateHealth</code> instance considering the current cluster state and all indices in the cluster.\n     *\n     * @param clusterState The current cluster state. Must not be null.\n     ",
      "vertexLabel": "ClusterStateHealth()"
    },
    {
      "vertexName": "Method public CommonStatsFlags types(String... types)  (CommonStatsFlags.java)",
      "comment": "\n     * Document types to return stats for. Mainly affects {@link Flag#Indexing} when\n     * enabled, returning specific indexing stats for those types.\n     ",
      "vertexLabel": "CommonStatsFlags types()"
    },
    {
      "vertexName": "Class TermVectorsRequest  (TermVectorsRequest.java)",
      "comment": "\n * Request returning the term vector (doc frequency, positions, offsets) for a\n * document.\n * <p>\n * Note, the {@link #index()}, {@link #type(String)} and {@link #id(String)} are\n * required.\n ",
      "vertexLabel": "Class TermVectorsRequest"
    },
    {
      "vertexName": "Class DeleteRequest  (DeleteRequest.java)",
      "comment": "\n * A request to delete a document from an index based on its type and id. Best created using\n * {@link org.elasticsearch.client.Requests#deleteRequest(String)}.\n * <p>\n * The operation requires the {@link #index()}, {@link #type(String)} and {@link #id(String)} to\n * be set.\n *\n * @see DeleteResponse\n * @see org.elasticsearch.client.Client#delete(DeleteRequest)\n * @see org.elasticsearch.client.Requests#deleteRequest(String)\n ",
      "vertexLabel": "Class DeleteRequest"
    },
    {
      "vertexName": "Method public boolean isSame(StoreFileMetaData md)  (BlobStoreIndexShardSnapshot.java)",
      "comment": "\n         * Checks if a file in a store is the same file\n         *\n         * @param md file in a store\n         * @return true if file in a store this this file have the same checksum and length\n         ",
      "vertexLabel": "boolean isSame()"
    },
    {
      "vertexName": "Method private PriorityQueue<ScoreTerm> createQueue(Map<String, Int> words, String... fieldNames) throws IOException  (XMoreLikeThis.java)",
      "children": [
        {
          "name": "Method private PriorityQueue<ScoreTerm> createQueue(Map<String, Int> words) throws IOException  (XMoreLikeThis.java)"
        }
      ],
      "comment": "\n     * Create a PriorityQueue from a word-&gt;tf map.\n     *\n     * @param words a map of words keyed on the word(String) with Int objects as the values.\n     * @param fieldNames an array of field names to override defaults.\n     ",
      "vertexLabel": "PriorityQueue<ScoreTerm> createQueue()"
    },
    {
      "vertexName": "Method public boolean updateSettings(Settings toApply, Settings.Builder target, Settings.Builder updates, String type)  (AbstractScopedSettings.java)",
      "comment": "\n     * Updates a target settings builder with new, updated or deleted settings from a given settings builder.\n     *\n     * @param toApply the new settings to apply\n     * @param target the target settings builder that the updates are applied to. All keys that have explicit null value in toApply will be\n     *        removed from this builder\n     * @param updates a settings builder that holds all updates applied to target\n     * @param type a free text string to allow better exceptions messages\n     * @return <code>true</code> if the target has changed otherwise <code>false</code>\n     ",
      "vertexLabel": "boolean updateSettings()"
    },
    {
      "vertexName": "Method public GroupShardsIterator allActiveShardsGrouped(String[] indices, boolean includeEmpty, boolean includeRelocationTargets)  (RoutingTable.java)",
      "comment": "\n     * Return GroupShardsIterator where each active shard routing has it's own shard iterator.\n     *\n     * @param includeEmpty             if true, a shard iterator will be added for non-assigned shards as well\n     * @param includeRelocationTargets if true, an <b>extra</b> shard iterator will be added for relocating shards. The extra\n     *                                 iterator contains a single ShardRouting pointing at the relocating target\n     ",
      "vertexLabel": "GroupShardsIterator allActiveShardsGrouped()"
    },
    {
      "vertexName": "Method public HistogramAggregationBuilder minDocCount(long minDocCount)  (HistogramAggregationBuilder.java)",
      "children": [
        {
          "name": "Method public DateHistogramAggregationBuilder minDocCount(long minDocCount)  (DateHistogramAggregationBuilder.java)"
        }
      ],
      "comment": " Set the minimum count of matching documents that buckets need to have\n     *  and return this builder so that calls can be chained. ",
      "vertexLabel": "HistogramAggregationBuilder minDocCount()"
    },
    {
      "vertexName": "Method T getInstance(Class<T> type)  (Injector.java)",
      "children": [
        {
          "name": "Method T getInstance(Key<T> key)  (Injector.java)"
        }
      ],
      "comment": "\n     * Returns the appropriate instance for the given injection type; equivalent to {@code\n     * getProvider(type).get()}. When feasible, avoid using this method, in favor of having Guice\n     * inject your dependencies ahead of time.\n     *\n     * @throws ConfigurationException if this injector cannot find or create the provider.\n     * @throws ProvisionException     if there was a runtime failure while providing an instance.\n     ",
      "vertexLabel": "T getInstance()"
    },
    {
      "vertexName": "Method public static TermQueryBuilder termQuery(String name, long value)  (QueryBuilders.java)",
      "children": [
        {
          "name": "Method public static TermQueryBuilder termQuery(String name, String value)  (QueryBuilders.java)"
        }
      ],
      "comment": "\n     * A Query that matches documents containing a term.\n     *\n     * @param name  The name of the field\n     * @param value The value of the term\n     ",
      "vertexLabel": "TermQueryBuilder termQuery()"
    },
    {
      "vertexName": "Method public static void setThreadContext(ThreadContext threadContext)  (DeprecationLogger.java)",
      "comment": "\n     * Set the {@link ThreadContext} used to add deprecation headers to network responses.\n     * <p>\n     * This is expected to <em>only</em> be invoked by the {@code Node}'s constructor (therefore once outside of tests).\n     *\n     * @param threadContext The thread context owned by the {@code ThreadPool} (and implicitly a {@code Node})\n     * @throws IllegalStateException if this {@code threadContext} has already been set\n     ",
      "vertexLabel": "void setThreadContext()"
    },
    {
      "vertexName": "Method public static boolean simpleMatch(String pattern, String str)  (Regex.java)",
      "comment": "\n     * Match a String against the given pattern, supporting the following simple\n     * pattern styles: \"xxx*\", \"*xxx\", \"*xxx*\" and \"xxx*yyy\" matches (with an\n     * arbitrary number of pattern parts), as well as direct equality.\n     *\n     * @param pattern the pattern to match against\n     * @param str     the String to match\n     * @return whether the String matches the given pattern\n     ",
      "vertexLabel": "boolean simpleMatch()"
    },
    {
      "vertexName": "Method public IndexRequest setShardId(ShardId shardId)  (IndexRequest.java)",
      "comment": "\n     * Override this method from ReplicationAction, this is where we are storing our state in the request object (which we really shouldn't\n     * do). Once the transport client goes away we can move away from making this available, but in the meantime this is dangerous to set or\n     * use because the IndexRequest object will always be wrapped in a bulk request envelope, which is where this *should* be set.\n     ",
      "vertexLabel": "IndexRequest setShardId()"
    },
    {
      "vertexName": "Method public MoveDecision decideMove(final ShardRouting shardRouting)  (BalancedShardsAllocator.java)",
      "children": [
        {
          "name": "Method public static MoveDecision cannotRemain(Decision canRemainDecision, AllocationDecision allocationDecision, DiscoveryNode assignedNode, List<NodeAllocationResult> nodeDecisions)  (MoveDecision.java)"
        }
      ],
      "comment": "\n         * Makes a decision on whether to move a started shard to another node.  The following rules apply\n         * to the {@link MoveDecision} return object:\n         *   1. If the shard is not started, no decision will be taken and {@link MoveDecision#isDecisionTaken()} will return false.\n         *   2. If the shard is allowed to remain on its current node, no attempt will be made to move the shard and\n         *      {@link MoveDecision#canRemainDecision} will have a decision type of YES.  All other fields in the object will be null.\n         *   3. If the shard is not allowed to remain on its current node, then {@link MoveDecision#getAllocationDecision()} will be\n         *      populated with the decision of moving to another node.  If {@link MoveDecision#forceMove()} ()} returns {@code true}, then\n         *      {@link MoveDecision#targetNode} will return a non-null value, otherwise the assignedNodeId will be null.\n         *   4. If the method is invoked in explain mode (e.g. from the cluster allocation explain APIs), then\n         *      {@link MoveDecision#nodeDecisions} will have a non-null value.\n         ",
      "vertexLabel": "MoveDecision decideMove()"
    },
    {
      "vertexName": "Method public Index concreteWriteIndex(ClusterState state, IndicesRequest request)  (IndexNameExpressionResolver.java)",
      "comment": "\n     * Utility method that allows to resolve an index expression to its corresponding single write index.\n     *\n     * @param state             the cluster state containing all the data to resolve to expression to a concrete index\n     * @param request           The request that defines how the an alias or an index need to be resolved to a concrete index\n     *                          and the expression that can be resolved to an alias or an index name.\n     * @throws IllegalArgumentException if the index resolution does not lead to an index, or leads to more than one index\n     * @return the write index obtained as a result of the index resolution\n     ",
      "vertexLabel": "Index concreteWriteIndex()"
    },
    {
      "vertexName": "Method public double[] predict(Collection<Double> values, int numPredictions)  (MovAvgModel.java)",
      "children": [
        {
          "name": "Method public abstract double next(Collection<Double> values)  (MovAvgModel.java)"
        }
      ],
      "comment": "\n     * Predicts the next `n` values in the series.\n     *\n     * @param values            Collection of numerics to movingAvg, usually windowed\n     * @param numPredictions    Number of newly generated predictions to return\n     * @return                  Returns an array of doubles, since most smoothing methods operate on floating points\n     ",
      "vertexLabel": "double[] predict()"
    },
    {
      "vertexName": "Method public RestoreSnapshotRequest settings(String source, XContentType xContentType)  (RestoreSnapshotRequest.java)",
      "children": [
        {
          "name": "Method public RestoreSnapshotRequestBuilder setSettings(Map<String, Object> source)  (RestoreSnapshotRequestBuilder.java)"
        },
        {
          "name": "Method public PutRepositoryRequest settings(String source, XContentType xContentType)  (PutRepositoryRequest.java)"
        }
      ],
      "comment": "\n     * Sets repository-specific restore settings in JSON or YAML format\n     * <p>\n     * See repository documentation for more information.\n     *\n     * @param source repository-specific snapshot settings\n     * @param xContentType the content type of the source\n     * @return this request\n     ",
      "vertexLabel": "RestoreSnapshotRequest settings()"
    },
    {
      "vertexName": "Method public abstract A create(List<B> buckets)  (InternalMultiBucketAggregation.java)",
      "comment": "\n     * Create a new copy of this {@link Aggregation} with the same settings as\n     * this {@link Aggregation} and contains the provided buckets.\n     *\n     * @param buckets\n     *            the buckets to use in the new {@link Aggregation}\n     * @return the new {@link Aggregation}\n     ",
      "vertexLabel": "abstract A create()"
    },
    {
      "vertexName": "Method public GetRequest(String index, String type, String id)  (GetRequest.java)",
      "children": [
        {
          "name": "Method TermVectorsRequestBuilder prepareTermVectors(String index, String type, String id)  (Client.java)"
        },
        {
          "name": "Method public IndexRequest(String index, String type, String id)  (IndexRequest.java)"
        }
      ],
      "comment": "\n     * Constructs a new get request against the specified index with the type and id.\n     *\n     * @param index The index to get the document from\n     * @param type  The type of the document\n     * @param id    The id of the document\n     ",
      "vertexLabel": "GetRequest()"
    },
    {
      "vertexName": "Method public ClusterSearchShardsRequestBuilder setPreference(String preference)  (ClusterSearchShardsRequestBuilder.java)",
      "children": [
        {
          "name": "Method public SearchRequest preference(String preference)  (SearchRequest.java)"
        }
      ],
      "comment": "\n     * Sets the preference to execute the search. Defaults to randomize across shards. Can be set to\n     * {@code _local} to prefer local shards or a custom value, which guarantees that the same order\n     * will be used across different requests.\n     ",
      "vertexLabel": "ClusterSearchShardsRequestBuilder setPreference()"
    },
    {
      "vertexName": "Method void typesExists(TypesExistsRequest request, ActionListener<TypesExistsResponse> listener)  (IndicesAdminClient.java)",
      "children": [
        {
          "name": "Method ActionFuture<TypesExistsResponse> typesExists(TypesExistsRequest request)  (IndicesAdminClient.java)"
        }
      ],
      "comment": "\n     * Types exists.\n     *\n     * @deprecated Types are deprecated and are in the process of being removed.\n     * @param request  The types exists\n     * @param listener A listener to be notified with a result\n     ",
      "vertexLabel": "void typesExists()"
    },
    {
      "vertexName": "Method public static SortedBinaryDocValues toString(final SortedNumericDoubleValues values)  (FieldData.java)",
      "children": [
        {
          "name": "Method public static SortedBinaryDocValues toString(final SortedNumericDocValues values)  (FieldData.java)"
        }
      ],
      "comment": "\n     * Return a {@link String} representation of the provided values. That is\n     * typically used for scripts or for the `map` execution mode of terms aggs.\n     * NOTE: this is very slow!\n     ",
      "vertexLabel": "SortedBinaryDocValues toString()"
    },
    {
      "vertexName": "Method public RestoreSnapshotRequest indices(List<String> indices)  (RestoreSnapshotRequest.java)",
      "children": [
        {
          "name": "Method public RestoreSnapshotRequest indices(String... indices)  (RestoreSnapshotRequest.java)"
        }
      ],
      "comment": "\n     * Sets the list of indices that should be restored from snapshot\n     * <p>\n     * The list of indices supports multi-index syntax. For example: \"+test*\" ,\"-test42\" will index all indices with\n     * prefix \"test\" except index \"test42\". Aliases are not supported. An empty list or {\"_all\"} will restore all open\n     * indices in the snapshot.\n     *\n     * @param indices list of indices\n     * @return this request\n     ",
      "vertexLabel": "RestoreSnapshotRequest indices()"
    },
    {
      "vertexName": "Method public FunctionScoreQueryBuilder boostMode(CombineFunction combineFunction)  (FunctionScoreQueryBuilder.java)",
      "comment": "\n     * Boost mode defines how the combined result of score functions will influence the final score together with the sub query score.\n     * @see CombineFunction\n     ",
      "vertexLabel": "FunctionScoreQueryBuilder boostMode()"
    },
    {
      "vertexName": "Method public MatchQueryBuilder zeroTermsQuery(MatchQuery.ZeroTermsQuery zeroTermsQuery)  (MatchQueryBuilder.java)",
      "children": [
        {
          "name": "Method public MatchPhraseQueryBuilder zeroTermsQuery(ZeroTermsQuery zeroTermsQuery)  (MatchPhraseQueryBuilder.java)"
        }
      ],
      "comment": "\n     * Sets query to use in case no query terms are available, e.g. after analysis removed them.\n     * Defaults to {@link MatchQuery.ZeroTermsQuery#NONE}, but can be set to\n     * {@link MatchQuery.ZeroTermsQuery#ALL} instead.\n     ",
      "vertexLabel": "MatchQueryBuilder zeroTermsQuery()"
    },
    {
      "vertexName": "Method public BaseTermQueryBuilder(String fieldName, int value)  (BaseTermQueryBuilder.java)",
      "children": [
        {
          "name": "Method public BaseTermQueryBuilder(String fieldName, String value)  (BaseTermQueryBuilder.java)"
        }
      ],
      "comment": "\n     * Constructs a new base term query.\n     *\n     * @param fieldName  The name of the field\n     * @param value The value of the term\n     ",
      "vertexLabel": "BaseTermQueryBuilder()"
    },
    {
      "vertexName": "Method public NumericDocValues select(final SortedNumericDocValues values, final long missingValue, final BitSet parentDocs, final DocIdSetIterator childDocs, int maxDoc, int maxChildren) throws IOException  (MultiValueMode.java)",
      "children": [
        {
          "name": "Method public BinaryDocValues select(final SortedBinaryDocValues values, final BytesRef missingValue, final BitSet parentDocs, final DocIdSetIterator childDocs, int maxDoc, int maxChildren) throws IOException  (MultiValueMode.java)"
        }
      ],
      "comment": "\n     * Return a {@link NumericDocValues} instance that can be used to sort root documents\n     * with this mode, the provided values and filters for root/inner documents.\n     *\n     * For every root document, the values of its inner documents will be aggregated.\n     * If none of the inner documents has a value, then <code>missingValue</code> is returned.\n     *\n     * Allowed Modes: SUM, AVG, MIN, MAX\n     *\n     * NOTE: Calling the returned instance on docs that are not root docs is illegal\n     *       The returned instance can only be evaluate the current and upcoming docs\n     ",
      "vertexLabel": "NumericDocValues select()"
    },
    {
      "vertexName": "Method public SearchRequestBuilder setIndicesOptions(IndicesOptions indicesOptions)  (SearchRequestBuilder.java)",
      "children": [
        {
          "name": "Method public DeleteIndexRequestBuilder setIndicesOptions(IndicesOptions options)  (DeleteIndexRequestBuilder.java)"
        }
      ],
      "comment": "\n     * Specifies what type of requested indices to ignore and wildcard indices expressions.\n     * <p>\n     * For example indices that don't exist.\n     ",
      "vertexLabel": "SearchRequestBuilder setIndicesOptions()"
    },
    {
      "vertexName": "Method public Analyzer getSearchQuoteAnalyzer(MappedFieldType fieldType)  (QueryShardContext.java)",
      "children": [
        {
          "name": "Method public Analyzer getSearchAnalyzer(MappedFieldType fieldType)  (QueryShardContext.java)"
        }
      ],
      "comment": "\n     * Gets the search quote analyzer for the given field, or the default if there is none present for the field\n     * TODO: remove this by moving defaults into mappers themselves\n     ",
      "vertexLabel": "Analyzer getSearchQuoteAnalyzer()"
    },
    {
      "vertexName": "EnumConstant MEDIAN  (SortMode.java)",
      "children": [
        {
          "name": "EnumConstant SUM  (SortMode.java)"
        }
      ],
      "comment": " Use the median of all values as sort value. Only applicable for number based array fields. *",
      "vertexLabel": "EnumConstant MEDIAN"
    },
    {
      "vertexName": "Field DEFAULT_MAX_NUM_TOKENS_PARSED  (XMoreLikeThis.java)",
      "children": [
        {
          "name": "Method public void setMaxNumTokensParsed(int i)  (XMoreLikeThis.java)"
        }
      ],
      "comment": "\n     * Default maximum number of tokens to parse in each example doc field that is not stored with TermVector support.\n     *\n     * @see #getMaxNumTokensParsed\n     ",
      "vertexLabel": "Field DEFAULT_MAX_NUM_TOKENS_PARSED"
    },
    {
      "vertexName": "Method public LongArray newLongArray(long size, boolean clearOnResize)  (BigArrays.java)",
      "children": [
        {
          "name": "Method public IntArray newIntArray(long size, boolean clearOnResize)  (BigArrays.java)"
        }
      ],
      "comment": "\n     * Allocate a new {@link LongArray}.\n     * @param size          the initial length of the array\n     * @param clearOnResize whether values should be set to 0 on initialization and resize\n     ",
      "vertexLabel": "LongArray newLongArray()"
    },
    {
      "vertexName": "Field min  (ExtendedBounds.java)",
      "comment": "\n     * Parsed min value. If this is null and {@linkplain #minAsStr} isn't then this must be parsed from {@linkplain #minAsStr}. If this is\n     * null and {@linkplain #minAsStr} is also null then there is no lower bound.\n     ",
      "vertexLabel": "Field min"
    },
    {
      "vertexName": "Method public String getSetting(String index, String setting)  (GetSettingsResponse.java)",
      "comment": "\n     * Returns the string value for the specified index and setting.  If the includeDefaults\n     * flag was not set or set to false on the GetSettingsRequest, this method will only\n     * return a value where the setting was explicitly set on the index.  If the includeDefaults\n     * flag was set to true on the GetSettingsRequest, this method will fall back to return the default\n     * value if the setting was not explicitly set.\n     ",
      "vertexLabel": "String getSetting()"
    },
    {
      "vertexName": "Method public RestoreSnapshotRequestBuilder setRenamePattern(String renamePattern)  (RestoreSnapshotRequestBuilder.java)",
      "children": [
        {
          "name": "Method public RestoreSnapshotRequest renamePattern(String renamePattern)  (RestoreSnapshotRequest.java)"
        }
      ],
      "comment": "\n     * Sets rename pattern that should be applied to restored indices.\n     * <p>\n     * Indices that match the rename pattern will be renamed according to {@link #setRenameReplacement(String)}. The\n     * rename pattern is applied according to the {@link java.util.regex.Matcher#appendReplacement(StringBuffer, String)}\n     * The request will fail if two or more indices will be renamed into the same name.\n     *\n     * @param renamePattern rename pattern\n     * @return this builder\n     ",
      "vertexLabel": "RestoreSnapshotRequestBuilder setRenamePattern()"
    },
    {
      "vertexName": "Method public GetSnapshotsRequest(String repository)  (GetSnapshotsRequest.java)",
      "comment": "\n     * Constructs a new get snapshots request with given repository name\n     *\n     * @param repository repository name\n     ",
      "vertexLabel": "GetSnapshotsRequest()"
    },
    {
      "vertexName": "Method public ClusterStateObserver(ClusterState initialState, ClusterService clusterService, @Nullable TimeValue timeout, Logger logger, ThreadContext contextHolder)  (ClusterStateObserver.java)",
      "children": [
        {
          "name": "Method public ClusterStateObserver(ClusterService clusterService, @Nullable TimeValue timeout, Logger logger, ThreadContext contextHolder)  (ClusterStateObserver.java)"
        }
      ],
      "comment": "\n     * @param timeout        a global timeout for this observer. After it has expired the observer\n     *                       will fail any existing or new #waitForNextChange calls. Set to null\n     *                       to wait indefinitely\n     ",
      "vertexLabel": "ClusterStateObserver()"
    },
    {
      "vertexName": "Method public int getMinDocFreq()  (XMoreLikeThis.java)",
      "children": [
        {
          "name": "Method public void setMinDocFreq(int minDocFreq)  (XMoreLikeThis.java)"
        }
      ],
      "comment": "\n     * Returns the frequency at which words will be ignored which do not occur in at least this\n     * many docs. The default frequency is {@link #DEFAULT_MIN_DOC_FREQ}.\n     *\n     * @return the frequency at which words will be ignored which do not occur in at least this\n     *         many docs.\n     ",
      "vertexLabel": "int getMinDocFreq()"
    },
    {
      "vertexName": "Method public SnapshotsStatusRequest ignoreUnavailable(boolean ignoreUnavailable)  (SnapshotsStatusRequest.java)",
      "comment": "\n     * Set to <code>true</code> to ignore unavailable snapshots, instead of throwing an exception.\n     * Defaults to <code>false</code>, which means unavailable snapshots cause an exception to be thrown.\n     *\n     * @param ignoreUnavailable whether to ignore unavailable snapshots\n     * @return this request\n     ",
      "vertexLabel": "SnapshotsStatusRequest ignoreUnavailable()"
    },
    {
      "vertexName": "Method public GetSnapshotsRequestBuilder setSnapshots(String... snapshots)  (GetSnapshotsRequestBuilder.java)",
      "comment": "\n     * Sets list of snapshots to return\n     *\n     * @param snapshots list of snapshots\n     * @return this builder\n     ",
      "vertexLabel": "GetSnapshotsRequestBuilder setSnapshots()"
    },
    {
      "vertexName": "Method public BytesReference getError()  (TaskResult.java)",
      "comment": "\n     * Get the error that finished this task. Will return null if the task didn't finish with an error, it hasn't yet finished, or didn't\n     * store its result.\n     ",
      "vertexLabel": "BytesReference getError()"
    },
    {
      "vertexName": "Class ImmutableOpenMap  (ImmutableOpenMap.java)",
      "comment": "\n * An immutable map implementation based on open hash map.\n * <p>\n * Can be constructed using a {@link #builder()}, or using {@link #builder(ImmutableOpenMap)} (which is an optimized\n * option to copy over existing content and modify it).\n ",
      "vertexLabel": "Class ImmutableOpenMap"
    },
    {
      "vertexName": "Method Object getSource()  (Element.java)",
      "comment": "\n     * Returns an arbitrary object containing information about the \"place\" where this element was\n     * configured. Used by Guice in the production of descriptive error messages.\n     * <p>\n     * Tools might specially handle types they know about; {@code StackTraceElement} is a good\n     * example. Tools should simply call {@code toString()} on the source object if the type is\n     * unfamiliar.\n     ",
      "vertexLabel": "Object getSource()"
    },
    {
      "vertexName": "Method void open(OpenIndexRequest request, ActionListener<OpenIndexResponse> listener)  (IndicesAdminClient.java)",
      "children": [
        {
          "name": "Method ActionFuture<OpenIndexResponse> open(OpenIndexRequest request)  (IndicesAdminClient.java)"
        },
        {
          "name": "Method void upgrade(UpgradeRequest request, ActionListener<UpgradeResponse> listener)  (IndicesAdminClient.java)"
        }
      ],
      "comment": "\n     * Open an index based on the index name.\n     *\n     * @param request  The close index request\n     * @param listener A listener to be notified with a result\n     * @see org.elasticsearch.client.Requests#openIndexRequest(String)\n     ",
      "vertexLabel": "void open()"
    },
    {
      "vertexName": "Method public void setMinTermFreq(int minTermFreq)  (XMoreLikeThis.java)",
      "comment": "\n     * Sets the frequency below which terms will be ignored in the source doc.\n     *\n     * @param minTermFreq the frequency below which terms will be ignored in the source doc.\n     ",
      "vertexLabel": "void setMinTermFreq()"
    },
    {
      "vertexName": "Method public Setting(String key, Setting<T> fallBackSetting, Function<String, T> parser, Property... properties)  (Setting.java)",
      "children": [
        {
          "name": "Method public Setting(String key, String defaultValue, Function<String, T> parser, Property... properties)  (Setting.java)"
        }
      ],
      "comment": "\n     * Creates a new Setting instance\n     * @param key the settings key for this setting.\n     * @param fallBackSetting a setting to fall back to if the current setting is not set.\n     * @param parser a parser that parses the string rep into a complex datatype.\n     * @param properties properties for this setting like scope, filtering...\n     ",
      "vertexLabel": "Setting()"
    },
    {
      "vertexName": "Field id  (StopWatch.java)",
      "comment": "\n     * Identifier of this stop watch.\n     * Handy when we have output from multiple stop watches\n     * and need to distinguish between them in log or console output.\n     ",
      "vertexLabel": "Field id"
    },
    {
      "vertexName": "Method public ImmutableOpenMap<String, DiskUsage> getNodeMostAvailableDiskUsages()  (ClusterInfo.java)",
      "comment": "\n     * Returns a node id to disk usage mapping for the path that has the most available space on the node.\n     ",
      "vertexLabel": "ImmutableOpenMap<String, DiskUsage> getNodeMostAvailableDiskUsages()"
    },
    {
      "vertexName": "Method void close(CloseIndexRequest request, ActionListener<AcknowledgedResponse> listener)  (IndicesAdminClient.java)",
      "children": [
        {
          "name": "Method void open(OpenIndexRequest request, ActionListener<OpenIndexResponse> listener)  (IndicesAdminClient.java)"
        }
      ],
      "comment": "\n     * Closes an index based on the index name.\n     *\n     * @param request  The close index request\n     * @param listener A listener to be notified with a result\n     * @see org.elasticsearch.client.Requests#closeIndexRequest(String)\n     ",
      "vertexLabel": "void close()"
    },
    {
      "vertexName": "Method public final void onModule(IndexModule indexModule)  (Plugin.java)",
      "comment": "\n     * Old-style guice index level extension point. {@code @Deprecated} and {@code final} to act as a signpost for plugin authors upgrading\n     * from 2.x.\n     *\n     * @deprecated use #onIndexModule instead\n     ",
      "vertexLabel": "final void onModule()"
    },
    {
      "vertexName": "Method public TermsQueryBuilder(String fieldName, int... values)  (TermsQueryBuilder.java)",
      "children": [
        {
          "name": "Method public TermsQueryBuilder(String fieldName, String... values)  (TermsQueryBuilder.java)"
        }
      ],
      "comment": "\n     * A filter for a field based on several terms matching on any of them.\n     *\n     * @param fieldName The field name\n     * @param values The terms\n     ",
      "vertexLabel": "TermsQueryBuilder()"
    },
    {
      "vertexName": "Method public TermSuggestionBuilder maxEdits(int maxEdits)  (TermSuggestionBuilder.java)",
      "children": [
        {
          "name": "Method public DirectCandidateGeneratorBuilder maxEdits(Integer maxEdits)  (DirectCandidateGeneratorBuilder.java)"
        }
      ],
      "comment": "\n     * Sets the maximum edit distance candidate suggestions can have in order to\n     * be considered as a suggestion. Can only be a value between 1 and 2. Any\n     * other value result in an bad request error being thrown. Defaults to\n     * {@code 2}.\n     ",
      "vertexLabel": "TermSuggestionBuilder maxEdits()"
    },
    {
      "vertexName": "Method public final void writeMap(final Map<K, V> map, final Writer<K> keyWriter, final Writer<V> valueWriter) throws IOException  (StreamOutput.java)",
      "comment": "\n     * Write a {@link Map} of {@code K}-type keys to {@code V}-type.\n     * <pre><code>\n     * Map&lt;String, String&gt; map = ...;\n     * out.writeMap(map, StreamOutput::writeString, StreamOutput::writeString);\n     * </code></pre>\n     *\n     * @param keyWriter The key writer\n     * @param valueWriter The value writer\n     ",
      "vertexLabel": "final void writeMap()"
    },
    {
      "vertexName": "Method public static NodesInfoRequest nodesInfoRequest(String... nodesIds)  (Requests.java)",
      "children": [
        {
          "name": "Method public static NodesInfoRequest nodesInfoRequest()  (Requests.java)"
        }
      ],
      "comment": "\n     * Creates a nodes info request against one or more nodes. Pass {@code null} or an empty array for all nodes.\n     *\n     * @param nodesIds The nodes ids to get the status for\n     * @return The nodes info request\n     * @see org.elasticsearch.client.ClusterAdminClient#nodesStats(org.elasticsearch.action.admin.cluster.node.stats.NodesStatsRequest)\n     ",
      "vertexLabel": "NodesInfoRequest nodesInfoRequest()"
    },
    {
      "vertexName": "Method public Builder put(String setting, long value)  (Settings.java)",
      "children": [
        {
          "name": "Method public Builder put(String setting, int value)  (Settings.java)"
        }
      ],
      "comment": "\n         * Sets the setting with the provided setting key and the long value.\n         *\n         * @param setting The setting key\n         * @param value   The long value\n         * @return The builder\n         ",
      "vertexLabel": "Builder put()"
    },
    {
      "vertexName": "Method public DeleteRequestBuilder setVersion(long version)  (DeleteRequestBuilder.java)",
      "children": [
        {
          "name": "Method public long version()  (GetRequest.java)"
        }
      ],
      "comment": "\n     * Sets the version, which will cause the delete operation to only be performed if a matching\n     * version exists and no changes happened on the doc since then.\n     ",
      "vertexLabel": "DeleteRequestBuilder setVersion()"
    },
    {
      "vertexName": "Method public BulkRequest add(IndexRequest request)  (BulkRequest.java)",
      "children": [
        {
          "name": "Method public BulkProcessor add(IndexRequest request)  (BulkProcessor.java)"
        }
      ],
      "comment": "\n     * Adds an {@link IndexRequest} to the list of actions to execute. Follows the same behavior of {@link IndexRequest}\n     * (for example, if no id is provided, one will be generated, or usage of the create flag).\n     ",
      "vertexLabel": "BulkRequest add()"
    },
    {
      "vertexName": "Method public TermVectorsRequest selectedFields(String... fields)  (TermVectorsRequest.java)",
      "children": [
        {
          "name": "Method public Set<String> selectedFields()  (TermVectorsRequest.java)"
        }
      ],
      "comment": "\n     * Return only term vectors for special selected fields. Returns the term\n     * vectors for all fields if selectedFields == null\n     ",
      "vertexLabel": "TermVectorsRequest selectedFields()"
    },
    {
      "vertexName": "Class LivenessResponse  (LivenessResponse.java)",
      "children": [
        {
          "name": "Class LivenessRequest  (LivenessRequest.java)"
        }
      ],
      "comment": "\n * Transport level private response for the transport handler registered under\n * {@value org.elasticsearch.action.admin.cluster.node.liveness.TransportLivenessAction#NAME}\n ",
      "vertexLabel": "Class LivenessResponse"
    },
    {
      "vertexName": "Interface BindingTargetVisitor  (BindingTargetVisitor.java)",
      "children": [
        {
          "name": "Interface BindingScopingVisitor  (BindingScopingVisitor.java)"
        }
      ],
      "comment": "\n * Visits each of the strategies used to find an instance to satisfy an injection.\n *\n * @param <V> any type to be returned by the visit method. Use {@link Void} with\n *            {@code return null} if no return type is needed.\n * @since 2.0\n ",
      "vertexLabel": "Interface BindingTargetVisitor"
    },
    {
      "vertexName": "Class ElasticsearchLeafReader  (ElasticsearchLeafReader.java)",
      "comment": "\n * A {@link org.apache.lucene.index.FilterLeafReader} that exposes\n * Elasticsearch internal per shard / index information like the shard ID.\n ",
      "vertexLabel": "Class ElasticsearchLeafReader"
    },
    {
      "vertexName": "Method public List<ShardLock> lockAllForIndex(Index index, IndexSettings settings, long lockTimeoutMS) throws ShardLockObtainFailedException  (NodeEnvironment.java)",
      "comment": "\n     * Tries to lock all local shards for the given index. If any of the shard locks can't be acquired\n     * a {@link ShardLockObtainFailedException} is thrown and all previously acquired locks are released.\n     *\n     * @param index the index to lock shards for\n     * @param lockTimeoutMS how long to wait for acquiring the indices shard locks\n     * @return the {@link ShardLock} instances for this index.\n     ",
      "vertexLabel": "List<ShardLock> lockAllForIndex()"
    },
    {
      "vertexName": "Method void deleteBlobIgnoringIfNotExists(String blobName) throws IOException  (BlobContainer.java)",
      "comment": "\n     * Deletes a blob with giving name, ignoring if the blob does not exist.\n     *\n     * @param   blobName\n     *          The name of the blob to delete.\n     * @throws  IOException if the blob exists but could not be deleted.\n     ",
      "vertexLabel": "void deleteBlobIgnoringIfNotExists()"
    },
    {
      "vertexName": "Method public static TermsQueryBuilder termsQuery(String name, double... values)  (QueryBuilders.java)",
      "children": [
        {
          "name": "Method public static TermsQueryBuilder termsQuery(String name, String... values)  (QueryBuilders.java)"
        }
      ],
      "comment": "\n     * A filer for a field based on several terms matching on any of them.\n     *\n     * @param name   The field name\n     * @param values The terms\n     ",
      "vertexLabel": "TermsQueryBuilder termsQuery()"
    },
    {
      "vertexName": "Method public TermVectorsRequestBuilder(ElasticsearchClient client, TermVectorsAction action, String index, String type, String id)  (TermVectorsRequestBuilder.java)",
      "children": [
        {
          "name": "Method public TermVectorsRequest(String index, String type, String id)  (TermVectorsRequest.java)"
        }
      ],
      "comment": "\n     * Constructs a new term vector request builder for a document that will be fetch\n     * from the provided index. Use {@code index}, {@code type} and\n     * {@code id} to specify the document to load.\n     ",
      "vertexLabel": "TermVectorsRequestBuilder()"
    },
    {
      "vertexName": "Method public CreateSnapshotRequestBuilder setSettings(Settings settings)  (CreateSnapshotRequestBuilder.java)",
      "children": [
        {
          "name": "Method public CreateSnapshotRequest settings(Settings settings)  (CreateSnapshotRequest.java)"
        }
      ],
      "comment": "\n     * Sets repository-specific snapshot settings.\n     * <p>\n     * See repository documentation for more information.\n     *\n     * @param settings repository-specific snapshot settings\n     * @return this builder\n     ",
      "vertexLabel": "CreateSnapshotRequestBuilder setSettings()"
    },
    {
      "vertexName": "Method public ExplainRequestBuilder setFetchSource(@Nullable String[] includes, @Nullable String[] excludes)  (ExplainRequestBuilder.java)",
      "children": [
        {
          "name": "Method public ExplainRequestBuilder setFetchSource(@Nullable String include, @Nullable String exclude)  (ExplainRequestBuilder.java)"
        }
      ],
      "comment": "\n     * Indicate that _source should be returned, with an \"include\" and/or \"exclude\" set which can include simple wildcard\n     * elements.\n     *\n     * @param includes An optional list of include (optionally wildcarded) pattern to filter the returned _source\n     * @param excludes An optional list of exclude (optionally wildcarded) pattern to filter the returned _source\n     ",
      "vertexLabel": "ExplainRequestBuilder setFetchSource()"
    },
    {
      "vertexName": "Method public IndexRequestBuilder setVersion(long version)  (IndexRequestBuilder.java)",
      "children": [
        {
          "name": "Method public long version()  (GetRequest.java)"
        }
      ],
      "comment": "\n     * Sets the version, which will cause the index operation to only be performed if a matching\n     * version exists and no changes happened on the doc since then.\n     ",
      "vertexLabel": "IndexRequestBuilder setVersion()"
    },
    {
      "vertexName": "Method public RestoreSnapshotRequestBuilder setIgnoreIndexSettings(String... ignoreIndexSettings)  (RestoreSnapshotRequestBuilder.java)",
      "children": [
        {
          "name": "Method public RestoreSnapshotRequest ignoreIndexSettings(List<String> ignoreIndexSettings)  (RestoreSnapshotRequest.java)"
        }
      ],
      "comment": "\n     * Sets the list of index settings and index settings groups that shouldn't be restored from snapshot\n     ",
      "vertexLabel": "RestoreSnapshotRequestBuilder setIgnoreIndexSettings()"
    },
    {
      "vertexName": "Method public void setForceAnalyzer(Analyzer analyzer)  (QueryStringQueryParser.java)",
      "comment": "\n     * @param analyzer Force the provided analyzer to be used for all query analysis regardless of the field.\n     ",
      "vertexLabel": "void setForceAnalyzer()"
    },
    {
      "vertexName": "Method public Client getRemoteClusterClient(ThreadPool threadPool, String clusterAlias)  (RemoteClusterService.java)",
      "children": [
        {
          "name": "Method Client getRemoteClusterClient(String clusterAlias)  (Client.java)"
        }
      ],
      "comment": "\n     * Returns a client to the remote cluster if the given cluster alias exists.\n     * @param threadPool the {@link ThreadPool} for the client\n     * @param clusterAlias the cluster alias the remote cluster is registered under\n     *\n     * @throws IllegalArgumentException if the given clusterAlias doesn't exist\n     ",
      "vertexLabel": "Client getRemoteClusterClient()"
    },
    {
      "vertexName": "Method public Iterable<V> values()  (Cache.java)",
      "comment": "\n     * An LRU sequencing of the values in the cache. This sequence is not protected from mutations\n     * to the cache (except for {@link Iterator#remove()}. The result of iteration under any other mutation is\n     * undefined.\n     *\n     * @return an LRU-ordered {@link Iterable} over the values in the cache\n     ",
      "vertexLabel": "Iterable<V> values()"
    },
    {
      "vertexName": "Method public static void copy(byte[] in, OutputStream out) throws IOException  (Streams.java)",
      "comment": "\n     * Copy the contents of the given byte array to the given OutputStream.\n     * Closes the stream when done.\n     *\n     * @param in  the byte array to copy from\n     * @param out the OutputStream to copy to\n     * @throws IOException in case of I/O errors\n     ",
      "vertexLabel": "void copy()"
    },
    {
      "vertexName": "Class BulkRequest  (BulkRequest.java)",
      "children": [
        {
          "name": "Class BulkRequestBuilder  (BulkRequestBuilder.java)"
        }
      ],
      "comment": "\n * A bulk request holds an ordered {@link IndexRequest}s, {@link DeleteRequest}s and {@link UpdateRequest}s\n * and allows to executes it in a single batch.\n *\n * Note that we only support refresh on the bulk request not per item.\n * @see org.elasticsearch.client.Client#bulk(BulkRequest)\n ",
      "vertexLabel": "Class BulkRequest"
    },
    {
      "vertexName": "Method private void handleOptionsRequest(RestRequest request, RestChannel channel, Set<RestRequest.Method> validMethodSet)  (RestController.java)",
      "comment": "\n     * Handle HTTP OPTIONS requests to a valid REST endpoint. A 200 HTTP\n     * response code is returned, and the response 'Allow' header includes a\n     * list of valid HTTP methods for the endpoint (see\n     * <a href=\"https://tools.ietf.org/html/rfc2616#section-9.2\">HTTP/1.1 - 9.2\n     * - Options</a>).\n     ",
      "vertexLabel": "void handleOptionsRequest()"
    },
    {
      "vertexName": "Method private long getCgroupCpuAcctUsageNanos(final String controlGroup) throws IOException  (OsProbe.java)",
      "children": [
        {
          "name": "Method private OsStats.Cgroup.CpuStat getCgroupCpuAcctCpuStat(final String controlGroup) throws IOException  (OsProbe.java)"
        },
        {
          "name": "Method public long getCpuAcctUsageNanos()  (OsStats.java)"
        }
      ],
      "comment": "\n     * The total CPU time in nanoseconds consumed by all tasks in the cgroup to which the Elasticsearch process belongs for the {@code\n     * cpuacct} subsystem.\n     *\n     * @param controlGroup the control group for the Elasticsearch process for the {@code cpuacct} subsystem\n     * @return the total CPU time in nanoseconds\n     * @throws IOException if an I/O exception occurs reading {@code cpuacct.usage} for the control group\n     ",
      "vertexLabel": "long getCgroupCpuAcctUsageNanos()"
    },
    {
      "vertexName": "Method private PhraseSuggestionBuilder(String fieldname, PhraseSuggestionBuilder in)  (PhraseSuggestionBuilder.java)",
      "children": [
        {
          "name": "Method private CompletionSuggestionBuilder(String fieldname, CompletionSuggestionBuilder in)  (CompletionSuggestionBuilder.java)"
        }
      ],
      "comment": "\n     * internal copy constructor that copies over all class fields except for the field which is\n     * set to the one provided in the first argument\n     ",
      "vertexLabel": "PhraseSuggestionBuilder()"
    },
    {
      "vertexName": "Method public List<String> getAsList(String key, List<String> defaultValue) throws SettingsException  (Settings.java)",
      "children": [
        {
          "name": "Method public List<String> getAsList(String key) throws SettingsException  (Settings.java)"
        }
      ],
      "comment": "\n     * The values associated with a setting key as an immutable list.\n     * <p>\n     * If commaDelimited is true, it will automatically load a comma separated list under the settingPrefix and merge with\n     * the numbered format.\n     *\n     * @param key The setting key to load the list by\n     * @return The setting list values\n     ",
      "vertexLabel": "List<String> getAsList()"
    },
    {
      "vertexName": "Method public FuzzyQueryBuilder(String fieldName, long value)  (FuzzyQueryBuilder.java)",
      "children": [
        {
          "name": "Method public FuzzyQueryBuilder(String fieldName, String value)  (FuzzyQueryBuilder.java)"
        }
      ],
      "comment": "\n     * Constructs a new fuzzy query.\n     *\n     * @param fieldName  The name of the field\n     * @param value The value of the text\n     ",
      "vertexLabel": "FuzzyQueryBuilder()"
    },
    {
      "vertexName": "Method static T rewrite(T original, QueryRewriteContext context, boolean assertNoAsyncTasks) throws IOException  (Rewriteable.java)",
      "children": [
        {
          "name": "Method static T rewrite(T original, QueryRewriteContext context) throws IOException  (Rewriteable.java)"
        }
      ],
      "comment": "\n     * Rewrites the given {@link Rewriteable} into its primitive form. Rewriteables that for instance fetch resources from remote hosts or\n     * can simplify / optimize itself should do their heavy lifting during\n     * {@link #rewriteAndFetch(Rewriteable, QueryRewriteContext, ActionListener)} (QueryRewriteContext)}. This method rewrites the\n     * rewriteable until it doesn't change anymore.\n     * @param original the original rewriteable to rewrite\n     * @param context the rewrite context to use\n     * @param assertNoAsyncTasks if <code>true</code> the rewrite will fail if there are any pending async tasks on the context after the\n     *                          rewrite. See {@link QueryRewriteContext#executeAsyncActions(ActionListener)} for detals\n     * @throws IOException if an {@link IOException} occurs\n     ",
      "vertexLabel": "T rewrite()"
    },
    {
      "vertexName": "Method public static void writeToChannel(byte[] source, WritableByteChannel channel) throws IOException  (Channels.java)",
      "comment": "\n     * Writes part of a byte array to a {@link java.nio.channels.WritableByteChannel}\n     *\n     * @param source  byte array to copy from\n     * @param channel target WritableByteChannel\n     ",
      "vertexLabel": "void writeToChannel()"
    },
    {
      "vertexName": "Method protected boolean parseBoolParam(@Nullable Map<String, Object> settings, String name, boolean defaultValue) throws ParseException  (MovAvgModel.java)",
      "comment": "\n         * Extracts a boolean from the settings map, otherwise throws an exception\n         *\n         * @param settings      Map of settings provided to this model\n         * @param name          Name of parameter we are attempting to extract\n         * @param defaultValue  Default value to be used if value does not exist in map\n         * @return Boolean value extracted from settings map\n         ",
      "vertexLabel": "boolean parseBoolParam()"
    },
    {
      "vertexName": "Method protected Result prepare(ShardId shardId, UpdateRequest request, final GetResult getResult, LongSupplier nowInMillis)  (UpdateHelper.java)",
      "children": [
        {
          "name": "Method public Result prepare(UpdateRequest request, IndexShard indexShard, LongSupplier nowInMillis)  (UpdateHelper.java)"
        }
      ],
      "comment": "\n     * Prepares an update request by converting it into an index or delete request or an update response (no action, in the event of a\n     * noop).\n     ",
      "vertexLabel": "Result prepare()"
    },
    {
      "vertexName": "Method public boolean partial()  (RestoreSnapshotRequest.java)",
      "comment": "\n     * Returns true if indices with failed to snapshot shards should be partially restored.\n     *\n     * @return true if indices with failed to snapshot shards should be partially restored\n     ",
      "vertexLabel": "boolean partial()"
    },
    {
      "vertexName": "Method private void setOptions(Map<String, String> options)  (StoredScriptSource.java)",
      "comment": "\n         * Options may have already been added if a template was specified.\n         * Appends the user-defined compiler options with the internal compiler options.\n         ",
      "vertexLabel": "void setOptions()"
    },
    {
      "vertexName": "Method abstract void copyCurrent(int slot)  (SingleDimensionValuesSource.java)",
      "comment": "\n     * The current value is filled by a {@link LeafBucketCollector} that visits all the\n     * values of each document. This method saves this current value in a slot and should only be used\n     * in the context of a collection.\n     * See {@link #getLeafCollector}.\n     ",
      "vertexLabel": "abstract void copyCurrent()"
    },
    {
      "vertexName": "Method public static long min(final long minSeqNo, final long seqNo)  (SequenceNumbers.java)",
      "comment": "\n     * Compute the minimum of the given current minimum sequence number and the specified sequence number, accounting for the fact that the\n     * current minimum sequence number could be {@link SequenceNumbers#NO_OPS_PERFORMED} or\n     * {@link SequenceNumbers#UNASSIGNED_SEQ_NO}. When the current minimum sequence number is not\n     * {@link SequenceNumbers#NO_OPS_PERFORMED} nor {@link SequenceNumbers#UNASSIGNED_SEQ_NO}, the specified sequence number\n     * must not be {@link SequenceNumbers#UNASSIGNED_SEQ_NO}.\n     *\n     * @param minSeqNo the current minimum sequence number\n     * @param seqNo the specified sequence number\n     * @return the new minimum sequence number\n     ",
      "vertexLabel": "long min()"
    },
    {
      "vertexName": "Method private ImmutableOpenMap<String, List<AliasMetaData>> findAliases(final String[] aliases, final String[] concreteIndices)  (MetaData.java)",
      "children": [
        {
          "name": "Method public ImmutableOpenMap<String, List<AliasMetaData>> findAliases(final AliasesRequest aliasesRequest, final String[] concreteIndices)  (MetaData.java)"
        }
      ],
      "comment": "\n     * Finds the specific index aliases that match with the specified aliases directly or partially via wildcards, and\n     * that point to the specified concrete indices (directly or matching indices via wildcards).\n     *\n     * @param aliases The aliases to look for. Might contain include or exclude wildcards.\n     * @param concreteIndices The concrete indices that the aliases must point to in order to be returned\n     * @return A map of index name to the list of aliases metadata. If a concrete index does not have matching\n     * aliases then the result will <b>not</b> include the index's key.\n     ",
      "vertexLabel": "ImmutableOpenMap<String, List<AliasMetaData>> findAliases()"
    },
    {
      "vertexName": "Method public static FunctionScoreQueryBuilder functionScoreQuery(FunctionScoreQueryBuilder.FilterFunctionBuilder[] filterFunctionBuilders)  (QueryBuilders.java)",
      "comment": "\n     * A query that allows to define a custom scoring function\n     *\n     * @param filterFunctionBuilders the filters and functions to execute\n     * @return the function score query\n     ",
      "vertexLabel": "FunctionScoreQueryBuilder functionScoreQuery()"
    },
    {
      "vertexName": "Method public static GeoDistanceSortBuilder fromXContent(XContentParser parser, String elementName) throws IOException  (GeoDistanceSortBuilder.java)",
      "children": [
        {
          "name": "Method public static ScriptSortBuilder fromXContent(XContentParser parser, String elementName)  (ScriptSortBuilder.java)"
        }
      ],
      "comment": "\n     * Creates a new {@link GeoDistanceSortBuilder} from the query held by the {@link XContentParser} in\n     * {@link org.elasticsearch.common.xcontent.XContent} format.\n     *\n     * @param parser the input parser. The state on the parser contained in this context will be changed as a\n     *                side effect of this method call\n     * @param elementName in some sort syntax variations the field name precedes the xContent object that specifies\n     *                    further parameters, e.g. in '{ \"foo\": { \"order\" : \"asc\"} }'. When parsing the inner object,\n     *                    the field name can be passed in via this argument\n     ",
      "vertexLabel": "GeoDistanceSortBuilder fromXContent()"
    },
    {
      "vertexName": "Method public static GeoShapeQueryBuilder geoIntersectionQuery(String name, ShapeBuilder shape) throws IOException  (QueryBuilders.java)",
      "comment": "\n     * A filter to filter indexed shapes intersecting with shapes\n     *\n     * @param name  The shape field name\n     * @param shape Shape to use in the filter\n     ",
      "vertexLabel": "GeoShapeQueryBuilder geoIntersectionQuery()"
    },
    {
      "vertexName": "Method public Setting(String key, String defaultValue, Function<String, T> parser, Validator<T> validator, Property... properties)  (Setting.java)",
      "children": [
        {
          "name": "Method public Setting(Key key, Function<Settings, String> defaultValue, Function<String, T> parser, Validator<T> validator, Property... properties)  (Setting.java)"
        }
      ],
      "comment": "\n     * Creates a new {@code Setting} instance.\n     *\n     * @param key          the settings key for this setting\n     * @param defaultValue a default value function that results a string representation of the default value\n     * @param parser       a parser that parses a string representation into the concrete type for this setting\n     * @param validator    a {@link Validator} for validating this setting\n     * @param properties   properties for this setting\n     ",
      "vertexLabel": "Setting()"
    },
    {
      "vertexName": "Method void addError(Throwable t)  (Binder.java)",
      "comment": "\n     * Records an exception, the full details of which will be logged, and the\n     * message of which will be presented to the user at a later\n     * time. If your Module calls something that you worry may fail, you should\n     * catch the exception and pass it into this.\n     ",
      "vertexLabel": "void addError()"
    },
    {
      "vertexName": "Method public String routing()  (SearchRequest.java)",
      "comment": "\n     * A comma separated list of routing values to control the shards the search will be executed on.\n     ",
      "vertexLabel": "String routing()"
    },
    {
      "vertexName": "Method public abstract T fromXContent(XContentParser parser) throws IOException  (MetaDataStateFormat.java)",
      "children": [
        {
          "name": "Method public abstract void toXContent(XContentBuilder builder, T state) throws IOException  (MetaDataStateFormat.java)"
        }
      ],
      "comment": "\n     * Reads a new instance of the state from the given XContentParser\n     * Subclasses need to implement this class for theirs specific state.\n     ",
      "vertexLabel": "abstract T fromXContent()"
    },
    {
      "vertexName": "Method public UpdateByQueryRequest setRouting(String routing)  (UpdateByQueryRequest.java)",
      "children": [
        {
          "name": "Method public DeleteByQueryRequest setRouting(String routing)  (DeleteByQueryRequest.java)"
        }
      ],
      "comment": "\n     * Set routing limiting the process to the shards that match that routing value\n     ",
      "vertexLabel": "UpdateByQueryRequest setRouting()"
    },
    {
      "vertexName": "Method void postIndex(ShardId shardId, Engine.Index index, Exception ex)  (IndexingOperationListener.java)",
      "comment": "\n     * Called after the indexing operation occurred with engine level exception.\n     * See {@link #postIndex(ShardId, Engine.Index, Engine.IndexResult)} for document\n     * related failures\n     ",
      "vertexLabel": "void postIndex()"
    },
    {
      "vertexName": "Class MatchPhrasePrefixQueryBuilder  (MatchPhrasePrefixQueryBuilder.java)",
      "children": [
        {
          "name": "Class MatchPhraseQueryBuilder  (MatchPhraseQueryBuilder.java)"
        }
      ],
      "comment": "\n * Match query is a query that analyzes the text and constructs a phrase prefix\n * query as the result of the analysis.\n ",
      "vertexLabel": "Class MatchPhrasePrefixQueryBuilder"
    },
    {
      "vertexName": "Method protected void requireBinding(Class<?> type)  (AbstractModule.java)",
      "children": [
        {
          "name": "Method protected void requireBinding(Key<?> key)  (AbstractModule.java)"
        }
      ],
      "comment": "\n     * Adds a dependency from this module to {@code type}. When the injector is\n     * created, Guice will report an error if {@code type} cannot be injected.\n     * Note that this requirement may be satisfied by implicit binding, such as\n     * a public no-arguments constructor.\n     *\n     * @since 2.0\n     ",
      "vertexLabel": "void requireBinding()"
    },
    {
      "vertexName": "Method protected ClusterState reroute(ClusterState clusterState, String reason, boolean debug)  (AllocationService.java)",
      "children": [
        {
          "name": "Method public ClusterState reroute(ClusterState clusterState, String reason)  (AllocationService.java)"
        }
      ],
      "comment": "\n     * Reroutes the routing table based on the live nodes.\n     * <p>\n     * If the same instance of ClusterState is returned, then no change has been made.\n     ",
      "vertexLabel": "ClusterState reroute()"
    },
    {
      "vertexName": "Class GetTaskRequestBuilder  (GetTaskRequestBuilder.java)",
      "comment": "\n * Builder for the request to retrieve the list of tasks running on the specified nodes\n ",
      "vertexLabel": "Class GetTaskRequestBuilder"
    },
    {
      "vertexName": "EnumConstant AWAITING_INFO  (AllocationDecision.java)",
      "children": [
        {
          "name": "EnumConstant FETCHING_SHARD_DATA  (UnassignedInfo.java)"
        }
      ],
      "comment": "\n     * Waiting on getting shard data from all nodes before making a decision\n     * about where to allocate the shard.\n     ",
      "vertexLabel": "EnumConstant AWAITING_INFO"
    },
    {
      "vertexName": "Method public static BackoffPolicy constantBackoff(TimeValue delay, int maxNumberOfRetries)  (BackoffPolicy.java)",
      "children": [
        {
          "name": "Method public static BackoffPolicy exponentialBackoff()  (BackoffPolicy.java)"
        }
      ],
      "comment": "\n     * Creates an new constant backoff policy with the provided configuration.\n     *\n     * @param delay              The delay defines how long to wait between retry attempts. Must not be null.\n     *                           Must be &lt;= <code>Integer.MAX_VALUE</code> ms.\n     * @param maxNumberOfRetries The maximum number of retries. Must be a non-negative number.\n     * @return A backoff policy with a constant wait time between retries. The returned instance is thread safe but each\n     * iterator created from it should only be used by a single thread.\n     ",
      "vertexLabel": "BackoffPolicy constantBackoff()"
    },
    {
      "vertexName": "Method public UpdateRequestBuilder setWaitForActiveShards(final int waitForActiveShards)  (UpdateRequestBuilder.java)",
      "children": [
        {
          "name": "Method public ResizeRequestBuilder setWaitForActiveShards(final int waitForActiveShards)  (ResizeRequestBuilder.java)"
        }
      ],
      "comment": "\n     * A shortcut for {@link #setWaitForActiveShards(ActiveShardCount)} where the numerical\n     * shard count is passed in, instead of having to first call {@link ActiveShardCount#from(int)}\n     * to get the ActiveShardCount.\n     ",
      "vertexLabel": "UpdateRequestBuilder setWaitForActiveShards()"
    },
    {
      "vertexName": "Method public ClusterHealthRequest waitForActiveShards(final int waitForActiveShards)  (ClusterHealthRequest.java)",
      "children": [
        {
          "name": "Method public BulkRequest waitForActiveShards(final int waitForActiveShards)  (BulkRequest.java)"
        }
      ],
      "comment": "\n     * A shortcut for {@link #waitForActiveShards(ActiveShardCount)} where the numerical\n     * shard count is passed in, instead of having to first call {@link ActiveShardCount#from(int)}\n     * to get the ActiveShardCount.\n     ",
      "vertexLabel": "ClusterHealthRequest waitForActiveShards()"
    },
    {
      "vertexName": "Method public boolean keyed()  (DateHistogramAggregationBuilder.java)",
      "comment": " Return whether buckets should be returned as a hash. In case\n     *  {@code keyed} is false, buckets will be returned as an array. ",
      "vertexLabel": "boolean keyed()"
    },
    {
      "vertexName": "Method public static MapBinder<K, V> newMapBinder(Binder binder, TypeLiteral<K> keyType, TypeLiteral<V> valueType)  (MapBinder.java)",
      "comment": "\n     * Returns a new mapbinder that collects entries of {@code keyType}/{@code valueType} in a\n     * {@link Map} that is itself bound with no binding annotation.\n     ",
      "vertexLabel": "MapBinder<K, V> newMapBinder()"
    },
    {
      "vertexName": "Method public long addWithoutBreaking(long bytes)  (ChildMemoryCircuitBreaker.java)",
      "comment": "\n     * Add an <b>exact</b> number of bytes, not checking for tripping the\n     * circuit breaker. This bypasses the overheadConstant multiplication.\n     *\n     * Also does not check with the parent breaker to see if the parent limit\n     * has been exceeded.\n     *\n     * @param bytes number of bytes to add to the breaker\n     * @return number of \"used\" bytes so far\n     ",
      "vertexLabel": "long addWithoutBreaking()"
    },
    {
      "vertexName": "Method public FieldCapabilities(String name, String type, boolean isSearchable, boolean isAggregatable)  (FieldCapabilities.java)",
      "comment": "\n     * Constructor\n     * @param name The name of the field.\n     * @param type The type associated with the field.\n     * @param isSearchable Whether this field is indexed for search.\n     * @param isAggregatable Whether this field can be aggregated on.\n     ",
      "vertexLabel": "FieldCapabilities()"
    },
    {
      "vertexName": "Method public ClusterUpdateSettingsRequestBuilder setTransientSettings(String settings, XContentType xContentType)  (ClusterUpdateSettingsRequestBuilder.java)",
      "children": [
        {
          "name": "Method public ClusterUpdateSettingsRequest transientSettings(String source, XContentType xContentType)  (ClusterUpdateSettingsRequest.java)"
        }
      ],
      "comment": "\n     * Sets the source containing the transient settings to be updated. They will not survive a full cluster restart\n     ",
      "vertexLabel": "ClusterUpdateSettingsRequestBuilder setTransientSettings()"
    },
    {
      "vertexName": "Method public static double min(double[] values)  (MovingFunctions.java)",
      "children": [
        {
          "name": "Method public static double sum(double[] values)  (MovingFunctions.java)"
        }
      ],
      "comment": "\n     * Find the minimum value in a window of values\n     * If all values are missing/null/NaN, the return value will be NaN\n     ",
      "vertexLabel": "double min()"
    },
    {
      "vertexName": "Method public WildcardQueryBuilder(String fieldName, String value)  (WildcardQueryBuilder.java)",
      "children": [
        {
          "name": "Method public static WildcardQueryBuilder wildcardQuery(String name, String query)  (QueryBuilders.java)"
        }
      ],
      "comment": "\n     * Implements the wildcard search query. Supported wildcards are {@code *}, which\n     * matches any character sequence (including the empty one), and {@code ?},\n     * which matches any single character. Note this query can be slow, as it\n     * needs to iterate over many terms. In order to prevent extremely slow WildcardQueries,\n     * a Wildcard term should not start with one of the wildcards {@code *} or\n     * {@code ?}.\n     *\n     * @param fieldName The field name\n     * @param value The wildcard query string\n     ",
      "vertexLabel": "WildcardQueryBuilder()"
    },
    {
      "vertexName": "Method public SearchRequestBuilder setRescorer(RescorerBuilder rescorer, int window)  (SearchRequestBuilder.java)",
      "children": [
        {
          "name": "Method public SearchRequestBuilder setRescorer(RescorerBuilder<?> rescorer)  (SearchRequestBuilder.java)"
        }
      ],
      "comment": "\n     * Clears all rescorers on the builder and sets the first one.  To use multiple rescore windows use\n     * {@link #addRescorer(org.elasticsearch.search.rescore.RescorerBuilder, int)}.\n     *\n     * @param rescorer rescorer configuration\n     * @param window   rescore window\n     * @return this for chaining\n     ",
      "vertexLabel": "SearchRequestBuilder setRescorer()"
    },
    {
      "vertexName": "Class RefreshRequest  (RefreshRequest.java)",
      "children": [
        {
          "name": "Class RefreshRequestBuilder  (RefreshRequestBuilder.java)"
        }
      ],
      "comment": "\n * A refresh request making all operations performed since the last refresh available for search. The (near) real-time\n * capabilities depends on the index engine used. For example, the internal one requires refresh to be called, but by\n * default a refresh is scheduled periodically.\n *\n * @see org.elasticsearch.client.Requests#refreshRequest(String...)\n * @see org.elasticsearch.client.IndicesAdminClient#refresh(RefreshRequest)\n * @see RefreshResponse\n ",
      "vertexLabel": "Class RefreshRequest"
    },
    {
      "vertexName": "Method public void setMaxNumTokensParsed(int i)  (XMoreLikeThis.java)",
      "children": [
        {
          "name": "Field maxNumTokensParsed  (XMoreLikeThis.java)"
        }
      ],
      "comment": "\n     * @param i The maximum number of tokens to parse in each example doc field that is not stored with TermVector support\n     ",
      "vertexLabel": "void setMaxNumTokensParsed()"
    },
    {
      "vertexName": "Method public int maxExpansions()  (MatchPhrasePrefixQueryBuilder.java)",
      "children": [
        {
          "name": "Method public int maxExpansions()  (MatchQueryBuilder.java)"
        }
      ],
      "comment": "\n     * Get the (optional) number of term expansions when using fuzzy or prefix\n     * type query.\n     ",
      "vertexLabel": "int maxExpansions()"
    },
    {
      "vertexName": "Method ActionFuture<AcknowledgedResponse> putMapping(PutMappingRequest request)  (IndicesAdminClient.java)",
      "comment": "\n     * Add mapping definition for a type into one or more indices.\n     *\n     * @param request The create mapping request\n     * @return A result future\n     * @see org.elasticsearch.client.Requests#putMappingRequest(String...)\n     ",
      "vertexLabel": "ActionFuture<AcknowledgedResponse> putMapping()"
    },
    {
      "vertexName": "Method public String routing()  (UpdateRequest.java)",
      "children": [
        {
          "name": "Method public GetRequest routing(String routing)  (GetRequest.java)"
        }
      ],
      "comment": "\n     * Controls the shard routing of the request. Using this value to hash the shard\n     * and not the id.\n     ",
      "vertexLabel": "String routing()"
    },
    {
      "vertexName": "Method public boolean hasField(String path)  (IngestDocument.java)",
      "comment": "\n     * Checks whether the document contains a value for the provided path\n     * @param path The path within the document in dot-notation\n     * @return true if the document contains a value for the field, false otherwise\n     * @throws IllegalArgumentException if the path is null, empty or invalid.\n     ",
      "vertexLabel": "boolean hasField()"
    },
    {
      "vertexName": "Method public BulkRequest waitForActiveShards(ActiveShardCount waitForActiveShards)  (BulkRequest.java)",
      "children": [
        {
          "name": "Method public Self waitForActiveShards(ActiveShardCount activeShardCount)  (AbstractBulkByScrollRequestBuilder.java)"
        }
      ],
      "comment": "\n     * Sets the number of shard copies that must be active before proceeding with the write.\n     * See {@link ReplicationRequest#waitForActiveShards(ActiveShardCount)} for details.\n     ",
      "vertexLabel": "BulkRequest waitForActiveShards()"
    },
    {
      "vertexName": "Method public static void normalizePoint(GeoPoint point)  (GeoUtils.java)",
      "comment": "\n     * Normalize the geo {@code Point} for its coordinates to lie within their\n     * respective normalized ranges.\n     * <p>\n     * Note: A shift of 180&deg; is applied in the longitude if necessary,\n     * in order to normalize properly the latitude.\n     *\n     * @param point The point to normalize in-place.\n     ",
      "vertexLabel": "void normalizePoint()"
    },
    {
      "vertexName": "Method public SearchRequestBuilder setRouting(String routing)  (SearchRequestBuilder.java)",
      "children": [
        {
          "name": "Method public String routing()  (SearchRequest.java)"
        }
      ],
      "comment": "\n     * A comma separated list of routing values to control the shards the search will be executed on.\n     ",
      "vertexLabel": "SearchRequestBuilder setRouting()"
    },
    {
      "vertexName": "Method static TopDocsCollectorContext createTopDocsCollectorContext(SearchContext searchContext, IndexReader reader, boolean hasFilterCollector) throws IOException  (TopDocsCollectorContext.java)",
      "comment": "\n     * Creates a {@link TopDocsCollectorContext} from the provided <code>searchContext</code>.\n     * @param hasFilterCollector True if the collector chain contains at least one collector that can filters document.\n     ",
      "vertexLabel": "TopDocsCollectorContext createTopDocsCollectorContext()"
    },
    {
      "vertexName": "Method public Builder put(String key, ByteSizeValue byteSizeValue)  (Settings.java)",
      "children": [
        {
          "name": "Method public Builder put(String key, String value)  (Settings.java)"
        }
      ],
      "comment": "\n         * Sets a byteSizeValue setting with the provided setting key and byteSizeValue.\n         *\n         * @param key  The setting key\n         * @param byteSizeValue The setting value\n         * @return The builder\n         ",
      "vertexLabel": "Builder put()"
    },
    {
      "vertexName": "Method public SearchRequest routing(String routing)  (SearchRequest.java)",
      "children": [
        {
          "name": "Method public String routing()  (SearchRequest.java)"
        }
      ],
      "comment": "\n     * A comma separated list of routing values to control the shards the search will be executed on.\n     ",
      "vertexLabel": "SearchRequest routing()"
    },
    {
      "vertexName": "Method public TimeValue getAsTime(String setting, TimeValue defaultValue)  (Settings.java)",
      "children": [
        {
          "name": "Method public Integer getAsInt(String setting, Integer defaultValue)  (Settings.java)"
        }
      ],
      "comment": "\n     * Returns the setting value (as time) associated with the setting key. If it does not exists,\n     * returns the default value provided.\n     ",
      "vertexLabel": "TimeValue getAsTime()"
    },
    {
      "vertexName": "Method void beforeIndexShardDeleted(ShardId shardId, Settings indexSettings)  (IndexEventListener.java)",
      "children": [
        {
          "name": "Method void afterIndexShardDeleted(ShardId shardId, Settings indexSettings)  (IndexEventListener.java)"
        }
      ],
      "comment": "\n     * Called before the index shard gets deleted from disk\n     * Note: this method is only executed on the first attempt of deleting the shard. Retries are will not invoke\n     * this method.\n     * @param shardId The shard id\n     * @param indexSettings the shards index settings\n     ",
      "vertexLabel": "void beforeIndexShardDeleted()"
    },
    {
      "vertexName": "Method public SearchRequestBuilder setFetchSource(@Nullable String include, @Nullable String exclude)  (SearchRequestBuilder.java)",
      "children": [
        {
          "name": "Method public ExplainRequestBuilder setFetchSource(@Nullable String include, @Nullable String exclude)  (ExplainRequestBuilder.java)"
        }
      ],
      "comment": "\n     * Indicate that _source should be returned with every hit, with an \"include\" and/or \"exclude\" set which can include simple wildcard\n     * elements.\n     *\n     * @param include An optional include (optionally wildcarded) pattern to filter the returned _source\n     * @param exclude An optional exclude (optionally wildcarded) pattern to filter the returned _source\n     ",
      "vertexLabel": "SearchRequestBuilder setFetchSource()"
    },
    {
      "vertexName": "Method public IndexRequestBuilder setSource(XContentType xContentType, Object... source)  (IndexRequestBuilder.java)",
      "children": [
        {
          "name": "Method public IndexRequestBuilder setSource(Object... source)  (IndexRequestBuilder.java)"
        }
      ],
      "comment": "\n     * Constructs a simple document with a field name and value pairs.\n     * <p>\n     * <b>Note: the number of objects passed as varargs to this method must be an even\n     * number. Also the first argument in each pair (the field name) must have a\n     * valid String representation.</b>\n     * </p>\n     ",
      "vertexLabel": "IndexRequestBuilder setSource()"
    },
    {
      "vertexName": "Method public PutIndexTemplateRequest mapping(String type, String source, XContentType xContentType)  (PutIndexTemplateRequest.java)",
      "children": [
        {
          "name": "Method public CreateIndexRequest mapping(String type, String source, XContentType xContentType)  (CreateIndexRequest.java)"
        }
      ],
      "comment": "\n     * Adds mapping that will be added when the index gets created.\n     *\n     * @param type   The mapping type\n     * @param source The mapping source\n     * @param xContentType The type of content contained within the source\n     ",
      "vertexLabel": "PutIndexTemplateRequest mapping()"
    },
    {
      "vertexName": "Method public Builder put(String key, String value)  (Settings.java)",
      "comment": "\n         * Sets a setting with the provided setting key and value.\n         *\n         * @param key   The setting key\n         * @param value The setting value\n         * @return The builder\n         ",
      "vertexLabel": "Builder put()"
    },
    {
      "vertexName": "Method public HistogramAggregationBuilder order(BucketOrder order)  (HistogramAggregationBuilder.java)",
      "children": [
        {
          "name": "Method public TermsAggregationBuilder order(BucketOrder order)  (TermsAggregationBuilder.java)"
        }
      ],
      "comment": " Set a new order on this builder and return the builder so that calls\n     *  can be chained. A tie-breaker may be added to avoid non-deterministic ordering. ",
      "vertexLabel": "HistogramAggregationBuilder order()"
    },
    {
      "vertexName": "Method public abstract void toXContent(XContentBuilder builder, T state) throws IOException  (MetaDataStateFormat.java)",
      "comment": "\n     * Writes the given state to the given XContentBuilder\n     * Subclasses need to implement this class for theirs specific state.\n     ",
      "vertexLabel": "abstract void toXContent()"
    },
    {
      "vertexName": "Method protected boolean setException(Throwable throwable)  (BaseFuture.java)",
      "children": [
        {
          "name": "Method protected boolean set(@Nullable V value)  (BaseFuture.java)"
        }
      ],
      "comment": "\n     * Subclasses should invoke this method to set the result of the computation\n     * to an error, {@code throwable}.  This will set the state of the future to\n     * {@link BaseFuture.Sync#COMPLETED} and call {@link #done()} if the\n     * state was successfully changed.\n     *\n     * @param throwable the exception that the task failed with.\n     * @return true if the state was successfully changed.\n     * @throws Error if the throwable was an {@link Error}.\n     ",
      "vertexLabel": "boolean setException()"
    },
    {
      "vertexName": "Method public void setBoost(boolean boost)  (XMoreLikeThis.java)",
      "comment": "\n     * Sets whether to boost terms in query based on \"score\" or not.\n     *\n     * @param boost true to boost terms in query based on \"score\", false otherwise.\n     * @see #isBoost\n     ",
      "vertexLabel": "void setBoost()"
    },
    {
      "vertexName": "Method public FieldCapabilities(String name, String type, boolean isSearchable, boolean isAggregatable, String[] indices, String[] nonSearchableIndices, String[] nonAggregatableIndices)  (FieldCapabilities.java)",
      "children": [
        {
          "name": "Method public FieldCapabilities(String name, String type, boolean isSearchable, boolean isAggregatable)  (FieldCapabilities.java)"
        },
        {
          "name": "Method public String[] nonSearchableIndices()  (FieldCapabilities.java)"
        }
      ],
      "comment": "\n     * Constructor\n     * @param name The name of the field\n     * @param type The type associated with the field.\n     * @param isSearchable Whether this field is indexed for search.\n     * @param isAggregatable Whether this field can be aggregated on.\n     * @param indices The list of indices where this field name is defined as {@code type},\n     *                or null if all indices have the same {@code type} for the field.\n     * @param nonSearchableIndices The list of indices where this field is not searchable,\n     *                             or null if the field is searchable in all indices.\n     * @param nonAggregatableIndices The list of indices where this field is not aggregatable,\n     *                               or null if the field is aggregatable in all indices.\n     ",
      "vertexLabel": "FieldCapabilities()"
    },
    {
      "vertexName": "Method public static boolean isKeyAsc(BucketOrder order)  (InternalOrder.java)",
      "comment": "\n     * Determine if the ordering strategy is sorting on bucket key ascending.\n     *\n     * @param order bucket ordering strategy to check.\n     * @return {@code true} if the ordering strategy is sorting on bucket key ascending, {@code false} otherwise.\n     ",
      "vertexLabel": "boolean isKeyAsc()"
    },
    {
      "vertexName": "Method public UpdateRequest upsert(Map<String, Object> source)  (UpdateRequest.java)",
      "children": [
        {
          "name": "Method public UpdateRequest upsert(XContentBuilder source)  (UpdateRequest.java)"
        }
      ],
      "comment": "\n     * Sets the doc source of the update request to be used when the document does not exists.\n     ",
      "vertexLabel": "UpdateRequest upsert()"
    },
    {
      "vertexName": "Method public abstract long nextRoundingValue(long value)  (Rounding.java)",
      "children": [
        {
          "name": "Method public abstract long nextRoundingValue(long value)  (Rounding.java)"
        }
      ],
      "comment": "\n     * Given the rounded value (which was potentially generated by {@link #round(long)}, returns the next rounding value. For example, with\n     * interval based rounding, if the interval is 3, {@code nextRoundValue(6) = 9 }.\n     *\n     * @param value The current rounding value\n     * @return      The next rounding value;\n     ",
      "vertexLabel": "abstract long nextRoundingValue()"
    },
    {
      "vertexName": "Interface Writeable  (Writeable.java)",
      "comment": "\n * Implementers can be written to a {@linkplain StreamOutput} and read from a {@linkplain StreamInput}. This allows them to be \"thrown\n * across the wire\" using Elasticsearch's internal protocol. If the implementer also implements equals and hashCode then a copy made by\n * serializing and deserializing must be equal and have the same hashCode. It isn't required that such a copy be entirely unchanged.\n * <p>\n * Prefer implementing this interface over implementing {@link Streamable} where possible. Lots of code depends on {@linkplain Streamable}\n * so this isn't always possible.\n ",
      "vertexLabel": "Interface Writeable"
    },
    {
      "vertexName": "Method public String get(String setting, String defaultValue)  (Settings.java)",
      "comment": "\n     * Returns the setting value associated with the setting key. If it does not exists,\n     * returns the default value provided.\n     ",
      "vertexLabel": "String get()"
    },
    {
      "vertexName": "Method public static String randomBase64UUID(Random random)  (UUIDs.java)",
      "children": [
        {
          "name": "Method public String getBase64UUID()  (RandomBasedUUIDGenerator.java)"
        }
      ],
      "comment": " Returns a Base64 encoded version of a Version 4.0 compatible UUID as defined here: http://www.ietf.org/rfc/rfc4122.txt, using the\n     *  provided {@code Random} instance ",
      "vertexLabel": "String randomBase64UUID()"
    },
    {
      "vertexName": "Method public MultiGetRequest preference(String preference)  (MultiGetRequest.java)",
      "children": [
        {
          "name": "Method public SearchRequest preference(String preference)  (SearchRequest.java)"
        }
      ],
      "comment": "\n     * Sets the preference to execute the search. Defaults to randomize across shards. Can be set to\n     * {@code _local} to prefer local shards or a custom value, which guarantees that the same order\n     * will be used across different requests.\n     ",
      "vertexLabel": "MultiGetRequest preference()"
    },
    {
      "vertexName": "Method Client getRemoteClusterClient(String clusterAlias)  (Client.java)",
      "comment": "\n     * Returns a client to a remote cluster with the given cluster alias.\n     *\n     * @throws IllegalArgumentException if the given clusterAlias doesn't exist\n     * @throws UnsupportedOperationException if this functionality is not available on this client.\n     ",
      "vertexLabel": "Client getRemoteClusterClient()"
    },
    {
      "vertexName": "Method public String getNestedPath()  (FieldSortBuilder.java)",
      "comment": "\n     * Returns the nested path if sorting occurs in a field that is inside a\n     * nested object.\n     * @deprecated set nested sort with {@link #setNestedSort(NestedSortBuilder)} and retrieve with {@link #getNestedSort()}\n     ",
      "vertexLabel": "String getNestedPath()"
    },
    {
      "vertexName": "Method void restoreShard(IndexShard shard, SnapshotId snapshotId, Version version, IndexId indexId, ShardId snapshotShardId, RecoveryState recoveryState)  (Repository.java)",
      "children": [
        {
          "name": "Method RestoreContext(IndexShard shard, SnapshotId snapshotId, Version version, IndexId indexId, ShardId snapshotShardId, RecoveryState recoveryState)  (BlobStoreRepository.java)"
        },
        {
          "name": "Method IndexShardSnapshotStatus getShardSnapshotStatus(SnapshotId snapshotId, Version version, IndexId indexId, ShardId shardId)  (Repository.java)"
        }
      ],
      "comment": "\n     * Restores snapshot of the shard.\n     * <p>\n     * The index can be renamed on restore, hence different {@code shardId} and {@code snapshotShardId} are supplied.\n     *\n     * @param shard           the shard to restore the index into\n     * @param snapshotId      snapshot id\n     * @param version         version of elasticsearch that created this snapshot\n     * @param indexId         id of the index in the repository from which the restore is occurring\n     * @param snapshotShardId shard id (in the snapshot)\n     * @param recoveryState   recovery state\n     ",
      "vertexLabel": "void restoreShard()"
    },
    {
      "vertexName": "Method public TermVectorsRequest(String index, String type, String id)  (TermVectorsRequest.java)",
      "comment": "\n     * Constructs a new term vector request for a document that will be fetch\n     * from the provided index. Use {@link #type(String)} and\n     * {@link #id(String)} to specify the document to load.\n     ",
      "vertexLabel": "TermVectorsRequest()"
    },
    {
      "vertexName": "Method ClusterTasksResult<T> execute(ClusterState currentState, List<T> tasks) throws Exception  (ClusterStateTaskExecutor.java)",
      "children": [
        {
          "name": "Method public abstract ClusterState execute(ClusterState currentState) throws Exception  (ClusterStateUpdateTask.java)"
        }
      ],
      "comment": "\n     * Update the cluster state based on the current state and the given tasks. Return the *same instance* if no state\n     * should be changed.\n     ",
      "vertexLabel": "ClusterTasksResult<T> execute()"
    },
    {
      "vertexName": "Method void onResponse(Response response)  (ActionListener.java)",
      "comment": "\n     * Handle action response. This response may constitute a failure or a\n     * success but it is up to the listener to make that decision.\n     ",
      "vertexLabel": "void onResponse()"
    },
    {
      "vertexName": "Method public List<String> getAsList(String key, List<String> defaultValue, Boolean commaDelimited) throws SettingsException  (Settings.java)",
      "children": [
        {
          "name": "Method public List<String> getAsList(String key) throws SettingsException  (Settings.java)"
        }
      ],
      "comment": "\n     * The values associated with a setting key as an immutable list.\n     * <p>\n     * It will also automatically load a comma separated list under the settingPrefix and merge with\n     * the numbered format.\n     *\n     * @param key  The setting key to load the list by\n     * @param defaultValue   The default value to use if no value is specified\n     * @param commaDelimited Whether to try to parse a string as a comma-delimited value\n     * @return The setting list values\n     ",
      "vertexLabel": "List<String> getAsList()"
    },
    {
      "vertexName": "Method public static ObjectObjectHashMap<K, V> newMap(int expectedElements)  (HppcMaps.java)",
      "comment": "\n     * Returns a new map with the given number of expected elements.\n     * \n     * @param expectedElements\n     *          The expected number of elements guaranteed not to cause buffer\n     *          expansion (inclusive).\n     ",
      "vertexLabel": "ObjectObjectHashMap<K, V> newMap()"
    },
    {
      "vertexName": "Method public static final E addNeighbors(String geohash, int length, E neighbors)  (GeoHashUtils.java)",
      "children": [
        {
          "name": "Method public static final E addNeighbors(String geohash, E neighbors)  (GeoHashUtils.java)"
        }
      ],
      "comment": "\n     * Add all geohashes of the cells next to a given geohash to a list.\n     *\n     * @param geohash   Geohash of a specified cell\n     * @param length    level of the given geohash\n     * @param neighbors list to add the neighbors to\n     * @return the given list\n     ",
      "vertexLabel": "final E addNeighbors()"
    },
    {
      "vertexName": "Field alpha  (EwmaModel.java)",
      "children": [
        {
          "name": "Field beta  (HoltLinearModel.java)"
        }
      ],
      "comment": "\n     * Controls smoothing of data.  Also known as \"level\" value.\n     * Alpha = 1 retains no memory of past values\n     * (e.g. random walk), while alpha = 0 retains infinite memory of past values (e.g.\n     * mean of the series).\n     ",
      "vertexLabel": "Field alpha"
    },
    {
      "vertexName": "Method public void parse(ParseContext context) throws IOException  (CompletionFieldMapper.java)",
      "children": [
        {
          "name": "Method private void parse(ParseContext parseContext, Token token, XContentParser parser, Map<String, CompletionInputMetaData> inputMap) throws IOException  (CompletionFieldMapper.java)"
        }
      ],
      "comment": "\n     * Parses and indexes inputs\n     *\n     * Parsing:\n     *  Acceptable format:\n     *   \"STRING\" - interpreted as field value (input)\n     *   \"ARRAY\" - each element can be one of \"OBJECT\" (see below)\n     *   \"OBJECT\" - { \"input\": STRING|ARRAY, \"weight\": STRING|INT, \"contexts\": ARRAY|OBJECT }\n     *\n     * Indexing:\n     *  if context mappings are defined, delegates to {@link ContextMappings#addField(ParseContext.Document, String, String, int, Map)}\n     *  else adds inputs as a {@link org.apache.lucene.search.suggest.document.SuggestField}\n     ",
      "vertexLabel": "void parse()"
    },
    {
      "vertexName": "Method public Setting(Key key, Function<Settings, String> defaultValue, Function<String, T> parser, Property... properties)  (Setting.java)",
      "children": [
        {
          "name": "Method public Setting(String key, String defaultValue, Function<String, T> parser, Property... properties)  (Setting.java)"
        }
      ],
      "comment": "\n     * Creates a new Setting instance\n     * @param key the settings key for this setting.\n     * @param defaultValue a default value function that returns the default values string representation.\n     * @param parser a parser that parses the string rep into a complex datatype.\n     * @param properties properties for this setting like scope, filtering...\n     ",
      "vertexLabel": "Setting()"
    },
    {
      "vertexName": "Method public static IndexRequest indexRequest(String index)  (Requests.java)",
      "children": [
        {
          "name": "Method public static DeleteRequest deleteRequest(String index)  (Requests.java)"
        }
      ],
      "comment": "\n     * Create an index request against a specific index. Note the {@link IndexRequest#type(String)} must be\n     * set as well and optionally the {@link IndexRequest#id(String)}.\n     *\n     * @param index The index name to index the request against\n     * @return The index request\n     * @see org.elasticsearch.client.Client#index(org.elasticsearch.action.index.IndexRequest)\n     ",
      "vertexLabel": "IndexRequest indexRequest()"
    },
    {
      "vertexName": "Method public static Set<T> difference(Set<T> left, Set<T> right)  (Sets.java)",
      "comment": "\n     * The relative complement, or difference, of the specified left and right set. Namely, the resulting set contains all the elements that\n     * are in the left set but not in the right set. Neither input is mutated by this operation, an entirely new set is returned.\n     *\n     * @param left  the left set\n     * @param right the right set\n     * @param <T>   the type of the elements of the sets\n     * @return the relative complement of the left set with respect to the right set\n     ",
      "vertexLabel": "Set<T> difference()"
    },
    {
      "vertexName": "Method public Builder putList(String setting, List<String> values)  (Settings.java)",
      "children": [
        {
          "name": "Method public Builder put(String setting, int value)  (Settings.java)"
        }
      ],
      "comment": "\n         * Sets the setting with the provided setting key and a list of values.\n         *\n         * @param setting The setting key\n         * @param values  The values\n         * @return The builder\n         ",
      "vertexLabel": "Builder putList()"
    },
    {
      "vertexName": "Method public FuzzyQueryBuilder(String fieldName, int value)  (FuzzyQueryBuilder.java)",
      "children": [
        {
          "name": "Method public FuzzyQueryBuilder(String fieldName, String value)  (FuzzyQueryBuilder.java)"
        }
      ],
      "comment": "\n     * Constructs a new fuzzy query.\n     *\n     * @param fieldName  The name of the field\n     * @param value The value of the text\n     ",
      "vertexLabel": "FuzzyQueryBuilder()"
    },
    {
      "vertexName": "Method static long x(long d, long m, long over)  (ByteSizeUnit.java)",
      "comment": "\n     * Scale d by m, checking for overflow.\n     * This has a short name to make above code more readable.\n     ",
      "vertexLabel": "long x()"
    },
    {
      "vertexName": "Method public MoreLikeThisQueryBuilder stopWords(String... stopWords)  (MoreLikeThisQueryBuilder.java)",
      "comment": "\n     * Set the set of stopwords.\n     * <p>\n     * Any word in this set is considered \"uninteresting\" and ignored. Even if your Analyzer allows stopwords, you\n     * might want to tell the MoreLikeThis code to ignore them, as for the purposes of document similarity it seems\n     * reasonable to assume that \"a stop word is never interesting\".\n     ",
      "vertexLabel": "MoreLikeThisQueryBuilder stopWords()"
    },
    {
      "vertexName": "Method public GetRequest preference(String preference)  (GetRequest.java)",
      "children": [
        {
          "name": "Method public SearchRequest preference(String preference)  (SearchRequest.java)"
        }
      ],
      "comment": "\n     * Sets the preference to execute the search. Defaults to randomize across shards. Can be set to\n     * {@code _local} to prefer local shards or a custom value, which guarantees that the same order\n     * will be used across different requests.\n     ",
      "vertexLabel": "GetRequest preference()"
    },
    {
      "vertexName": "Class MembersInjectorLookup  (MembersInjectorLookup.java)",
      "children": [
        {
          "name": "Class ProviderLookup  (ProviderLookup.java)"
        }
      ],
      "comment": "\n * A lookup of the members injector for a type. Lookups are created explicitly in a module using\n * {@link org.elasticsearch.common.inject.Binder#getMembersInjector(Class) getMembersInjector()} statements:\n * <pre>\n *     MembersInjector&lt;PaymentService&gt; membersInjector\n *         = getMembersInjector(PaymentService.class);</pre>\n *\n * @author crazybob@google.com (Bob Lee)\n * @since 2.0\n ",
      "vertexLabel": "Class MembersInjectorLookup"
    },
    {
      "vertexName": "Method public static MoreLikeThisQueryBuilder moreLikeThisQuery(String[] likeTexts, Item[] likeItems)  (QueryBuilders.java)",
      "children": [
        {
          "name": "Method public MoreLikeThisQueryBuilder(String[] likeTexts, Item[] likeItems)  (MoreLikeThisQueryBuilder.java)"
        },
        {
          "name": "Method public static MoreLikeThisQueryBuilder moreLikeThisQuery(Item[] likeItems)  (QueryBuilders.java)"
        }
      ],
      "comment": "\n     * A more like this query that finds documents that are \"like\" the provided texts or documents\n     * which is checked against the \"_all\" field.\n     * @param likeTexts the text to use when generating the 'More Like This' query.\n     * @param likeItems the documents to use when generating the 'More Like This' query.\n     ",
      "vertexLabel": "MoreLikeThisQueryBuilder moreLikeThisQuery()"
    },
    {
      "vertexName": "Method public final void onModule(SettingsModule settingsModule)  (Plugin.java)",
      "children": [
        {
          "name": "Method public final void onModule(IndexModule indexModule)  (Plugin.java)"
        }
      ],
      "comment": "\n     * Old-style guice settings extension point. {@code @Deprecated} and {@code final} to act as a signpost for plugin authors upgrading\n     * from 2.x.\n     *\n     * @deprecated use #getSettings and #getSettingsFilter instead\n     ",
      "vertexLabel": "final void onModule()"
    },
    {
      "vertexName": "Method public ClusterStateObserver(ClusterService clusterService, @Nullable TimeValue timeout, Logger logger, ThreadContext contextHolder)  (ClusterStateObserver.java)",
      "comment": "\n     * @param timeout        a global timeout for this observer. After it has expired the observer\n     *                       will fail any existing or new #waitForNextChange calls. Set to null\n     *                       to wait indefinitely\n     ",
      "vertexLabel": "ClusterStateObserver()"
    },
    {
      "vertexName": "Method protected IndexSearcher wrap(IndexSearcher searcher) throws IOException  (IndexSearcherWrapper.java)",
      "comment": "\n     * @param searcher      The provided index searcher to be wrapped to add custom functionality\n     * @return a new index searcher wrapping the provided index searcher or if no wrapping was performed\n     *         the provided index searcher\n     ",
      "vertexLabel": "IndexSearcher wrap()"
    },
    {
      "vertexName": "Method public TopHitsAggregationBuilder docValueField(String docValueField, String format)  (TopHitsAggregationBuilder.java)",
      "comment": "\n     * Adds a field to load from doc values and return as part of\n     * the search request.\n     ",
      "vertexLabel": "TopHitsAggregationBuilder docValueField()"
    },
    {
      "vertexName": "Method public ElasticsearchException(String msg, Throwable cause, Object... args)  (ElasticsearchException.java)",
      "children": [
        {
          "name": "Method public ElasticsearchException(String msg, Object... args)  (ElasticsearchException.java)"
        }
      ],
      "comment": "\n     * Construct a <code>ElasticsearchException</code> with the specified detail message\n     * and nested exception.\n     *\n     * The message can be parameterized using <code>{}</code> as placeholders for the given\n     * arguments\n     *\n     * @param msg   the detail message\n     * @param cause the nested exception\n     * @param args  the arguments for the message\n     ",
      "vertexLabel": "ElasticsearchException()"
    },
    {
      "vertexName": "EnumConstant UNAUTHORIZED  (RestStatus.java)",
      "children": [
        {
          "name": "EnumConstant PROXY_AUTHENTICATION  (RestStatus.java)"
        }
      ],
      "comment": "\n     * The request requires user authentication. The response MUST include a WWW-Authenticate header field\n     * (section 14.47) containing a challenge applicable to the requested resource. The client MAY repeat the request\n     * with a suitable Authorization header field (section 14.8). If the request already included Authorization\n     * credentials, then the 401 response indicates that authorization has been refused for those credentials.\n     * If the 401 response contains the same challenge as the prior response, and the user agent has already attempted\n     * authentication at least once, then the user SHOULD be presented the entity that was given in the response,\n     * since that entity might include relevant diagnostic information. HTTP access authentication is explained in\n     * \"HTTP Authentication: Basic and Digest Access Authentication\" [43].\n     ",
      "vertexLabel": "EnumConstant UNAUTHORIZED"
    },
    {
      "vertexName": "Method void updateShardState(ShardRouting shardRouting, long primaryTerm, BiConsumer<IndexShard, ActionListener<ResyncTask>> primaryReplicaSyncer, long applyingClusterStateVersion, Set<String> inSyncAllocationIds, IndexShardRoutingTable routingTable, Set<String> pre60AllocationIds) throws IOException  (IndicesClusterStateService.java)",
      "children": [
        {
          "name": "Method public synchronized void updateFromMaster(final long applyingClusterStateVersion, final Set<String> inSyncAllocationIds, final IndexShardRoutingTable routingTable, final Set<String> pre60AllocationIds)  (ReplicationTracker.java)"
        }
      ],
      "comment": "\n         * Updates the shard state based on an incoming cluster state:\n         * - Updates and persists the new routing value.\n         * - Updates the primary term if this shard is a primary.\n         * - Updates the allocation ids that are tracked by the shard if it is a primary.\n         *   See {@link ReplicationTracker#updateFromMaster(long, Set, IndexShardRoutingTable, Set)} for details.\n         *\n         * @param shardRouting                the new routing entry\n         * @param primaryTerm                 the new primary term\n         * @param primaryReplicaSyncer        the primary-replica resync action to trigger when a term is increased on a primary\n         * @param applyingClusterStateVersion the cluster state version being applied when updating the allocation IDs from the master\n         * @param inSyncAllocationIds         the allocation ids of the currently in-sync shard copies\n         * @param routingTable                the shard routing table\n         * @throws IndexShardRelocatedException if shard is marked as relocated and relocation aborted\n         * @throws IOException                  if shard state could not be persisted\n         ",
      "vertexLabel": "void updateShardState()"
    },
    {
      "vertexName": "Method private void endSnapshot(final SnapshotsInProgress.Entry entry, final String failure)  (SnapshotsService.java)",
      "children": [
        {
          "name": "Method void endSnapshot(final SnapshotsInProgress.Entry entry)  (SnapshotsService.java)"
        }
      ],
      "comment": "\n     * Finalizes the shard in repository and then removes it from cluster state\n     * <p>\n     * This is non-blocking method that runs on a thread from SNAPSHOT thread pool\n     *\n     * @param entry   snapshot\n     * @param failure failure reason or null if snapshot was successful\n     ",
      "vertexLabel": "void endSnapshot()"
    },
    {
      "vertexName": "Method public static void tryOpenIndex(Path indexLocation, ShardId shardId, NodeEnvironment.ShardLocker shardLocker, Logger logger) throws IOException, ShardLockObtainFailedException  (Store.java)",
      "comment": "\n     * Tries to open an index for the given location. This includes reading the\n     * segment infos and possible corruption markers. If the index can not\n     * be opened, an exception is thrown\n     ",
      "vertexLabel": "void tryOpenIndex()"
    },
    {
      "vertexName": "Method public TermSuggestionBuilder suggestMode(SuggestMode suggestMode)  (TermSuggestionBuilder.java)",
      "children": [
        {
          "name": "Method public DirectCandidateGeneratorBuilder suggestMode(String suggestMode)  (DirectCandidateGeneratorBuilder.java)"
        }
      ],
      "comment": "\n     * The global suggest mode controls what suggested terms are included or\n     * controls for what suggest text tokens, terms should be suggested for.\n     * Three possible values can be specified:\n     * <ol>\n     * <li><code>missing</code> - Only suggest terms in the suggest text that\n     * aren't in the index. This is the default.\n     * <li><code>popular</code> - Only suggest terms that occur in more docs\n     * then the original suggest text term.\n     * <li><code>always</code> - Suggest any matching suggest terms based on\n     * tokens in the suggest text.\n     * </ol>\n     ",
      "vertexLabel": "TermSuggestionBuilder suggestMode()"
    },
    {
      "vertexName": "Method Set<InjectionPoint> getInjectionPoints()  (InstanceBinding.java)",
      "comment": "\n     * Returns the field and method injection points of the instance, injected at injector-creation\n     * time only.\n     *\n     * @return a possibly empty set\n     ",
      "vertexLabel": "Set<InjectionPoint> getInjectionPoints()"
    },
    {
      "vertexName": "Method public static String readStringProperty(String processorType, String processorTag, Map<String, Object> configuration, String propertyName)  (ConfigurationUtils.java)",
      "children": [
        {
          "name": "Method public static Integer readIntProperty(String processorType, String processorTag, Map<String, Object> configuration, String propertyName, Integer defaultValue)  (ConfigurationUtils.java)"
        }
      ],
      "comment": "\n     * Returns and removes the specified property from the specified configuration map.\n     *\n     * If the property value isn't of type string an {@link ElasticsearchParseException} is thrown.\n     * If the property is missing an {@link ElasticsearchParseException} is thrown\n     ",
      "vertexLabel": "String readStringProperty()"
    },
    {
      "vertexName": "Method public CloseIndexRequestBuilder setIndices(String... indices)  (CloseIndexRequestBuilder.java)",
      "children": [
        {
          "name": "Method public CloseIndexRequest indices(String... indices)  (CloseIndexRequest.java)"
        }
      ],
      "comment": "\n     * Sets the indices to be closed\n     *\n     * @param indices the indices to be closed\n     * @return the request itself\n     ",
      "vertexLabel": "CloseIndexRequestBuilder setIndices()"
    },
    {
      "vertexName": "Method MembersInjector<T> getMembersInjector(Class<T> type)  (TypeEncounter.java)",
      "children": [
        {
          "name": "Method MembersInjector<T> getMembersInjector(TypeLiteral<T> typeLiteral)  (Injector.java)"
        },
        {
          "name": "Method public MembersInjector<T> getMembersInjector()  (MembersInjectorLookup.java)"
        }
      ],
      "comment": "\n     * Returns the members injector used to inject dependencies into methods and fields on instances\n     * of the given type {@code T}. The returned members injector will not be valid until the main\n     * injector has been created. The members injector will throw an {@code IllegalStateException}\n     * if you try to use it beforehand.\n     *\n     * @param type type to get members injector for\n     ",
      "vertexLabel": "MembersInjector<T> getMembersInjector()"
    },
    {
      "vertexName": "Method public IndexSettings(final IndexMetaData indexMetaData, final Settings nodeSettings, IndexScopedSettings indexScopedSettings)  (IndexSettings.java)",
      "children": [
        {
          "name": "Method public IndexSettings(final IndexMetaData indexMetaData, final Settings nodeSettings)  (IndexSettings.java)"
        }
      ],
      "comment": "\n     * Creates a new {@link IndexSettings} instance. The given node settings will be merged with the settings in the metadata\n     * while index level settings will overwrite node settings.\n     *\n     * @param indexMetaData the index metadata this settings object is associated with\n     * @param nodeSettings the nodes settings this index is allocated on.\n     ",
      "vertexLabel": "IndexSettings()"
    },
    {
      "vertexName": "Method public Path getRootStatePath()  (ShardPath.java)",
      "children": [
        {
          "name": "Method public Path getRootDataPath()  (ShardPath.java)"
        }
      ],
      "comment": "\n     * Returns the state-path root for this shard. The root is a parent of {@link #getRootStatePath()} ()} without the index name\n     * and the shard ID.\n     ",
      "vertexLabel": "Path getRootStatePath()"
    },
    {
      "vertexName": "Method public Self setWaitForActiveShards(final int waitForActiveShards)  (AbstractBulkByScrollRequest.java)",
      "children": [
        {
          "name": "Method public ResizeRequestBuilder setWaitForActiveShards(final int waitForActiveShards)  (ResizeRequestBuilder.java)"
        }
      ],
      "comment": "\n     * A shortcut for {@link #setWaitForActiveShards(ActiveShardCount)} where the numerical\n     * shard count is passed in, instead of having to first call {@link ActiveShardCount#from(int)}\n     * to get the ActiveShardCount.\n     ",
      "vertexLabel": "Self setWaitForActiveShards()"
    },
    {
      "vertexName": "Method public SnapshotsStatusRequest(String repository)  (SnapshotsStatusRequest.java)",
      "children": [
        {
          "name": "Method public GetSnapshotsRequest(String repository)  (GetSnapshotsRequest.java)"
        }
      ],
      "comment": "\n     * Constructs a new get snapshots request with given repository name\n     *\n     * @param repository repository name\n     ",
      "vertexLabel": "SnapshotsStatusRequest()"
    },
    {
      "vertexName": "Method public ClassPermission(String name, String actions)  (ClassPermission.java)",
      "children": [
        {
          "name": "Method public SpecialPermission(String name, String actions)  (SpecialPermission.java)"
        }
      ],
      "comment": "\n     * Creates a new ClassPermission object.\n     * This constructor exists for use by the {@code Policy} object to instantiate new Permission objects.\n     *\n     * @param name class to grant permission to\n     * @param actions ignored\n     ",
      "vertexLabel": "ClassPermission()"
    },
    {
      "vertexName": "Method public void submitStateUpdateTask(String source, T updateTask)  (ClusterService.java)",
      "children": [
        {
          "name": "Method static ClusterStateTaskConfig build(Priority priority, TimeValue timeout)  (ClusterStateTaskConfig.java)"
        }
      ],
      "comment": "\n     * Submits a cluster state update task; unlike {@link #submitStateUpdateTask(String, Object, ClusterStateTaskConfig,\n     * ClusterStateTaskExecutor, ClusterStateTaskListener)}, submitted updates will not be batched.\n     *\n     * @param source     the source of the cluster state update task\n     * @param updateTask the full context for the cluster state update\n     *                   task\n     *\n     ",
      "vertexLabel": "void submitStateUpdateTask()"
    },
    {
      "vertexName": "Class AllocateEmptyPrimaryAllocationCommand  (AllocateEmptyPrimaryAllocationCommand.java)",
      "comment": "\n * Allocates an unassigned empty primary shard to a specific node. Use with extreme care as this will result in data loss.\n * Allocation deciders are ignored.\n ",
      "vertexLabel": "Class AllocateEmptyPrimaryAllocationCommand"
    },
    {
      "vertexName": "Method public ClusterState applyFailedShards(final ClusterState clusterState, final List<FailedShard> failedShards, final List<StaleShard> staleShards)  (AllocationService.java)",
      "children": [
        {
          "name": "Method public ClusterState applyStartedShards(ClusterState clusterState, List<ShardRouting> startedShards)  (AllocationService.java)"
        },
        {
          "name": "Method public static ClusterState removeStaleIdsWithoutRoutings(ClusterState clusterState, List<StaleShard> staleShards, Logger logger)  (IndexMetaDataUpdater.java)"
        }
      ],
      "comment": "\n     * Applies the failed shards. Note, only assigned ShardRouting instances that exist in the routing table should be\n     * provided as parameter. Also applies a list of allocation ids to remove from the in-sync set for shard copies for which there\n     * are no routing entries in the routing table.\n     *\n     * <p>\n     * If the same instance of ClusterState is returned, then no change has been made.</p>\n     ",
      "vertexLabel": "ClusterState applyFailedShards()"
    },
    {
      "vertexName": "Method public RestoreSnapshotRequestBuilder setIncludeAliases(boolean restoreAliases)  (RestoreSnapshotRequestBuilder.java)",
      "children": [
        {
          "name": "Method public RestoreSnapshotRequest includeAliases(boolean includeAliases)  (RestoreSnapshotRequest.java)"
        }
      ],
      "comment": "\n     * If set to true the restore procedure will restore aliases\n     *\n     * @param restoreAliases true if aliases should be restored from the snapshot\n     * @return this builder\n     ",
      "vertexLabel": "RestoreSnapshotRequestBuilder setIncludeAliases()"
    },
    {
      "vertexName": "Method B setRefreshPolicy(String refreshPolicy)  (WriteRequestBuilder.java)",
      "children": [
        {
          "name": "Method R setRefreshPolicy(String refreshPolicy)  (WriteRequest.java)"
        }
      ],
      "comment": "\n     * Parse the refresh policy from a string, only modifying it if the string is non null. Convenient to use with request parsing.\n     ",
      "vertexLabel": "B setRefreshPolicy()"
    },
    {
      "vertexName": "Method public IndexRequest source(XContentType xContentType, Object... source)  (IndexRequest.java)",
      "comment": "\n     * Sets the content source to index.\n     * <p>\n     * <b>Note: the number of objects passed to this method as varargs must be an even\n     * number. Also the first argument in each pair (the field name) must have a\n     * valid String representation.</b>\n     * </p>\n     ",
      "vertexLabel": "IndexRequest source()"
    },
    {
      "vertexName": "Method public static double[] holtForecast(double[] values, double alpha, double beta, int numForecasts)  (MovingFunctions.java)",
      "comment": "\n     * Version of holt that can \"forecast\", not exposed as a whitelisted function for moving_fn scripts, but\n     * here as compatibility/code sharing for existing moving_avg agg.  Can be removed when moving_avg is gone.\n     ",
      "vertexLabel": "double[] holtForecast()"
    },
    {
      "vertexName": "Method ActionFuture<OpenIndexResponse> open(OpenIndexRequest request)  (IndicesAdminClient.java)",
      "comment": "\n     * Open an index based on the index name.\n     *\n     * @param request The close index request\n     * @return The result future\n     * @see org.elasticsearch.client.Requests#openIndexRequest(String)\n     ",
      "vertexLabel": "ActionFuture<OpenIndexResponse> open()"
    },
    {
      "vertexName": "Method public ImmutableOpenMap<String, Settings> defaultSettings()  (GetIndexResponse.java)",
      "children": [
        {
          "name": "Method public ImmutableOpenMap<String, Settings> getIndexToSettings()  (GetSettingsResponse.java)"
        }
      ],
      "comment": "\n     * If the originating {@link GetIndexRequest} object was configured to include\n     * defaults, this will contain a mapping of index name to {@link Settings} objects.\n     * The returned {@link Settings} objects will contain only those settings taking\n     * effect as defaults.  Any settings explicitly set on the index will be available\n     * via {@link #settings()}.\n     * See also {@link GetIndexRequest#includeDefaults(boolean)}\n     ",
      "vertexLabel": "ImmutableOpenMap<String, Settings> defaultSettings()"
    },
    {
      "vertexName": "Method public void setStopWords(Set<?> stopWords)  (XMoreLikeThis.java)",
      "children": [
        {
          "name": "Method public MoreLikeThisQueryBuilder stopWords(String... stopWords)  (MoreLikeThisQueryBuilder.java)"
        }
      ],
      "comment": "\n     * Set the set of stopwords.\n     * Any word in this set is considered \"uninteresting\" and ignored.\n     * Even if your Analyzer allows stopwords, you might want to tell the MoreLikeThis code to ignore them, as\n     * for the purposes of document similarity it seems reasonable to assume that \"a stop word is never interesting\".\n     *\n     * @param stopWords set of stopwords, if null it means to allow stop words\n     * @see #getStopWords\n     ",
      "vertexLabel": "void setStopWords()"
    },
    {
      "vertexName": "Method public void onAllNodesAcked(@Nullable Exception e)  (AckedClusterStateUpdateTask.java)",
      "children": [
        {
          "name": "Method void onAllNodesAcked(@Nullable Exception e)  (AckedClusterStateTaskListener.java)"
        }
      ],
      "comment": "\n     * Called once all the nodes have acknowledged the cluster state update request. Must be\n     * very lightweight execution, since it gets executed on the cluster service thread.\n     *\n     * @param e optional error that might have been thrown\n     ",
      "vertexLabel": "void onAllNodesAcked()"
    },
    {
      "vertexName": "Method protected void onNonChannelException(Exception exception)  (TcpTransport.java)",
      "comment": "\n     * Exception handler for exceptions that are not associated with a specific channel.\n     *\n     * @param exception the exception\n     ",
      "vertexLabel": "void onNonChannelException()"
    },
    {
      "vertexName": "Method public RestoreSnapshotRequestBuilder setSettings(String source, XContentType xContentType)  (RestoreSnapshotRequestBuilder.java)",
      "children": [
        {
          "name": "Method public RestoreSnapshotRequest settings(String source, XContentType xContentType)  (RestoreSnapshotRequest.java)"
        },
        {
          "name": "Method public PutRepositoryRequestBuilder setSettings(String source, XContentType xContentType)  (PutRepositoryRequestBuilder.java)"
        }
      ],
      "comment": "\n     * Sets repository-specific restore settings in JSON or YAML format\n     * <p>\n     * See repository documentation for more information.\n     *\n     * @param source repository-specific snapshot settings\n     * @param xContentType the content type of the source\n     * @return this builder\n     ",
      "vertexLabel": "RestoreSnapshotRequestBuilder setSettings()"
    },
    {
      "vertexName": "Method public Self setSlices(int slices)  (AbstractBulkByScrollRequest.java)",
      "children": [
        {
          "name": "Field slices  (AbstractBulkByScrollRequest.java)"
        }
      ],
      "comment": "\n     * The number of slices this task should be divided into. Defaults to 1 meaning the task isn't sliced into subtasks.\n     ",
      "vertexLabel": "Self setSlices()"
    },
    {
      "vertexName": "Method public void onResponse(DiscoveryNode node)  (BlockingClusterStatePublishResponseHandler.java)",
      "children": [
        {
          "name": "Method public void onFailure(DiscoveryNode node, Exception e)  (BlockingClusterStatePublishResponseHandler.java)"
        }
      ],
      "comment": "\n     * Called for each response obtained from non master nodes\n     *\n     * @param node the node that replied to the publish event\n     ",
      "vertexLabel": "void onResponse()"
    },
    {
      "vertexName": "Method public Builder setIndicesOptions(IndicesOptions options)  (BaseAliasesRequestBuilder.java)",
      "comment": "\n     * Specifies what type of requested indices to ignore and wildcard indices expressions.\n     *\n     * For example indices that don't exist.\n     ",
      "vertexLabel": "Builder setIndicesOptions()"
    },
    {
      "vertexName": "Field max  (ExtendedBounds.java)",
      "children": [
        {
          "name": "Field min  (ExtendedBounds.java)"
        }
      ],
      "comment": "\n     * Parsed min value. If this is null and {@linkplain #maxAsStr} isn't then this must be parsed from {@linkplain #maxAsStr}. If this is\n     * null and {@linkplain #maxAsStr} is also null then there is no lower bound.\n     ",
      "vertexLabel": "Field max"
    },
    {
      "vertexName": "Enum SortMode  (SortMode.java)",
      "children": [
        {
          "name": "EnumConstant MEDIAN  (SortMode.java)"
        }
      ],
      "comment": "\n * Elasticsearch supports sorting by array or multi-valued fields. The SortMode option controls what array value is picked\n * for sorting the document it belongs to. The mode option can have the following values:\n * <ul>\n * <li>min - Pick the lowest value.</li>\n * <li>max - Pick the highest value.</li>\n * <li>sum - Use the sum of all values as sort value. Only applicable for number based array fields.</li>\n * <li>avg - Use the average of all values as sort value. Only applicable for number based array fields.</li>\n * <li>median - Use the median of all values as sort value. Only applicable for number based array fields.</li>\n * </ul>\n ",
      "vertexLabel": "Enum SortMode"
    },
    {
      "vertexName": "Method public static long toLongExact(Number n)  (Numbers.java)",
      "children": [
        {
          "name": "Method public static int toIntExact(Number n)  (Numbers.java)"
        }
      ],
      "comment": " Return the long that {@code n} stores, or throws an exception if the\n     *  stored value cannot be converted to a long that stores the exact same\n     *  value. ",
      "vertexLabel": "long toLongExact()"
    },
    {
      "vertexName": "Method public QueryStringQueryBuilder analyzer(String analyzer)  (QueryStringQueryBuilder.java)",
      "comment": "\n     * The optional analyzer used to analyze the query string. Note, if a field has search analyzer\n     * defined for it, then it will be used automatically. Defaults to the smart search analyzer.\n     ",
      "vertexLabel": "QueryStringQueryBuilder analyzer()"
    },
    {
      "vertexName": "Method public IndexRequestBuilder setSource(byte[] source, int offset, int length, XContentType xContentType)  (IndexRequestBuilder.java)",
      "children": [
        {
          "name": "Method public IndexRequest source(byte[] source, int offset, int length, XContentType xContentType)  (IndexRequest.java)"
        }
      ],
      "comment": "\n     * Sets the document to index in bytes form (assumed to be safe to be used from different\n     * threads).\n     *\n     * @param source The source to index\n     * @param offset The offset in the byte array\n     * @param length The length of the data\n     * @param xContentType The type/format of the source\n     ",
      "vertexLabel": "IndexRequestBuilder setSource()"
    },
    {
      "vertexName": "Method native boolean SetProcessWorkingSetSize(Pointer handle, SizeT minSize, SizeT maxSize)  (JNAKernel32Library.java)",
      "comment": "\n     * Sets the minimum and maximum working set sizes for the specified process.\n     *\n     * https://msdn.microsoft.com/en-us/library/windows/desktop/ms686234%28v=vs.85%29.aspx\n     *\n     * @param handle A handle to the process whose working set sizes is to be set.\n     * @param minSize The minimum working set size for the process, in bytes.\n     * @param maxSize The maximum working set size for the process, in bytes.\n     * @return true if the function succeeds.\n     ",
      "vertexLabel": "native boolean SetProcessWorkingSetSize()"
    },
    {
      "vertexName": "Method public OpenIndexRequest waitForActiveShards(ActiveShardCount waitForActiveShards)  (OpenIndexRequest.java)",
      "children": [
        {
          "name": "Method public CreateIndexRequest waitForActiveShards(ActiveShardCount waitForActiveShards)  (CreateIndexRequest.java)"
        }
      ],
      "comment": "\n     * Sets the number of shard copies that should be active for indices opening to return.\n     * Defaults to {@link ActiveShardCount#DEFAULT}, which will wait for one shard copy\n     * (the primary) to become active. Set this value to {@link ActiveShardCount#ALL} to\n     * wait for all shards (primary and all replicas) to be active before returning.\n     * Otherwise, use {@link ActiveShardCount#from(int)} to set this value to any\n     * non-negative integer, up to the number of copies per shard (number of replicas + 1),\n     * to wait for the desired amount of shard copies to become active before returning.\n     * Indices opening will only wait up until the timeout value for the number of shard copies\n     * to be active before returning.  Check {@link OpenIndexResponse#isShardsAcknowledged()} to\n     * determine if the requisite shard copies were all started before returning or timing out.\n     *\n     * @param waitForActiveShards number of active shard copies to wait on\n     ",
      "vertexLabel": "OpenIndexRequest waitForActiveShards()"
    },
    {
      "vertexName": "Method public PutIndexTemplateRequest mapping(String type, XContentBuilder source)  (PutIndexTemplateRequest.java)",
      "children": [
        {
          "name": "Method public CreateIndexRequest mapping(String type, XContentBuilder source)  (CreateIndexRequest.java)"
        }
      ],
      "comment": "\n     * Adds mapping that will be added when the index gets created.\n     *\n     * @param type   The mapping type\n     * @param source The mapping source\n     ",
      "vertexLabel": "PutIndexTemplateRequest mapping()"
    },
    {
      "vertexName": "Method public boolean ensureSynced(Stream<Location> locations) throws IOException  (Translog.java)",
      "children": [
        {
          "name": "Method public boolean ensureSynced(Location location) throws IOException  (Translog.java)"
        }
      ],
      "comment": "\n     * Ensures that all locations in the given stream have been synced / written to the underlying storage.\n     * This method allows for internal optimization to minimize the amount of fsync operations if multiple\n     * locations must be synced.\n     *\n     * @return Returns <code>true</code> iff this call caused an actual sync operation otherwise <code>false</code>\n     ",
      "vertexLabel": "boolean ensureSynced()"
    },
    {
      "vertexName": "Method MembersInjector<T> getMembersInjector(TypeLiteral<T> typeLiteral)  (TypeEncounter.java)",
      "children": [
        {
          "name": "Method MembersInjector<T> getMembersInjector(Class<T> type)  (TypeEncounter.java)"
        }
      ],
      "comment": "\n     * Returns the members injector used to inject dependencies into methods and fields on instances\n     * of the given type {@code T}. The returned members injector will not be valid until the main\n     * injector has been created. The members injector will throw an {@code IllegalStateException}\n     * if you try to use it beforehand.\n     *\n     * @param typeLiteral type to get members injector for\n     ",
      "vertexLabel": "MembersInjector<T> getMembersInjector()"
    },
    {
      "vertexName": "Method public static SortedSet<T> sortedDifference(Set<T> left, Set<T> right)  (Sets.java)",
      "children": [
        {
          "name": "Method public static Set<T> difference(Set<T> left, Set<T> right)  (Sets.java)"
        }
      ],
      "comment": "\n     * The relative complement, or difference, of the specified left and right set, returned as a sorted set. Namely, the resulting set\n     * contains all the elements that are in the left set but not in the right set, and the set is sorted using the natural ordering of\n     * element type. Neither input is mutated by this operation, an entirely new set is returned.\n     *\n     * @param left  the left set\n     * @param right the right set\n     * @param <T>   the type of the elements of the sets\n     * @return the sorted relative complement of the left set with respect to the right set\n     ",
      "vertexLabel": "SortedSet<T> sortedDifference()"
    },
    {
      "vertexName": "Method public MultiGetRequestBuilder setRefresh(boolean refresh)  (MultiGetRequestBuilder.java)",
      "children": [
        {
          "name": "Method public GetRequest refresh(boolean refresh)  (GetRequest.java)"
        }
      ],
      "comment": "\n     * Should a refresh be executed before this get operation causing the operation to\n     * return the latest value. Note, heavy get should not set this to {@code true}. Defaults\n     * to {@code false}.\n     ",
      "vertexLabel": "MultiGetRequestBuilder setRefresh()"
    },
    {
      "vertexName": "Class AllocateStalePrimaryAllocationCommand  (AllocateStalePrimaryAllocationCommand.java)",
      "children": [
        {
          "name": "Class AllocateEmptyPrimaryAllocationCommand  (AllocateEmptyPrimaryAllocationCommand.java)"
        }
      ],
      "comment": "\n * Allocates an unassigned stale primary shard to a specific node. Use with extreme care as this will result in data loss.\n * Allocation deciders are ignored.\n ",
      "vertexLabel": "Class AllocateStalePrimaryAllocationCommand"
    },
    {
      "vertexName": "Class SortedNumericFloatFieldData  (SortedNumericDVIndexFieldData.java)",
      "children": [
        {
          "name": "Class SortedNumericHalfFloatFieldData  (SortedNumericDVIndexFieldData.java)"
        }
      ],
      "comment": "\n     * FieldData implementation for 32-bit float values.\n     * <p>\n     * Order of values within a document is consistent with\n     * {@link Float#compareTo(Float)}, hence the following reversible\n     * transformation is applied at both index and search:\n     * {@code bits ^ (bits >> 31) & 0x7fffffff}\n     * <p>\n     * Although the API is multi-valued, most codecs in Lucene specialize\n     * for the case where documents have at most one value. In this case\n     * {@link FieldData#unwrapSingleton(SortedNumericDoubleValues)} will return\n     * the underlying single-valued NumericDoubleValues representation.\n     ",
      "vertexLabel": "Class SortedNumericFloatFieldData"
    },
    {
      "vertexName": "Method public void execute(Interruptable interruptable)  (CancellableThreads.java)",
      "comment": "\n     * run the Interruptable, capturing the executing thread. Concurrent calls to {@link #cancel(String)} will interrupt this thread\n     * causing the call to prematurely return.\n     *\n     * @param interruptable code to run\n     ",
      "vertexLabel": "void execute()"
    },
    {
      "vertexName": "Method public T getFieldValue(TemplateScript.Factory pathTemplate, Class<T> clazz)  (IngestDocument.java)",
      "children": [
        {
          "name": "Method public T getFieldValue(String path, Class<T> clazz)  (IngestDocument.java)"
        }
      ],
      "comment": "\n     * Returns the value contained in the document with the provided templated path\n     * @param pathTemplate The path within the document in dot-notation\n     * @param clazz The expected class fo the field value\n     * @return the value fro the provided path if existing, null otherwise\n     * @throws IllegalArgumentException if the pathTemplate is null, empty, invalid, if the field doesn't exist,\n     * or if the field that is found at the provided path is not of the expected type.\n     ",
      "vertexLabel": "T getFieldValue()"
    },
    {
      "vertexName": "Method public static FunctionScoreQueryBuilder functionScoreQuery(QueryBuilder queryBuilder, ScoreFunctionBuilder function)  (QueryBuilders.java)",
      "children": [
        {
          "name": "Method public static FunctionScoreQueryBuilder functionScoreQuery(ScoreFunctionBuilder function)  (QueryBuilders.java)"
        }
      ],
      "comment": "\n     * A query that allows to define a custom scoring function.\n     *\n     * @param queryBuilder The query to custom score\n     * @param function     The function builder used to custom score\n     ",
      "vertexLabel": "FunctionScoreQueryBuilder functionScoreQuery()"
    },
    {
      "vertexName": "Method public void withBackoff(BiConsumer<BulkRequest, ActionListener<BulkResponse>> consumer, BulkRequest bulkRequest, ActionListener<BulkResponse> listener)  (Retry.java)",
      "children": [
        {
          "name": "Method public PlainActionFuture<BulkResponse> withBackoff(BiConsumer<BulkRequest, ActionListener<BulkResponse>> consumer, BulkRequest bulkRequest)  (Retry.java)"
        }
      ],
      "comment": "\n     * Invokes #accept(BulkRequest, ActionListener). Backs off on the provided exception and delegates results to the\n     * provided listener. Retries will be scheduled using the class's thread pool.\n     * @param consumer The consumer to which apply the request and listener\n     * @param bulkRequest The bulk request that should be executed.\n     * @param listener A listener that is invoked when the bulk request finishes or completes with an exception. The listener is not\n     ",
      "vertexLabel": "void withBackoff()"
    },
    {
      "vertexName": "Method ActionFuture<IndicesShardStoresResponse> shardStores(IndicesShardStoresRequest request)  (IndicesAdminClient.java)",
      "comment": "\n     * The shard stores info of one or more indices.\n     *\n     * @param request The indices shard stores request\n     * @return The result future\n     * @see Requests#indicesShardStoresRequest(String...)\n     ",
      "vertexLabel": "ActionFuture<IndicesShardStoresResponse> shardStores()"
    },
    {
      "vertexName": "Method public static TermQueryBuilder termQuery(String name, double value)  (QueryBuilders.java)",
      "children": [
        {
          "name": "Method public static TermQueryBuilder termQuery(String name, String value)  (QueryBuilders.java)"
        }
      ],
      "comment": "\n     * A Query that matches documents containing a term.\n     *\n     * @param name  The name of the field\n     * @param value The value of the term\n     ",
      "vertexLabel": "TermQueryBuilder termQuery()"
    },
    {
      "vertexName": "Method ActionFuture<RolloverResponse> rolloversIndex(RolloverRequest request)  (IndicesAdminClient.java)",
      "children": [
        {
          "name": "Method RolloverRequestBuilder prepareRolloverIndex(String sourceAlias)  (IndicesAdminClient.java)"
        }
      ],
      "comment": "\n     * Swaps the index pointed to by an alias given all provided conditions are satisfied\n     ",
      "vertexLabel": "ActionFuture<RolloverResponse> rolloversIndex()"
    },
    {
      "vertexName": "Method public Builder put(String key, Class clazz)  (Settings.java)",
      "children": [
        {
          "name": "Method public Builder put(String key, String value)  (Settings.java)"
        }
      ],
      "comment": "\n         * Sets a setting with the provided setting key and class as value.\n         *\n         * @param key   The setting key\n         * @param clazz The setting class value\n         * @return The builder\n         ",
      "vertexLabel": "Builder put()"
    },
    {
      "vertexName": "Method public RatioValue getAsRatio(String setting, String defaultValue) throws SettingsException  (Settings.java)",
      "children": [
        {
          "name": "Method public Boolean getAsBoolean(String setting, Boolean defaultValue)  (Settings.java)"
        }
      ],
      "comment": "\n     * Returns the setting value (as a RatioValue) associated with the setting key. Provided values can\n     * either be a percentage value (eg. 23%), or expressed as a floating point number (eg. 0.23). If\n     * it does not exist, parses the default value provided.\n     ",
      "vertexLabel": "RatioValue getAsRatio()"
    },
    {
      "vertexName": "Method Provider<T> getProvider(Key<T> key)  (Injector.java)",
      "children": [
        {
          "name": "Method Provider<T> getProvider(Key<T> key)  (TypeEncounter.java)"
        },
        {
          "name": "Method Provider<T> getProvider(Class<T> type)  (Injector.java)"
        }
      ],
      "comment": "\n     * Returns the provider used to obtain instances for the given injection key. When feasible, avoid\n     * using this method, in favor of having Guice inject your dependencies ahead of time.\n     *\n     * @throws ConfigurationException if this injector cannot find or create the provider.\n     * @see Binder#getProvider(Key) for an alternative that offers up front error detection\n     ",
      "vertexLabel": "Provider<T> getProvider()"
    },
    {
      "vertexName": "Method protected TypeLiteral()  (TypeLiteral.java)",
      "comment": "\n     * Constructs a new type literal. Derives represented class from type\n     * parameter.\n     * <p>\n     * Clients create an empty anonymous subclass. Doing so embeds the type\n     * parameter in the anonymous class's type hierarchy so we can reconstitute it\n     * at runtime despite erasure.\n     ",
      "vertexLabel": "TypeLiteral()"
    },
    {
      "vertexName": "Method public TermsAggregationBuilder shardMinDocCount(long shardMinDocCount)  (TermsAggregationBuilder.java)",
      "comment": "\n     * Set the minimum document count terms should have on the shard in order to\n     * appear in the response.\n     ",
      "vertexLabel": "TermsAggregationBuilder shardMinDocCount()"
    },
    {
      "vertexName": "Class TermVectorsRequestBuilder  (TermVectorsRequestBuilder.java)",
      "children": [
        {
          "name": "Class TermVectorsRequest  (TermVectorsRequest.java)"
        }
      ],
      "comment": "\n * The builder class for a term vector request.\n * Returns the term vector (doc frequency, positions, offsets) for a document.\n * <p>\n * Note, the {@code index}, {@code type} and {@code id} are\n * required.\n ",
      "vertexLabel": "Class TermVectorsRequestBuilder"
    },
    {
      "vertexName": "Method public IndexRequestBuilder setSource(Map<String, ?> source, XContentType contentType)  (IndexRequestBuilder.java)",
      "children": [
        {
          "name": "Method public IndexRequest source(Map<String, ?> source, XContentType contentType) throws ElasticsearchGenerationException  (IndexRequest.java)"
        }
      ],
      "comment": "\n     * Index the Map as the provided content type.\n     *\n     * @param source The map to index\n     ",
      "vertexLabel": "IndexRequestBuilder setSource()"
    },
    {
      "vertexName": "Method public Builder put(String key, Enum<?> enumValue)  (Settings.java)",
      "children": [
        {
          "name": "Method public Builder put(String key, Level level)  (Settings.java)"
        }
      ],
      "comment": "\n         * Sets an enum setting with the provided setting key and enum instance.\n         *\n         * @param key  The setting key\n         * @param enumValue The setting value\n         * @return The builder\n         ",
      "vertexLabel": "Builder put()"
    },
    {
      "vertexName": "Method protected double parseDoubleParam(@Nullable Map<String, Object> settings, String name, double defaultValue) throws ParseException  (MovAvgModel.java)",
      "children": [
        {
          "name": "Method protected int parseIntegerParam(@Nullable Map<String, Object> settings, String name, int defaultValue) throws ParseException  (MovAvgModel.java)"
        }
      ],
      "comment": "\n         * Extracts a 0-1 inclusive double from the settings map, otherwise throws an exception\n         *\n         * @param settings      Map of settings provided to this model\n         * @param name          Name of parameter we are attempting to extract\n         * @param defaultValue  Default value to be used if value does not exist in map\n         * @return Double value extracted from settings map\n         ",
      "vertexLabel": "double parseDoubleParam()"
    },
    {
      "vertexName": "Method public abstract double getScore(long subsetFreq, long subsetSize, long supersetFreq, long supersetSize)  (SignificanceHeuristic.java)",
      "comment": "\n     * @param subsetFreq   The frequency of the term in the selected sample\n     * @param subsetSize   The size of the selected sample (typically number of docs)\n     * @param supersetFreq The frequency of the term in the superset from which the sample was taken\n     * @param supersetSize The size of the superset from which the sample was taken  (typically number of docs)\n     * @return a \"significance\" score\n     ",
      "vertexLabel": "abstract double getScore()"
    },
    {
      "vertexName": "Method public MultiSearchRequestBuilder setIndicesOptions(IndicesOptions indicesOptions)  (MultiSearchRequestBuilder.java)",
      "children": [
        {
          "name": "Method public DeleteIndexRequestBuilder setIndicesOptions(IndicesOptions options)  (DeleteIndexRequestBuilder.java)"
        }
      ],
      "comment": "\n     * Specifies what type of requested indices to ignore and how to deal with wildcard indices expressions.\n     * For example indices that don't exist.\n     * <p>\n     * Invoke this method before invoking {@link #add(SearchRequestBuilder)}.\n     ",
      "vertexLabel": "MultiSearchRequestBuilder setIndicesOptions()"
    },
    {
      "vertexName": "Method public static MoreLikeThisQueryBuilder moreLikeThisQuery(Item[] likeItems)  (QueryBuilders.java)",
      "children": [
        {
          "name": "Method public static MoreLikeThisQueryBuilder moreLikeThisQuery(String[] likeTexts)  (QueryBuilders.java)"
        }
      ],
      "comment": "\n     * A more like this query that finds documents that are \"like\" the provided documents\n     * which is checked against the \"_all\" field.\n     * @param likeItems the documents to use when generating the 'More Like This' query.\n     ",
      "vertexLabel": "MoreLikeThisQueryBuilder moreLikeThisQuery()"
    },
    {
      "vertexName": "Method Cancellable scheduleWithFixedDelay(Runnable command, TimeValue interval, String executor)  (Scheduler.java)",
      "comment": "\n     * Schedules a periodic action that runs on scheduler thread. Do not run blocking calls on the scheduler thread. Subclasses may allow\n     * to execute on a different executor, in which case blocking calls are allowed.\n     *\n     * @param command the action to take\n     * @param interval the delay interval\n     * @param executor the name of the executor that has to execute this task. Ignored in the default implementation but can be used\n     *                 by subclasses that support multiple executors.\n     * @return a {@link Cancellable} that can be used to cancel the subsequent runs of the command. If the command is running, it will\n     *         not be interrupted.\n     ",
      "vertexLabel": "Cancellable scheduleWithFixedDelay()"
    },
    {
      "vertexName": "Class ScriptException  (ScriptException.java)",
      "comment": "\n * Exception from a scripting engine.\n * <p>\n * A ScriptException has the following components:\n * <ul>\n *   <li>{@code message}: A short and simple summary of what happened, such as \"compile error\".\n *   <li>{@code cause}: The underlying cause of the exception.\n *   <li>{@code scriptStack}: An implementation-specific \"stacktrace\" for the error in the script.\n *   <li>{@code script}: Identifier for which script failed.\n *   <li>{@code lang}: Scripting engine language, such as \"painless\"\n * </ul>\n ",
      "vertexLabel": "Class ScriptException"
    },
    {
      "vertexName": "Method public abstract void waitForOpsToComplete(long seqNo) throws InterruptedException  (Engine.java)",
      "comment": "\n     * Waits for all operations up to the provided sequence number to complete.\n     *\n     * @param seqNo the sequence number that the checkpoint must advance to before this method returns\n     * @throws InterruptedException if the thread was interrupted while blocking on the condition\n     ",
      "vertexLabel": "abstract void waitForOpsToComplete()"
    },
    {
      "vertexName": "Method public boolean isSame(FileInfo fileInfo)  (BlobStoreIndexShardSnapshot.java)",
      "children": [
        {
          "name": "Method public boolean isSame(StoreFileMetaData md)  (BlobStoreIndexShardSnapshot.java)"
        }
      ],
      "comment": "\n         * Checks if a file in a store is the same file\n         *\n         * @param fileInfo file in a store\n         * @return true if file in a store this this file have the same checksum and length\n         ",
      "vertexLabel": "boolean isSame()"
    },
    {
      "vertexName": "Method public boolean existsOrFallbackExists(final Settings settings)  (Setting.java)",
      "children": [
        {
          "name": "Method public boolean exists(final Settings settings)  (Setting.java)"
        }
      ],
      "comment": "\n     * Returns true if and only if this setting including fallback settings is present in the given settings instance.\n     *\n     * @param settings the settings\n     * @return true if the setting including fallback settings is present in the given settings instance, otherwise false\n     ",
      "vertexLabel": "boolean existsOrFallbackExists()"
    },
    {
      "vertexName": "Method public Weight getWeight()  (FilterAggregatorFactory.java)",
      "comment": "\n     * Returns the {@link Weight} for this filter aggregation, creating it if\n     * necessary. This is done lazily so that the {@link Weight} is only created\n     * if the aggregation collects documents reducing the overhead of the\n     * aggregation in the case where no documents are collected.\n     * \n     * Note that as aggregations are initialsed and executed in a serial manner,\n     * no concurrency considerations are necessary here.\n     ",
      "vertexLabel": "Weight getWeight()"
    },
    {
      "vertexName": "Method public double compression()  (PercentilesAggregationBuilder.java)",
      "children": [
        {
          "name": "Method public PercentileRanksAggregationBuilder compression(double compression)  (PercentileRanksAggregationBuilder.java)"
        }
      ],
      "comment": "\n     * Expert: get the compression. Higher values improve accuracy but also\n     * memory usage. Only relevant when using {@link PercentilesMethod#TDIGEST}.\n     ",
      "vertexLabel": "double compression()"
    },
    {
      "vertexName": "Method public Builder precision(String precision)  (GeoContextMapping.java)",
      "children": [
        {
          "name": "Method public Builder precision(double meters)  (GeoContextMapping.java)"
        }
      ],
      "comment": "\n         * Set the precision use o make suggestions\n         *\n         * @param precision\n         *            precision as distance with {@link DistanceUnit}. Default:\n         *            meters\n         * @return this\n         ",
      "vertexLabel": "Builder precision()"
    },
    {
      "vertexName": "Method public FunctionScoreQueryBuilder(QueryBuilder query, FilterFunctionBuilder[] filterFunctionBuilders)  (FunctionScoreQueryBuilder.java)",
      "children": [
        {
          "name": "Method public FunctionScoreQueryBuilder(FilterFunctionBuilder[] filterFunctionBuilders)  (FunctionScoreQueryBuilder.java)"
        }
      ],
      "comment": "\n     * Creates a function_score query that executes the provided filters and functions on documents that match a query.\n     *\n     * @param query the query that defines which documents the function_score query will be executed on.\n     * @param filterFunctionBuilders the filters and functions\n     ",
      "vertexLabel": "FunctionScoreQueryBuilder()"
    },
    {
      "vertexName": "Method void afterLoad(TermsEnum termsEnum, long actualUsed)  (AbstractIndexFieldData.java)",
      "comment": "\n         * Possibly adjust a circuit breaker after field data has been loaded,\n         * now that the actual amount of memory used by the field data is known\n         *\n         * @param termsEnum  terms that were loaded\n         * @param actualUsed actual field data memory usage\n         ",
      "vertexLabel": "void afterLoad()"
    },
    {
      "vertexName": "Method boolean isMergeResults()  (FieldCapabilitiesRequest.java)",
      "comment": "\n     * Returns <code>true</code> iff the results should be merged.\n     *\n     * Note that when using the high-level REST client, results are always merged (this flag is always considered 'true').\n     ",
      "vertexLabel": "boolean isMergeResults()"
    },
    {
      "vertexName": "Method void removeIndex(Index index, IndexRemovalReason reason, String extraInfo)  (IndicesClusterStateService.java)",
      "children": [
        {
          "name": "EnumConstant NO_LONGER_ASSIGNED  (IndicesClusterStateService.java)"
        }
      ],
      "comment": "\n         * Removes the given index from this service and releases all associated resources. Persistent parts of the index\n         * like the shards files, state and transaction logs are kept around in the case of a disaster recovery.\n         * @param index the index to remove\n         * @param reason the reason to remove the index\n         * @param extraInfo extra information that will be used for logging and reporting\n         ",
      "vertexLabel": "void removeIndex()"
    },
    {
      "vertexName": "Method public synchronized int totalOperationsOnStart()  (RecoveryState.java)",
      "comment": "\n         * returns the total number of translog operations to recovered, on the start of the recovery. Unlike {@link #totalOperations}\n         * this does change during recovery.\n         * <p>\n         * A value of -1 ({@link RecoveryState.Translog#UNKNOWN} is return if this is unknown (typically a gateway recovery)\n         ",
      "vertexLabel": "synchronized int totalOperationsOnStart()"
    },
    {
      "vertexName": "Method public ScriptSortBuilder setNestedFilter(QueryBuilder nestedFilter)  (ScriptSortBuilder.java)",
      "children": [
        {
          "name": "Method public FieldSortBuilder setNestedFilter(QueryBuilder nestedFilter)  (FieldSortBuilder.java)"
        }
      ],
      "comment": "\n     * Sets the nested filter that the nested objects should match with in order to be taken into account\n     * for sorting.\n     *\n     * @deprecated set nested sort with {@link #setNestedSort(NestedSortBuilder)} and retrieve with {@link #getNestedSort()}\n     ",
      "vertexLabel": "ScriptSortBuilder setNestedFilter()"
    },
    {
      "vertexName": "Method protected ValuesSourceAggregationBuilder(StreamInput in, ValuesSourceType valuesSourceType, ValueType targetValueType) throws IOException  (ValuesSourceAggregationBuilder.java)",
      "comment": "\n     * Read an aggregation from a stream that does not serialize its targetValueType. This should be used by most subclasses.\n     ",
      "vertexLabel": "ValuesSourceAggregationBuilder()"
    },
    {
      "vertexName": "Method static Object maybeConvertToBytesRef(Object obj)  (AbstractQueryBuilder.java)",
      "comment": "\n     * This helper method checks if the object passed in is a string or {@link CharBuffer},\n     * if so it converts it to a {@link BytesRef}.\n     * @param obj the input object\n     * @return the same input object or a {@link BytesRef} representation if input was of type string\n     ",
      "vertexLabel": "Object maybeConvertToBytesRef()"
    },
    {
      "vertexName": "Method public GeoDistanceSortBuilder sortMode(SortMode sortMode)  (GeoDistanceSortBuilder.java)",
      "children": [
        {
          "name": "Method public SortMode sortMode()  (GeoDistanceSortBuilder.java)"
        }
      ],
      "comment": "\n     * Defines which distance to use for sorting in the case a document contains multiple geo points.\n     * Possible values: min and max\n     ",
      "vertexLabel": "GeoDistanceSortBuilder sortMode()"
    },
    {
      "vertexName": "Method public MultiMatchQueryBuilder analyzer(String analyzer)  (MultiMatchQueryBuilder.java)",
      "children": [
        {
          "name": "Method public MatchPhrasePrefixQueryBuilder analyzer(String analyzer)  (MatchPhrasePrefixQueryBuilder.java)"
        }
      ],
      "comment": "\n     * Explicitly set the analyzer to use. Defaults to use explicit mapping config for the field, or, if not\n     * set, the default search analyzer.\n     ",
      "vertexLabel": "MultiMatchQueryBuilder analyzer()"
    },
    {
      "vertexName": "Method public void addIndexEventListener(IndexEventListener listener)  (IndexModule.java)",
      "comment": "\n     * Adds an {@link IndexEventListener} for this index. All listeners added here\n     * are maintained for the entire index lifecycle on this node. Once an index is closed or deleted these\n     * listeners go out of scope.\n     * <p>\n     * Note: an index might be created on a node multiple times. For instance if the last shard from an index is\n     * relocated to another node the internal representation will be destroyed which includes the registered listeners.\n     * Once the node holds at least one shard of an index all modules are reloaded and listeners are registered again.\n     * Listeners can't be unregistered they will stay alive for the entire time the index is allocated on a node.\n     * </p>\n     ",
      "vertexLabel": "void addIndexEventListener()"
    },
    {
      "vertexName": "EnumConstant FAILURE  (IndicesClusterStateService.java)",
      "children": [
        {
          "name": "EnumConstant DELETED  (IndicesClusterStateService.java)"
        }
      ],
      "comment": "\n             * Something around index management has failed and the index should be removed.\n             * Persistent parts of the index like the shards files, state and transaction logs are kept around in the\n             * case of a disaster recovery.\n             ",
      "vertexLabel": "EnumConstant FAILURE"
    },
    {
      "vertexName": "Class IndicesStatsRequest  (IndicesStatsRequest.java)",
      "comment": "\n * A request to get indices level stats. Allow to enable different stats to be returned.\n * <p>\n * By default, all statistics are enabled.\n * <p>\n * All the stats to be returned can be cleared using {@link #clear()}, at which point, specific\n * stats can be enabled.\n ",
      "vertexLabel": "Class IndicesStatsRequest"
    },
    {
      "vertexName": "Method public ByteSizeValue getAsBytesSize(String setting, ByteSizeValue defaultValue) throws SettingsException  (Settings.java)",
      "children": [
        {
          "name": "Method public Integer getAsInt(String setting, Integer defaultValue)  (Settings.java)"
        }
      ],
      "comment": "\n     * Returns the setting value (as size) associated with the setting key. If it does not exists,\n     * returns the default value provided.\n     ",
      "vertexLabel": "ByteSizeValue getAsBytesSize()"
    },
    {
      "vertexName": "Method public HoltLinearModelBuilder alpha(double alpha)  (HoltLinearModel.java)",
      "children": [
        {
          "name": "Method public EWMAModelBuilder alpha(double alpha)  (EwmaModel.java)"
        }
      ],
      "comment": "\n         * Alpha controls the smoothing of the data.  Alpha = 1 retains no memory of past values\n         * (e.g. a random walk), while alpha = 0 retains infinite memory of past values (e.g.\n         * the series mean).  Useful values are somewhere in between.  Defaults to 0.5.\n         *\n         * @param alpha A double between 0-1 inclusive, controls data smoothing\n         *\n         * @return The builder to continue chaining\n         ",
      "vertexLabel": "HoltLinearModelBuilder alpha()"
    },
    {
      "vertexName": "Class GeoContextMapping  (GeoContextMapping.java)",
      "children": [
        {
          "name": "Class CategoryContextMapping  (CategoryContextMapping.java)"
        }
      ],
      "comment": "\n * A {@link ContextMapping} that uses a geo location/area as a\n * criteria.\n * The suggestions can be boosted and/or filtered depending on\n * whether it falls within an area, represented by a query geo hash\n * with a specified precision\n *\n * {@link GeoQueryContext} defines the options for constructing\n * a unit of query context for this context type\n ",
      "vertexLabel": "Class GeoContextMapping"
    },
    {
      "vertexName": "Method public CreateSnapshotRequest includeGlobalState(boolean includeGlobalState)  (CreateSnapshotRequest.java)",
      "children": [
        {
          "name": "Method public boolean includeGlobalState()  (SnapshotsService.java)"
        }
      ],
      "comment": "\n     * Set to true if global state should be stored as part of the snapshot\n     *\n     * @param includeGlobalState true if global state should be stored\n     * @return this request\n     ",
      "vertexLabel": "CreateSnapshotRequest includeGlobalState()"
    },
    {
      "vertexName": "Method public CloseIndexRequest indices(String... indices)  (CloseIndexRequest.java)",
      "comment": "\n     * Sets the indices to be closed\n     * @param indices the indices to be closed\n     * @return the request itself\n     ",
      "vertexLabel": "CloseIndexRequest indices()"
    },
    {
      "vertexName": "Method protected CountDownLatch updateIndicesStats(final ActionListener<IndicesStatsResponse> listener)  (InternalClusterInfoService.java)",
      "children": [
        {
          "name": "Method protected CountDownLatch updateNodeStats(final ActionListener<NodesStatsResponse> listener)  (InternalClusterInfoService.java)"
        }
      ],
      "comment": "\n     * Retrieve the latest indices stats, calling the listener when complete\n     * @return a latch that can be used to wait for the indices stats to complete if desired\n     ",
      "vertexLabel": "CountDownLatch updateIndicesStats()"
    },
    {
      "vertexName": "Method public static MoreLikeThisQueryBuilder moreLikeThisQuery(String[] fields, String[] likeTexts, Item[] likeItems)  (QueryBuilders.java)",
      "children": [
        {
          "name": "Method public static MoreLikeThisQueryBuilder moreLikeThisQuery(String[] likeTexts, Item[] likeItems)  (QueryBuilders.java)"
        },
        {
          "name": "Method public String[] getFieldNames()  (XMoreLikeThis.java)"
        }
      ],
      "comment": "\n     * A more like this query that finds documents that are \"like\" the provided texts or documents\n     * which is checked against the fields the query is constructed with.\n     *\n     * @param fields the field names that will be used when generating the 'More Like This' query.\n     * @param likeTexts the text to use when generating the 'More Like This' query.\n     * @param likeItems the documents to use when generating the 'More Like This' query.\n     ",
      "vertexLabel": "MoreLikeThisQueryBuilder moreLikeThisQuery()"
    },
    {
      "vertexName": "Method public boolean enoughShardsActive(final int activeShardCount)  (ActiveShardCount.java)",
      "children": [
        {
          "name": "Method public boolean enoughShardsActive(final ClusterState clusterState, final String... indices)  (ActiveShardCount.java)"
        }
      ],
      "comment": "\n     * Returns true iff the given number of active shards is enough to meet\n     * the required shard count represented by this instance.  This method\n     * should only be invoked with {@link ActiveShardCount} objects created\n     * from {@link #from(int)}, or {@link #NONE} or {@link #ONE}.\n     ",
      "vertexLabel": "boolean enoughShardsActive()"
    },
    {
      "vertexName": "Method public ImmutableOpenMap<String, Settings> getIndexToSettings()  (GetSettingsResponse.java)",
      "comment": "\n     * Returns a map of index name to {@link Settings} object.  The returned {@link Settings}\n     * objects contain only those settings explicitly set on a given index.  Any settings\n     * taking effect as defaults must be accessed via {@link #getIndexToDefaultSettings()}.\n     ",
      "vertexLabel": "ImmutableOpenMap<String, Settings> getIndexToSettings()"
    },
    {
      "vertexName": "Method public static FunctionScoreQueryBuilder functionScoreQuery(ScoreFunctionBuilder function)  (QueryBuilders.java)",
      "comment": "\n     * A query that allows to define a custom scoring function.\n     *\n     * @param function The function builder used to custom score\n     ",
      "vertexLabel": "FunctionScoreQueryBuilder functionScoreQuery()"
    },
    {
      "vertexName": "Method private static void addSocketPermissionForTransportProfiles(final Permissions policy, final Settings settings)  (Security.java)",
      "children": [
        {
          "name": "Method private static void addSocketPermissionForTransport(final Permissions policy, final Settings settings)  (Security.java)"
        }
      ],
      "comment": "\n     * Add dynamic {@link SocketPermission} based on transport settings. This method will first check if there is a port range specified in\n     * the transport profile specified by {@code profileSettings} and will fall back to {@code settings}.\n     *\n     * @param policy          the {@link Permissions} instance to apply the dynamic {@link SocketPermission}s to\n     * @param settings        the {@link Settings} instance to read the transport settings from\n     ",
      "vertexLabel": "void addSocketPermissionForTransportProfiles()"
    },
    {
      "vertexName": "Class SortedNumericDoubleFieldData  (SortedNumericDVIndexFieldData.java)",
      "children": [
        {
          "name": "Class SortedNumericHalfFloatFieldData  (SortedNumericDVIndexFieldData.java)"
        }
      ],
      "comment": "\n     * FieldData implementation for 64-bit double values.\n     * <p>\n     * Order of values within a document is consistent with\n     * {@link Double#compareTo(Double)}, hence the following reversible\n     * transformation is applied at both index and search:\n     * {@code bits ^ (bits >> 63) & 0x7fffffffffffffffL}\n     * <p>\n     * Although the API is multi-valued, most codecs in Lucene specialize\n     * for the case where documents have at most one value. In this case\n     * {@link FieldData#unwrapSingleton(SortedNumericDoubleValues)} will return\n     * the underlying single-valued NumericDoubleValues representation.\n     ",
      "vertexLabel": "Class SortedNumericDoubleFieldData"
    },
    {
      "vertexName": "Method CompoundOrder(List<BucketOrder> compoundOrder)  (InternalOrder.java)",
      "comment": "\n         * Create a new ordering strategy to sort by multiple criteria. A tie-breaker may be added to avoid\n         * non-deterministic ordering.\n         *\n         * @param compoundOrder a list of {@link BucketOrder}s to sort on, in order of priority.\n         ",
      "vertexLabel": "CompoundOrder()"
    },
    {
      "vertexName": "Method void termVector(TermVectorsRequest request, ActionListener<TermVectorsResponse> listener)  (Client.java)",
      "children": [
        {
          "name": "Method void termVectors(TermVectorsRequest request, ActionListener<TermVectorsResponse> listener)  (Client.java)"
        }
      ],
      "comment": "\n     * An action that returns the term vectors for a specific document.\n     *\n     * @param request The term vector request\n     ",
      "vertexLabel": "void termVector()"
    },
    {
      "vertexName": "Method private void removeSnapshotFromClusterState(final Snapshot snapshot, final SnapshotInfo snapshotInfo, final Exception failure, @Nullable CleanupAfterErrorListener listener)  (SnapshotsService.java)",
      "children": [
        {
          "name": "Method private void removeSnapshotFromClusterState(final Snapshot snapshot, final SnapshotInfo snapshotInfo, final Exception e)  (SnapshotsService.java)"
        }
      ],
      "comment": "\n     * Removes record of running snapshot from cluster state and notifies the listener when this action is complete\n     *  @param snapshot   snapshot\n     * @param failure          exception if snapshot failed\n     * @param listener   listener to notify when snapshot information is removed from the cluster state\n     ",
      "vertexLabel": "void removeSnapshotFromClusterState()"
    },
    {
      "vertexName": "EnumConstant NOT_ACCEPTABLE  (RestStatus.java)",
      "children": [
        {
          "name": "EnumConstant MULTIPLE_CHOICES  (RestStatus.java)"
        }
      ],
      "comment": "\n     * The resource identified by the request is only capable of generating response entities which have content\n     * characteristics not acceptable according to the accept headers sent in the request.\n     * <p>\n     * Unless it was a HEAD request, the response SHOULD include an entity containing a list of available entity\n     * characteristics and location(s) from which the user or user agent can choose the one most appropriate.\n     * The entity format is specified by the media type given in the Content-Type header field. Depending upon the\n     * format and the capabilities of the user agent, selection of the most appropriate choice MAY be performed\n     * automatically. However, this specification does not define any standard for such automatic selection.\n     * <p>\n     * Note: HTTP/1.1 servers are allowed to return responses which are not acceptable according to the accept\n     * headers sent in the request. In some cases, this may even be preferable to sending a 406 response. User\n     * agents are encouraged to inspect the headers of an incoming response to determine if it is acceptable.\n     * <p>\n     * If the response could be unacceptable, a user agent SHOULD temporarily stop receipt of more data and query\n     * the user for a decision on further actions.\n     ",
      "vertexLabel": "EnumConstant NOT_ACCEPTABLE"
    },
    {
      "vertexName": "Method void cancelTasks(CancelTasksRequest request, ActionListener<CancelTasksResponse> listener)  (ClusterAdminClient.java)",
      "children": [
        {
          "name": "Method void listTasks(ListTasksRequest request, ActionListener<ListTasksResponse> listener)  (ClusterAdminClient.java)"
        }
      ],
      "comment": "\n     * Cancel active tasks\n     *\n     * @param request  The nodes tasks request\n     * @param listener A listener to be notified with a result\n     * @see org.elasticsearch.client.Requests#cancelTasksRequest()\n     ",
      "vertexLabel": "void cancelTasks()"
    },
    {
      "vertexName": "Method public static TermQueryBuilder termQuery(String name, boolean value)  (QueryBuilders.java)",
      "children": [
        {
          "name": "Method public static TermQueryBuilder termQuery(String name, String value)  (QueryBuilders.java)"
        }
      ],
      "comment": "\n     * A Query that matches documents containing a term.\n     *\n     * @param name  The name of the field\n     * @param value The value of the term\n     ",
      "vertexLabel": "TermQueryBuilder termQuery()"
    },
    {
      "vertexName": "Method public TimeValue getTotalStoppedTime()  (MergeStats.java)",
      "children": [
        {
          "name": "Method public long getTotalStoppedTimeInMillis()  (MergeStats.java)"
        }
      ],
      "comment": "\n     * The total time large merges were stopped so smaller merges could finish.\n     ",
      "vertexLabel": "TimeValue getTotalStoppedTime()"
    },
    {
      "vertexName": "Method public static void writeOrder(BucketOrder order, StreamOutput out) throws IOException  (InternalOrder.java)",
      "comment": "\n         * Write a {@link BucketOrder} to a {@link StreamOutput}.\n         *\n         * @param order order to write to the stream.\n         * @param out   stream to write the order to.\n         * @throws IOException on error writing to the stream.\n         ",
      "vertexLabel": "void writeOrder()"
    },
    {
      "vertexName": "Method public ClusterUpdateSettingsRequest persistentSettings(String source, XContentType xContentType)  (ClusterUpdateSettingsRequest.java)",
      "comment": "\n     * Sets the source containing the persistent settings to be updated. They will get applied cross restarts\n     ",
      "vertexLabel": "ClusterUpdateSettingsRequest persistentSettings()"
    },
    {
      "vertexName": "Method public Searcher acquireSearcher(String source, SearcherScope scope) throws EngineException  (Engine.java)",
      "children": [
        {
          "name": "Method public final Searcher acquireSearcher(String source) throws EngineException  (Engine.java)"
        }
      ],
      "comment": "\n     * Returns a new searcher instance. The consumer of this\n     * API is responsible for releasing the returned searcher in a\n     * safe manner, preferably in a try/finally block.\n     *\n     * @param source the source API or routing that triggers this searcher acquire\n     * @param scope the scope of this searcher ie. if the searcher will be used for get or search purposes\n     *\n     * @see Searcher#close()\n     ",
      "vertexLabel": "Searcher acquireSearcher()"
    },
    {
      "vertexName": "Method public boolean routingTableChanged()  (ClusterChangedEvent.java)",
      "children": [
        {
          "name": "Method public boolean metaDataChanged()  (ClusterChangedEvent.java)"
        }
      ],
      "comment": "\n     * Returns <code>true</code> iff the routing tables (for all indices) have\n     * changed between the previous cluster state and the current cluster state.\n     * Note that this is an object reference equality test, not an equals test.\n     ",
      "vertexLabel": "boolean routingTableChanged()"
    },
    {
      "vertexName": "Method public GeoDistanceAggregationBuilder addUnboundedTo(String key, double to)  (GeoDistanceAggregationBuilder.java)",
      "children": [
        {
          "name": "Method public DateRangeAggregationBuilder addUnboundedTo(String key, String to)  (DateRangeAggregationBuilder.java)"
        }
      ],
      "comment": "\n     * Add a new range with no lower bound.\n     *\n     * @param key\n     *            the key to use for this range in the response\n     * @param to\n     *            the upper bound on the distances, exclusive\n     ",
      "vertexLabel": "GeoDistanceAggregationBuilder addUnboundedTo()"
    },
    {
      "vertexName": "Method public final void onModule(ClusterModule module)  (Plugin.java)",
      "children": [
        {
          "name": "Method public final void onModule(NetworkModule module)  (Plugin.java)"
        }
      ],
      "comment": "\n     * Old-style cluster extension point. {@code @Deprecated} and {@code final} to act as a signpost for plugin authors upgrading\n     * from 2.x.\n     *\n     * @deprecated implement {@link ClusterPlugin} instead\n     ",
      "vertexLabel": "final void onModule()"
    },
    {
      "vertexName": "Method public TermVectorsRequest preference(String preference)  (TermVectorsRequest.java)",
      "children": [
        {
          "name": "Method public MultiGetRequest preference(String preference)  (MultiGetRequest.java)"
        }
      ],
      "comment": "\n     * Sets the preference to execute the search. Defaults to randomize across\n     * shards. Can be set to {@code _local} to prefer local shards or a custom value,\n     * which guarantees that the same order will be used across different\n     * requests.\n     ",
      "vertexLabel": "TermVectorsRequest preference()"
    },
    {
      "vertexName": "Class LoggingAwareCommand  (LoggingAwareCommand.java)",
      "comment": "\n * A command that is aware of logging. This class should be preferred over the base {@link Command} class for any CLI tools that depend on\n * core Elasticsearch as they could directly or indirectly touch classes that touch logging and as such logging needs to be configured.\n ",
      "vertexLabel": "Class LoggingAwareCommand"
    },
    {
      "vertexName": "Method U createIndex(IndexMetaData indexMetaData, List<IndexEventListener> builtInIndexListener) throws IOException  (IndicesClusterStateService.java)",
      "children": [
        {
          "name": "Method public synchronized IndexService createIndex(final IndexMetaData indexMetaData, final List<IndexEventListener> builtInListeners) throws IOException  (IndicesService.java)"
        }
      ],
      "comment": "\n         * Creates a new {@link IndexService} for the given metadata.\n         *\n         * @param indexMetaData          the index metadata to create the index for\n         * @param builtInIndexListener   a list of built-in lifecycle {@link IndexEventListener} that should should be used along side with\n         *                               the per-index listeners\n         * @throws ResourceAlreadyExistsException if the index already exists.\n         ",
      "vertexLabel": "U createIndex()"
    },
    {
      "vertexName": "Method public CreateSnapshotRequestBuilder setSettings(Map<String, Object> settings)  (CreateSnapshotRequestBuilder.java)",
      "children": [
        {
          "name": "Method public CreateSnapshotRequestBuilder setSettings(Settings settings)  (CreateSnapshotRequestBuilder.java)"
        }
      ],
      "comment": "\n     * Sets repository-specific snapshot settings.\n     * <p>\n     * See repository documentation for more information.\n     *\n     * @param settings repository-specific snapshot settings\n     * @return this builder\n     ",
      "vertexLabel": "CreateSnapshotRequestBuilder setSettings()"
    },
    {
      "vertexName": "Method public ClusterRerouteRequest add(AllocationCommand... commands)  (ClusterRerouteRequest.java)",
      "comment": "\n     * Adds allocation commands to be applied to the cluster. Note, can be empty, in which case\n     * will simply run a simple \"reroute\".\n     ",
      "vertexLabel": "ClusterRerouteRequest add()"
    },
    {
      "vertexName": "Method public static ShardId extractShardId(LeafReader reader)  (ShardUtils.java)",
      "comment": "\n     * Tries to extract the shard id from a reader if possible, when its not possible,\n     * will return null.\n     ",
      "vertexLabel": "ShardId extractShardId()"
    },
    {
      "vertexName": "Method public PutIndexTemplateRequest create(boolean create)  (PutIndexTemplateRequest.java)",
      "comment": "\n     * Set to {@code true} to force only creation, not an update of an index template. If it already\n     * exists, it will fail with an {@link IllegalArgumentException}.\n     ",
      "vertexLabel": "PutIndexTemplateRequest create()"
    },
    {
      "vertexName": "Method public String[] concreteIndexNames(ClusterState state, IndicesOptions options, String... indexExpressions)  (IndexNameExpressionResolver.java)",
      "children": [
        {
          "name": "Method public Index[] concreteIndices(ClusterState state, IndicesOptions options, long startTime, String... indexExpressions)  (IndexNameExpressionResolver.java)"
        }
      ],
      "comment": "\n     * Translates the provided index expression into actual concrete indices, properly deduplicated.\n     *\n     * @param state             the cluster state containing all the data to resolve to expressions to concrete indices\n     * @param options           defines how the aliases or indices need to be resolved to concrete indices\n     * @param indexExpressions  expressions that can be resolved to alias or index names.\n     * @return the resolved concrete indices based on the cluster state, indices options and index expressions\n     * @throws IndexNotFoundException if one of the index expressions is pointing to a missing index or alias and the\n     * provided indices options in the context don't allow such a case, or if the final result of the indices resolution\n     * contains no indices and the indices options in the context don't allow such a case.\n     * @throws IllegalArgumentException if one of the aliases resolve to multiple indices and the provided\n     * indices options in the context don't allow such a case.\n     ",
      "vertexLabel": "String[] concreteIndexNames()"
    },
    {
      "vertexName": "Class DiverseDocsDeferringCollector  (DiversifiedBytesHashSamplerAggregator.java)",
      "comment": "\n     * A {@link DeferringBucketCollector} that identifies top scoring documents\n     * but de-duped by a key then passes only these on to nested collectors.\n     * This implementation is only for use with a single bucket aggregation.\n     ",
      "vertexLabel": "Class DiverseDocsDeferringCollector"
    },
    {
      "vertexName": "Method public static boolean isAllIndices(List<String> aliasesOrIndices)  (IndexNameExpressionResolver.java)",
      "children": [
        {
          "name": "Method public static boolean isAllTypes(String[] types)  (MetaData.java)"
        }
      ],
      "comment": "\n     * Identifies whether the array containing index names given as argument refers to all indices\n     * The empty or null array identifies all indices\n     *\n     * @param aliasesOrIndices the array containing index names\n     * @return true if the provided array maps to all indices, false otherwise\n     ",
      "vertexLabel": "boolean isAllIndices()"
    },
    {
      "vertexName": "Method public AllocateStalePrimaryAllocationCommand(String index, int shardId, String node, boolean acceptDataLoss)  (AllocateStalePrimaryAllocationCommand.java)",
      "children": [
        {
          "name": "Method public AllocateReplicaAllocationCommand(String index, int shardId, String node)  (AllocateReplicaAllocationCommand.java)"
        }
      ],
      "comment": "\n     * Creates a new {@link AllocateStalePrimaryAllocationCommand}\n     *\n     * @param index          index of the shard to assign\n     * @param shardId        id of the shard to assign\n     * @param node           node id of the node to assign the shard to\n     * @param acceptDataLoss whether the user agrees to data loss\n     ",
      "vertexLabel": "AllocateStalePrimaryAllocationCommand()"
    },
    {
      "vertexName": "Method public RestoreSnapshotRequestBuilder setIndices(String... indices)  (RestoreSnapshotRequestBuilder.java)",
      "children": [
        {
          "name": "Method public RestoreSnapshotRequest indices(String... indices)  (RestoreSnapshotRequest.java)"
        }
      ],
      "comment": "\n     * Sets the list of indices that should be restored from snapshot\n     * <p>\n     * The list of indices supports multi-index syntax. For example: \"+test*\" ,\"-test42\" will index all indices with\n     * prefix \"test\" except index \"test42\". Aliases are not supported. An empty list or {\"_all\"} will restore all open\n     * indices in the snapshot.\n     *\n     * @param indices list of indices\n     * @return this builder\n     ",
      "vertexLabel": "RestoreSnapshotRequestBuilder setIndices()"
    },
    {
      "vertexName": "Method public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException  (Joda.java)",
      "children": [
        {
          "name": "Method public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale)  (Joda.java)"
        }
      ],
      "comment": "\n         * We adjust the instant by displayOffset to adjust for the offset that might have been added in\n         * {@link DateTimeFormatter#printTo(Appendable, long, Chronology)} when using a time zone.\n         ",
      "vertexLabel": "void printTo()"
    },
    {
      "vertexName": "Method public void setPreFilterShardSize(int preFilterShardSize)  (SearchRequest.java)",
      "comment": "\n     * Sets a threshold that enforces a pre-filter roundtrip to pre-filter search shards based on query rewriting if the number of shards\n     * the search request expands to exceeds the threshold. This filter roundtrip can limit the number of shards significantly if for\n     * instance a shard can not match any documents based on it's rewrite method ie. if date filters are mandatory to match but the shard\n     * bounds and the query are disjoint. The default is {@code 128}\n     ",
      "vertexLabel": "void setPreFilterShardSize()"
    },
    {
      "vertexName": "Class AbstractProfileBreakdown  (AbstractProfileBreakdown.java)",
      "comment": "\n * A record of timings for the various operations that may happen during query execution.\n * A node's time may be composed of several internal attributes (rewriting, weighting,\n * scoring, etc).\n ",
      "vertexLabel": "Class AbstractProfileBreakdown"
    },
    {
      "vertexName": "Field beta  (HoltLinearModel.java)",
      "comment": "\n     * Controls smoothing of trend.\n     * Beta = 1 retains no memory of past values\n     * (e.g. random walk), while alpha = 0 retains infinite memory of past values (e.g.\n     * mean of the series).\n     ",
      "vertexLabel": "Field beta"
    },
    {
      "vertexName": "Method private static double thresholdPercentageFromWatermark(String watermark, boolean lenient)  (DiskThresholdSettings.java)",
      "comment": "\n     * Attempts to parse the watermark into a percentage, returning 100.0% if it can not be parsed and the specified lenient parameter is\n     * true, otherwise throwing an {@link ElasticsearchParseException}.\n     *\n     * @param watermark the watermark to parse as a percentage\n     * @param lenient true if lenient parsing should be applied\n     * @return the parsed percentage\n     ",
      "vertexLabel": "double thresholdPercentageFromWatermark()"
    },
    {
      "vertexName": "Method public Version getMinNodeVersion()  (DiscoveryNodes.java)",
      "comment": "\n     * Returns the version of the node with the oldest version in the cluster.\n     *\n     * @return the oldest version in the cluster\n     ",
      "vertexLabel": "Version getMinNodeVersion()"
    },
    {
      "vertexName": "Method Map<String, Mapper.TypeParser> getMappers()  (MapperPlugin.java)",
      "comment": "\n     * Returns additional mapper implementations added by this plugin.\n     * <p>\n     * The key of the returned {@link Map} is the unique name for the mapper which will be used\n     * as the mapping {@code type}, and the value is a {@link Mapper.TypeParser} to parse the\n     * mapper settings into a {@link Mapper}.\n     ",
      "vertexLabel": "Map<String, Mapper.TypeParser> getMappers()"
    },
    {
      "vertexName": "Method static BytesReference decodeFrame(BytesReference networkBytes) throws IOException  (TcpTransport.java)",
      "children": [
        {
          "name": "Method public static int readMessageLength(BytesReference networkBytes) throws IOException  (TcpTransport.java)"
        }
      ],
      "comment": "\n     * Attempts to a decode a message from the provided bytes. If a full message is not available, null is\n     * returned. If the message is a ping, an empty {@link BytesReference} will be returned.\n     *\n     * @param networkBytes the will be read\n     * @return the message decoded\n     * @throws StreamCorruptedException              if the message header format is not recognized\n     * @throws TcpTransport.HttpOnTransportException if the message header appears to be an HTTP message\n     * @throws IllegalArgumentException              if the message length is greater that the maximum allowed frame size.\n     *                                               This is dependent on the available memory.\n     ",
      "vertexLabel": "BytesReference decodeFrame()"
    },
    {
      "vertexName": "Method public IntArray grow(IntArray array, long minSize)  (BigArrays.java)",
      "children": [
        {
          "name": "Method public ByteArray grow(ByteArray array, long minSize)  (BigArrays.java)"
        }
      ],
      "comment": " Grow an array to a size that is larger than <code>minSize</code>,\n     * preserving content, and potentially reusing part of the provided array. ",
      "vertexLabel": "IntArray grow()"
    },
    {
      "vertexName": "Interface WriteRequest  (WriteRequest.java)",
      "comment": "\n * Interface implemented by requests that modify the documents in an index like {@link IndexRequest}, {@link UpdateRequest}, and\n * {@link BulkRequest}. Rather than implement this directly most implementers should extend {@link ReplicatedWriteRequest}.\n ",
      "vertexLabel": "Interface WriteRequest"
    },
    {
      "vertexName": "Method boolean shouldRollTranslogGeneration()  (IndexShard.java)",
      "children": [
        {
          "name": "Method public abstract boolean shouldRollTranslogGeneration()  (Engine.java)"
        }
      ],
      "comment": "\n     * Tests whether or not the translog generation should be rolled to a new generation. This test is based on the size of the current\n     * generation compared to the configured generation threshold size.\n     *\n     * @return {@code true} if the current generation should be rolled to a new generation\n     ",
      "vertexLabel": "boolean shouldRollTranslogGeneration()"
    },
    {
      "vertexName": "Method void health(ClusterHealthRequest request, ActionListener<ClusterHealthResponse> listener)  (ClusterAdminClient.java)",
      "children": [
        {
          "name": "Method void state(ClusterStateRequest request, ActionListener<ClusterStateResponse> listener)  (ClusterAdminClient.java)"
        }
      ],
      "comment": "\n     * The health of the cluster.\n     *\n     * @param request  The cluster state request\n     * @param listener A listener to be notified with a result\n     * @see Requests#clusterHealthRequest(String...)\n     ",
      "vertexLabel": "void health()"
    },
    {
      "vertexName": "Method ActionFuture<CreateIndexResponse> create(CreateIndexRequest request)  (IndicesAdminClient.java)",
      "comment": "\n     * Creates an index using an explicit request allowing to specify the settings of the index.\n     *\n     * @param request The create index request\n     * @return The result future\n     * @see org.elasticsearch.client.Requests#createIndexRequest(String)\n     ",
      "vertexLabel": "ActionFuture<CreateIndexResponse> create()"
    },
    {
      "vertexName": "Method public void completePersistentTask(String id, long allocationId, Exception failure, ActionListener<PersistentTask<?>> listener)  (PersistentTasksClusterService.java)",
      "children": [
        {
          "name": "Method public void updatePersistentTaskState(final String taskId, final long taskAllocationId, final PersistentTaskState taskState, final ActionListener<PersistentTask<?>> listener)  (PersistentTasksClusterService.java)"
        }
      ],
      "comment": "\n     * Restarts a record about a running persistent task from cluster state\n     *\n     * @param id           the id of the persistent task\n     * @param allocationId the allocation id of the persistent task\n     * @param failure      the reason for restarting the task or null if the task completed successfully\n     * @param listener     the listener that will be called when task is removed\n     ",
      "vertexLabel": "void completePersistentTask()"
    },
    {
      "vertexName": "Method public Analyzer getSearchAnalyzer(MappedFieldType fieldType)  (QueryShardContext.java)",
      "comment": "\n     * Gets the search analyzer for the given field, or the default if there is none present for the field\n     * TODO: remove this by moving defaults into mappers themselves\n     ",
      "vertexLabel": "Analyzer getSearchAnalyzer()"
    },
    {
      "vertexName": "Class DiverseDocsDeferringCollector  (DiversifiedMapSamplerAggregator.java)",
      "children": [
        {
          "name": "Class DiverseDocsDeferringCollector  (DiversifiedBytesHashSamplerAggregator.java)"
        }
      ],
      "comment": "\n     * A {@link DeferringBucketCollector} that identifies top scoring documents\n     * but de-duped by a key then passes only these on to nested collectors.\n     * This implementation is only for use with a single bucket aggregation.\n     ",
      "vertexLabel": "Class DiverseDocsDeferringCollector"
    },
    {
      "vertexName": "Method public abstract boolean lowLevelCancellation()  (SearchContext.java)",
      "children": [
        {
          "name": "Field LOW_LEVEL_CANCELLATION_SETTING  (SearchService.java)"
        }
      ],
      "comment": "\n     * Indicates if the current index should perform frequent low level search cancellation check.\n     *\n     * Enabling low-level checks will make long running searches to react to the cancellation request faster. However,\n     * since it will produce more cancellation checks it might slow the search performance down.\n     ",
      "vertexLabel": "abstract boolean lowLevelCancellation()"
    },
    {
      "vertexName": "Method public GetRequest storedFields(String... fields)  (GetRequest.java)",
      "comment": "\n     * Explicitly specify the stored fields that will be returned. By default, the {@code _source}\n     * field will be returned.\n     ",
      "vertexLabel": "GetRequest storedFields()"
    },
    {
      "vertexName": "Method public static NumericDocValues replaceMissing(NumericDocValues values, long missing)  (FieldData.java)",
      "comment": "\n     * Return a {@link NumericDocValues} instance that has a value for every\n     * document, returns the same value as {@code values} if there is a value\n     * for the current document and {@code missing} otherwise.\n     ",
      "vertexLabel": "NumericDocValues replaceMissing()"
    },
    {
      "vertexName": "Method InetSocketAddress getRemoteAddress()  (HttpChannel.java)",
      "children": [
        {
          "name": "Method InetSocketAddress getRemoteAddress()  (TcpChannel.java)"
        }
      ],
      "comment": "\n     * Returns the remote address for this channel. Can be null if channel does not have a remote address.\n     *\n     * @return the remote address of this channel.\n     ",
      "vertexLabel": "InetSocketAddress getRemoteAddress()"
    },
    {
      "vertexName": "Method public GeoDistanceAggregationBuilder addUnboundedFrom(String key, double from)  (GeoDistanceAggregationBuilder.java)",
      "children": [
        {
          "name": "Method public DateRangeAggregationBuilder addUnboundedFrom(String key, String from)  (DateRangeAggregationBuilder.java)"
        }
      ],
      "comment": "\n     * Add a new range with no upper bound.\n     *\n     * @param key\n     *            the key to use for this range in the response\n     * @param from\n     *            the lower bound on the distances, inclusive\n     ",
      "vertexLabel": "GeoDistanceAggregationBuilder addUnboundedFrom()"
    },
    {
      "vertexName": "Method protected boolean serializeTargetValueType()  (ValuesSourceAggregationBuilder.java)",
      "children": [
        {
          "name": "Method protected boolean serializeTargetValueType()  (MultiValuesSourceAggregationBuilder.java)"
        }
      ],
      "comment": "\n     * Should this builder serialize its targetValueType? Defaults to false. All subclasses that override this to true should use the three\n     * argument read constructor rather than the four argument version.\n     ",
      "vertexLabel": "boolean serializeTargetValueType()"
    },
    {
      "vertexName": "Class IndicesStatsRequestBuilder  (IndicesStatsRequestBuilder.java)",
      "children": [
        {
          "name": "Class IndicesStatsRequest  (IndicesStatsRequest.java)"
        }
      ],
      "comment": "\n * A request to get indices level stats. Allow to enable different stats to be returned.\n * <p>\n * By default, the {@link #setDocs(boolean)}, {@link #setStore(boolean)}, {@link #setIndexing(boolean)}\n * are enabled. Other stats can be enabled as well.\n * <p>\n * All the stats to be returned can be cleared using {@link #clear()}, at which point, specific\n * stats can be enabled.\n ",
      "vertexLabel": "Class IndicesStatsRequestBuilder"
    },
    {
      "vertexName": "Method public String prettyPrint()  (StopWatch.java)",
      "comment": "\n     * Return a string with a table describing all tasks performed.\n     * For custom reporting, call getTaskInfo() and use the task info directly.\n     ",
      "vertexLabel": "String prettyPrint()"
    },
    {
      "vertexName": "Method public URL resolveRepoURL(URL url)  (Environment.java)",
      "children": [
        {
          "name": "Method public Path resolveRepoFile(String location)  (Environment.java)"
        }
      ],
      "comment": "\n     * Checks if the specified URL is pointing to the local file system and if it does, resolves the specified url\n     * against the list of configured repository roots\n     *\n     * If the specified url doesn't match any of the roots, returns null.\n     ",
      "vertexLabel": "URL resolveRepoURL()"
    },
    {
      "vertexName": "Method public static ConnectionProfile buildSingleChannelProfile(TransportRequestOptions.Type channelType, @Nullable TimeValue connectTimeout, @Nullable TimeValue handshakeTimeout)  (ConnectionProfile.java)",
      "children": [
        {
          "name": "Method public static ConnectionProfile buildSingleChannelProfile(TransportRequestOptions.Type channelType, boolean compressionEnabled)  (ConnectionProfile.java)"
        }
      ],
      "comment": "\n     * Builds a connection profile that is dedicated to a single channel type. Allows passing connection and\n     * handshake timeouts.\n     ",
      "vertexLabel": "ConnectionProfile buildSingleChannelProfile()"
    },
    {
      "vertexName": "Method private static void addBindPermissions(Permissions policy, Settings settings)  (Security.java)",
      "children": [
        {
          "name": "Method private static void addSocketPermissionForHttp(final Permissions policy, final Settings settings)  (Security.java)"
        }
      ],
      "comment": "\n     * Add dynamic {@link SocketPermission}s based on HTTP and transport settings.\n     *\n     * @param policy the {@link Permissions} instance to apply the dynamic {@link SocketPermission}s to.\n     * @param settings the {@link Settings} instance to read the HTTP and transport settings from\n     ",
      "vertexLabel": "void addBindPermissions()"
    },
    {
      "vertexName": "Method public GeoBoundingBoxQueryBuilder setCorners(GeoPoint topLeft, GeoPoint bottomRight)  (GeoBoundingBoxQueryBuilder.java)",
      "comment": "\n     * Adds points.\n     * @param topLeft topLeft point to add.\n     * @param bottomRight bottomRight point to add.\n     * ",
      "vertexLabel": "GeoBoundingBoxQueryBuilder setCorners()"
    },
    {
      "vertexName": "Method public static long max(final long maxSeqNo, final long seqNo)  (SequenceNumbers.java)",
      "children": [
        {
          "name": "Method public static long min(final long minSeqNo, final long seqNo)  (SequenceNumbers.java)"
        }
      ],
      "comment": "\n     * Compute the maximum of the given current maximum sequence number and the specified sequence number, accounting for the fact that the\n     * current maximum sequence number could be {@link SequenceNumbers#NO_OPS_PERFORMED} or\n     * {@link SequenceNumbers#UNASSIGNED_SEQ_NO}. When the current maximum sequence number is not\n     * {@link SequenceNumbers#NO_OPS_PERFORMED} nor {@link SequenceNumbers#UNASSIGNED_SEQ_NO}, the specified sequence number\n     * must not be {@link SequenceNumbers#UNASSIGNED_SEQ_NO}.\n     *\n     * @param maxSeqNo the current maximum sequence number\n     * @param seqNo the specified sequence number\n     * @return the new maximum sequence number\n     ",
      "vertexLabel": "long max()"
    },
    {
      "vertexName": "Method public static boolean indexMetaDataChanged(IndexMetaData metaData1, IndexMetaData metaData2)  (ClusterChangedEvent.java)",
      "children": [
        {
          "name": "Method public boolean metaDataChanged()  (ClusterChangedEvent.java)"
        }
      ],
      "comment": "\n     * Returns <code>true</code> iff the {@link IndexMetaData} for a given index\n     * has changed between the previous cluster state and the new cluster state.\n     * Note that this is an object reference equality test, not an equals test.\n     ",
      "vertexLabel": "boolean indexMetaDataChanged()"
    },
    {
      "vertexName": "Method void dispatchBadRequest(RestRequest request, RestChannel channel, ThreadContext threadContext, Throwable cause)  (HttpServerTransport.java)",
      "children": [
        {
          "name": "Method void dispatchRequest(RestRequest request, RestChannel channel, ThreadContext threadContext)  (HttpServerTransport.java)"
        }
      ],
      "comment": "\n         * Dispatches a bad request. For example, if a request is malformed it will be dispatched via this method with the cause of the bad\n         * request.\n         *\n         * @param request       the request to dispatch\n         * @param channel       the response channel of this request\n         * @param threadContext the thread context\n         * @param cause         the cause of the bad request\n         ",
      "vertexLabel": "void dispatchBadRequest()"
    },
    {
      "vertexName": "Class VerifyRepositoryRequest  (VerifyRepositoryRequest.java)",
      "comment": "\n * Unregister repository request.\n * <p>\n * The unregister repository command just unregisters the repository. No data is getting deleted from the repository.\n ",
      "vertexLabel": "Class VerifyRepositoryRequest"
    },
    {
      "vertexName": "Method public CommonTermsQueryBuilder lowFreqMinimumShouldMatch(String lowFreqMinimumShouldMatch)  (CommonTermsQueryBuilder.java)",
      "comment": "\n     * Sets the minimum number of low frequent query terms that need to match in order to\n     * produce a hit.\n     ",
      "vertexLabel": "CommonTermsQueryBuilder lowFreqMinimumShouldMatch()"
    },
    {
      "vertexName": "Method public static String collectionToCommaDelimitedString(Iterable<?> coll)  (Strings.java)",
      "children": [
        {
          "name": "Method public static String arrayToCommaDelimitedString(Object[] arr)  (Strings.java)"
        }
      ],
      "comment": "\n     * Convenience method to return a Collection as a CSV String.\n     * E.g. useful for <code>toString()</code> implementations.\n     *\n     * @param coll the Collection to display\n     * @return the delimited String\n     ",
      "vertexLabel": "String collectionToCommaDelimitedString()"
    },
    {
      "vertexName": "Method public MetadataSnapshot getMetadata(IndexCommit commit, boolean lockDirectory) throws IOException  (Store.java)",
      "children": [
        {
          "name": "Method public MetadataSnapshot getMetadata(IndexCommit commit) throws IOException  (Store.java)"
        }
      ],
      "comment": "\n     * Returns a new MetadataSnapshot for the given commit. If the given commit is <code>null</code>\n     * the latest commit point is used.\n     *\n     * Note that this method requires the caller verify it has the right to access the store and\n     * no concurrent file changes are happening. If in doubt, you probably want to use one of the following:\n     *\n     * {@link #readMetadataSnapshot(Path, ShardId, NodeEnvironment.ShardLocker, Logger)} to read a meta data while locking\n     * {@link IndexShard#snapshotStoreMetadata()} to safely read from an existing shard\n     * {@link IndexShard#acquireLastIndexCommit(boolean)} to get an {@link IndexCommit} which is safe to use but has to be freed\n     *\n     * @param commit the index commit to read the snapshot from or <code>null</code> if the latest snapshot should be read from the\n     *               directory\n     * @param lockDirectory if <code>true</code> the index writer lock will be obtained before reading the snapshot. This should\n     *                      only be used if there is no started shard using this store.\n     * @throws CorruptIndexException      if the lucene index is corrupted. This can be caused by a checksum mismatch or an\n     *                                    unexpected exception when opening the index reading the segments file.\n     * @throws IndexFormatTooOldException if the lucene index is too old to be opened.\n     * @throws IndexFormatTooNewException if the lucene index is too new to be opened.\n     * @throws FileNotFoundException      if one or more files referenced by a commit are not present.\n     * @throws NoSuchFileException        if one or more files referenced by a commit are not present.\n     * @throws IndexNotFoundException     if the commit point can't be found in this store\n     ",
      "vertexLabel": "MetadataSnapshot getMetadata()"
    },
    {
      "vertexName": "Method public int getSlices()  (AbstractBulkByScrollRequest.java)",
      "children": [
        {
          "name": "Field slices  (AbstractBulkByScrollRequest.java)"
        }
      ],
      "comment": "\n     * The number of slices this task should be divided into. Defaults to 1 meaning the task isn't sliced into subtasks.\n     ",
      "vertexLabel": "int getSlices()"
    },
    {
      "vertexName": "Method public Object to()  (RangeQueryBuilder.java)",
      "comment": "\n     * Gets the upper range value for this query.\n     * In case upper bound is assigned to a string, we internally convert it to a {@link BytesRef} because\n     * in {@link RangeQueryBuilder} field are later parsed as {@link BytesRef} and we need internal representation\n     * of query to be equal regardless of whether it was created from XContent or via Java API.\n     ",
      "vertexLabel": "Object to()"
    },
    {
      "vertexName": "Method public static TermQueryBuilder termQuery(String name, int value)  (QueryBuilders.java)",
      "children": [
        {
          "name": "Method public static TermQueryBuilder termQuery(String name, String value)  (QueryBuilders.java)"
        }
      ],
      "comment": "\n     * A Query that matches documents containing a term.\n     *\n     * @param name  The name of the field\n     * @param value The value of the term\n     ",
      "vertexLabel": "TermQueryBuilder termQuery()"
    },
    {
      "vertexName": "Method public void waitForPersistentTasksCondition(final Predicate<PersistentTasksCustomMetaData> predicate, @Nullable final TimeValue timeout, final ActionListener<Boolean> listener)  (PersistentTasksService.java)",
      "comment": "\n     * Waits for persistent tasks to comply with a given predicate, then call back the listener accordingly.\n     *\n     * @param predicate the predicate to evaluate\n     * @param timeout a timeout for waiting\n     * @param listener the callback listener\n     ",
      "vertexLabel": "void waitForPersistentTasksCondition()"
    },
    {
      "vertexName": "Method public CancelAllocationCommand(String index, int shardId, String node, boolean allowPrimary)  (CancelAllocationCommand.java)",
      "children": [
        {
          "name": "Method public String node()  (CancelAllocationCommand.java)"
        },
        {
          "name": "Method public AllocateReplicaAllocationCommand(String index, int shardId, String node)  (AllocateReplicaAllocationCommand.java)"
        }
      ],
      "comment": "\n     * Creates a new {@link CancelAllocationCommand}\n     *\n     * @param index index of the shard which allocation should be canceled\n     * @param shardId id of the shard which allocation should be canceled\n     * @param node id of the node that manages the shard which allocation should be canceled\n     ",
      "vertexLabel": "CancelAllocationCommand()"
    },
    {
      "vertexName": "Field alpha  (HoltWintersModel.java)",
      "children": [
        {
          "name": "Field alpha  (EwmaModel.java)"
        }
      ],
      "comment": "\n     * Controls smoothing of data.  Also known as \"level\" value.\n     * Alpha = 1 retains no memory of past values\n     * (e.g. random walk), while alpha = 0 retains infinite memory of past values (e.g.\n     * mean of the series).\n     ",
      "vertexLabel": "Field alpha"
    },
    {
      "vertexName": "Method public ReducedQueryPhase reducedQueryPhase(Collection<? extends SearchPhaseResult> queryResults, boolean isScrollRequest)  (SearchPhaseController.java)",
      "comment": "\n     * Reduces the given query results and consumes all aggregations and profile results.\n     * @param queryResults a list of non-null query shard results\n     ",
      "vertexLabel": "ReducedQueryPhase reducedQueryPhase()"
    },
    {
      "vertexName": "Method public String getSetting(String index, String setting)  (GetIndexResponse.java)",
      "children": [
        {
          "name": "Method public String getSetting(String index, String setting)  (GetSettingsResponse.java)"
        }
      ],
      "comment": "\n     * Returns the string value for the specified index and setting.  If the includeDefaults flag was not set or set to\n     * false on the {@link GetIndexRequest}, this method will only return a value where the setting was explicitly set\n     * on the index.  If the includeDefaults flag was set to true on the {@link GetIndexRequest}, this method will fall\n     * back to return the default value if the setting was not explicitly set.\n     ",
      "vertexLabel": "String getSetting()"
    },
    {
      "vertexName": "Method public Runnable preserveContext(Runnable command)  (ThreadContext.java)",
      "children": [
        {
          "name": "Method Runnable preserveContext(Runnable command)  (Scheduler.java)"
        }
      ],
      "comment": "\n     * Saves the current thread context and wraps command in a Runnable that restores that context before running command. If\n     * <code>command</code> has already been passed through this method then it is returned unaltered rather than wrapped twice.\n     ",
      "vertexLabel": "Runnable preserveContext()"
    },
    {
      "vertexName": "Method public Path resolveRepoFile(String location)  (Environment.java)",
      "comment": "\n     * Resolves the specified location against the list of configured repository roots\n     *\n     * If the specified location doesn't match any of the roots, returns null.\n     ",
      "vertexLabel": "Path resolveRepoFile()"
    },
    {
      "vertexName": "Method public void submitStateUpdateTask(String source, T updateTask)  (MasterService.java)",
      "children": [
        {
          "name": "Method public void submitStateUpdateTask(String source, T updateTask)  (ClusterService.java)"
        }
      ],
      "comment": "\n     * Submits a cluster state update task; unlike {@link #submitStateUpdateTask(String, Object, ClusterStateTaskConfig,\n     * ClusterStateTaskExecutor, ClusterStateTaskListener)}, submitted updates will not be batched.\n     *\n     * @param source     the source of the cluster state update task\n     * @param updateTask the full context for the cluster state update\n     *                   task\n     *\n     ",
      "vertexLabel": "void submitStateUpdateTask()"
    },
    {
      "vertexName": "Method public ShardRestoreStatus(String nodeId, State state, String reason)  (RestoreInProgress.java)",
      "children": [
        {
          "name": "Method public ShardRestoreStatus(String nodeId, State state)  (RestoreInProgress.java)"
        }
      ],
      "comment": "\n         * Constructs a new shard restore status in with specified state on the given node with specified failure reason\n         *\n         * @param nodeId node id\n         * @param state  restore state\n         * @param reason failure reason\n         ",
      "vertexLabel": "ShardRestoreStatus()"
    },
    {
      "vertexName": "Method public abstract boolean isVersionConflictForWrites(long currentVersion, long expectedVersion, boolean deleted)  (VersionType.java)",
      "children": [
        {
          "name": "Method public abstract boolean isVersionConflictForReads(long currentVersion, long expectedVersion)  (VersionType.java)"
        }
      ],
      "comment": "\n     * Checks whether the current version conflicts with the expected version, based on the current version type.\n     *\n     * @param currentVersion  the current version for the document\n     * @param expectedVersion the version specified for the write operation\n     * @param deleted         true if the document is currently deleted (note that #currentVersion will typically be\n     *                        {@link Versions#NOT_FOUND}, but may be something else if the document was recently deleted\n     * @return true if versions conflict false o.w.\n     ",
      "vertexLabel": "abstract boolean isVersionConflictForWrites()"
    },
    {
      "vertexName": "Method Set<InjectionPoint> getInjectionPoints()  (ProviderInstanceBinding.java)",
      "children": [
        {
          "name": "Method Set<InjectionPoint> getInjectionPoints()  (InstanceBinding.java)"
        }
      ],
      "comment": "\n     * Returns the field and method injection points of the provider, injected at injector-creation\n     * time only.\n     *\n     * @return a possibly empty set\n     ",
      "vertexLabel": "Set<InjectionPoint> getInjectionPoints()"
    },
    {
      "vertexName": "EnumConstant BEST_FIELDS  (MultiMatchQueryBuilder.java)",
      "children": [
        {
          "name": "EnumConstant PHRASE  (MultiMatchQueryBuilder.java)"
        }
      ],
      "comment": "\n         * Uses the best matching boolean field as main score and uses\n         * a tie-breaker to adjust the score based on remaining field matches\n         ",
      "vertexLabel": "EnumConstant BEST_FIELDS"
    },
    {
      "vertexName": "Class DiverseDocsDeferringCollector  (DiversifiedNumericSamplerAggregator.java)",
      "children": [
        {
          "name": "Class DiverseDocsDeferringCollector  (DiversifiedBytesHashSamplerAggregator.java)"
        }
      ],
      "comment": "\n     * A {@link DeferringBucketCollector} that identifies top scoring documents\n     * but de-duped by a key then passes only these on to nested collectors.\n     * This implementation is only for use with a single bucket aggregation.\n     ",
      "vertexLabel": "Class DiverseDocsDeferringCollector"
    },
    {
      "vertexName": "Method public ForceMergeRequest maxNumSegments(int maxNumSegments)  (ForceMergeRequest.java)",
      "children": [
        {
          "name": "Method public int maxNumSegments()  (ForceMergeRequest.java)"
        }
      ],
      "comment": "\n     * Will merge the index down to &lt;= maxNumSegments. By default, will cause the merge\n     * process to merge down to half the configured number of segments.\n     ",
      "vertexLabel": "ForceMergeRequest maxNumSegments()"
    },
    {
      "vertexName": "Method private long getBitSetKey(final long seqNo)  (LocalCheckpointTracker.java)",
      "comment": "\n     * Return the bit set for the provided sequence number, possibly allocating a new set if needed.\n     *\n     * @param seqNo the sequence number to obtain the bit set for\n     * @return the bit set corresponding to the provided sequence number\n     ",
      "vertexLabel": "long getBitSetKey()"
    },
    {
      "vertexName": "Method public ClusterRerouteRequest setRetryFailed(boolean retryFailed)  (ClusterRerouteRequest.java)",
      "comment": "\n     * Sets the retry failed flag (defaults to {@code false}). If true, the\n     * request will retry allocating shards that can't currently be allocated due to too many allocation failures.\n     ",
      "vertexLabel": "ClusterRerouteRequest setRetryFailed()"
    },
    {
      "vertexName": "Field requestsPerSecond  (AbstractBulkByScrollRequest.java)",
      "comment": "\n     * The throttle for this request in sub-requests per second. {@link Float#POSITIVE_INFINITY} means set no throttle and that is the\n     * default. Throttling is done between batches, as we start the next scroll requests. That way we can increase the scroll's timeout to\n     * make sure that it contains any time that we might wait.\n     ",
      "vertexLabel": "Field requestsPerSecond"
    },
    {
      "vertexName": "EnumConstant PHRASE_PREFIX  (MultiMatchQueryBuilder.java)",
      "children": [
        {
          "name": "EnumConstant PHRASE  (MultiMatchQueryBuilder.java)"
        }
      ],
      "comment": "\n         * Uses the best matching phrase-prefix field as main score and uses\n         * a tie-breaker to adjust the score based on remaining field matches\n         ",
      "vertexLabel": "EnumConstant PHRASE_PREFIX"
    },
    {
      "vertexName": "Class ForceMergeRequest  (ForceMergeRequest.java)",
      "children": [
        {
          "name": "Class ForceMergeRequestBuilder  (ForceMergeRequestBuilder.java)"
        }
      ],
      "comment": "\n * A request to force merging the segments of one or more indices. In order to\n * run a merge on all the indices, pass an empty array or {@code null} for the\n * indices.\n * {@link #maxNumSegments(int)} allows to control the number of segments\n * to force merge down to. Defaults to simply checking if a merge needs\n * to execute, and if so, executes it\n *\n * @see org.elasticsearch.client.Requests#forceMergeRequest(String...)\n * @see org.elasticsearch.client.IndicesAdminClient#forceMerge(ForceMergeRequest)\n * @see ForceMergeResponse\n ",
      "vertexLabel": "Class ForceMergeRequest"
    },
    {
      "vertexName": "Method public HandshakeResponse handshake(final Transport.Connection connection, final long handshakeTimeout, Predicate<ClusterName> clusterNamePredicate)  (TransportService.java)",
      "children": [
        {
          "name": "Method public DiscoveryNode handshake(final Transport.Connection connection, final long handshakeTimeout) throws ConnectTransportException  (TransportService.java)"
        }
      ],
      "comment": "\n     * Executes a high-level handshake using the given connection\n     * and returns the discovery node of the node the connection\n     * was established with. The handshake will fail if the cluster\n     * name on the target node doesn't match the local cluster name.\n     *\n     * @param connection       the connection to a specific node\n     * @param handshakeTimeout handshake timeout\n     * @param clusterNamePredicate cluster name validation predicate\n     * @return the handshake response\n     * @throws IllegalStateException if the handshake failed\n     ",
      "vertexLabel": "HandshakeResponse handshake()"
    },
    {
      "vertexName": "Method public PutRepositoryRequest settings(String source, XContentType xContentType)  (PutRepositoryRequest.java)",
      "children": [
        {
          "name": "Method public PutRepositoryRequestBuilder setSettings(String source, XContentType xContentType)  (PutRepositoryRequestBuilder.java)"
        }
      ],
      "comment": "\n     * Sets the repository settings.\n     *\n     * @param source repository settings in json or yaml format\n     * @param xContentType the content type of the source\n     * @return this request\n     ",
      "vertexLabel": "PutRepositoryRequest settings()"
    },
    {
      "vertexName": "Field STRICT_DATE_OPTIONAL_TIME_NANOS  (DateFormatters.java)",
      "children": [
        {
          "name": "Field STRICT_DATE_OPTIONAL_TIME  (DateFormatters.java)"
        }
      ],
      "comment": "\n     * Returns a generic ISO datetime parser where the date is mandatory and the time is optional with nanosecond resolution.\n     ",
      "vertexLabel": "Field STRICT_DATE_OPTIONAL_TIME_NANOS"
    },
    {
      "vertexName": "Method public static String arrayToCommaDelimitedString(Object[] arr)  (Strings.java)",
      "comment": "\n     * Convenience method to return a String array as a CSV String.\n     * E.g. useful for <code>toString()</code> implementations.\n     *\n     * @param arr the array to display\n     * @return the delimited String\n     ",
      "vertexLabel": "String arrayToCommaDelimitedString()"
    },
    {
      "vertexName": "Method public UnaryOperator<Map<String, MetaData.Custom>> getCustomMetaDataUpgrader()  (Plugin.java)",
      "children": [
        {
          "name": "Method public UnaryOperator<IndexMetaData> getIndexMetaDataUpgrader()  (Plugin.java)"
        }
      ],
      "comment": "\n     * Provides a function to modify global custom meta data on startup.\n     * <p>\n     * Plugins should return the input custom map via {@link UnaryOperator#identity()} if no upgrade is required.\n     * <p>\n     * The order of custom meta data upgraders calls is undefined and can change between runs so, it is expected that\n     * plugins will modify only data owned by them to avoid conflicts.\n     * <p>\n     * @return Never {@code null}. The same or upgraded {@code MetaData.Custom} map.\n     * @throws IllegalStateException if the node should not start because at least one {@code MetaData.Custom}\n     *                               is unsupported\n     ",
      "vertexLabel": "UnaryOperator<Map<String, MetaData.Custom>> getCustomMetaDataUpgrader()"
    },
    {
      "vertexName": "Method void get(GetRequest request, ActionListener<GetResponse> listener)  (Client.java)",
      "children": [
        {
          "name": "Method ActionFuture<GetResponse> get(GetRequest request)  (Client.java)"
        }
      ],
      "comment": "\n     * Gets the document that was indexed from an index with a type and id.\n     *\n     * @param request  The get request\n     * @param listener A listener to be notified with a result\n     * @see Requests#getRequest(String)\n     ",
      "vertexLabel": "void get()"
    },
    {
      "vertexName": "Method native boolean QueryInformationJobObject(Pointer job, int infoClass, Pointer info, int infoLength, Pointer returnLength)  (JNAKernel32Library.java)",
      "children": [
        {
          "name": "Method native boolean SetInformationJobObject(Pointer job, int infoClass, Pointer info, int infoLength)  (JNAKernel32Library.java)"
        }
      ],
      "comment": "\n     * Get job limit and state information\n     *\n     * https://msdn.microsoft.com/en-us/library/windows/desktop/ms684925%28v=vs.85%29.aspx\n     *\n     * @param job job handle\n     * @param infoClass information class constant\n     * @param info pointer to information structure\n     * @param infoLength size of information structure\n     * @param returnLength length of data written back to structure (or null if not wanted)\n     * @return true if the function succeeds\n     ",
      "vertexLabel": "native boolean QueryInformationJobObject()"
    },
    {
      "vertexName": "Method public MoreLikeThisQueryBuilder(@Nullable String[] fields, @Nullable String[] likeTexts, @Nullable Item[] likeItems)  (MoreLikeThisQueryBuilder.java)",
      "children": [
        {
          "name": "Method public static MoreLikeThisQueryBuilder moreLikeThisQuery(String[] likeTexts, Item[] likeItems)  (QueryBuilders.java)"
        },
        {
          "name": "Method public void setFieldNames(String[] fieldNames)  (XMoreLikeThis.java)"
        }
      ],
      "comment": "\n     * Sets the field names that will be used when generating the 'More Like This' query.\n     *\n     * @param fields the field names that will be used when generating the 'More Like This' query.\n     * @param likeTexts the text to use when generating the 'More Like This' query.\n     * @param likeItems the documents to use when generating the 'More Like This' query.\n     ",
      "vertexLabel": "MoreLikeThisQueryBuilder()"
    },
    {
      "vertexName": "Method public SpanContainingQueryBuilder(SpanQueryBuilder big, SpanQueryBuilder little)  (SpanContainingQueryBuilder.java)",
      "comment": "\n     * @param big the big clause, it must enclose {@code little} for a match.\n     * @param little the little clause, it must be contained within {@code big} for a match.\n     ",
      "vertexLabel": "SpanContainingQueryBuilder()"
    },
    {
      "vertexName": "Method public PercentileRanksAggregationBuilder compression(double compression)  (PercentileRanksAggregationBuilder.java)",
      "comment": "\n     * Expert: set the compression. Higher values improve accuracy but also\n     * memory usage. Only relevant when using {@link PercentilesMethod#TDIGEST}.\n     ",
      "vertexLabel": "PercentileRanksAggregationBuilder compression()"
    },
    {
      "vertexName": "Method public MatchQueryBuilder analyzer(String analyzer)  (MatchQueryBuilder.java)",
      "children": [
        {
          "name": "Method public MatchPhrasePrefixQueryBuilder analyzer(String analyzer)  (MatchPhrasePrefixQueryBuilder.java)"
        }
      ],
      "comment": "\n     * Explicitly set the analyzer to use. Defaults to use explicit mapping config for the field, or, if not\n     * set, the default search analyzer.\n     ",
      "vertexLabel": "MatchQueryBuilder analyzer()"
    },
    {
      "vertexName": "Method long getNumDocAppends()  (InternalEngine.java)",
      "children": [
        {
          "name": "Method long getNumDocUpdates()  (InternalEngine.java)"
        }
      ],
      "comment": "\n     * Returns the number of documents have been appended since this engine was opened.\n     * This count does not include the appends from the existing segments before opening engine.\n     ",
      "vertexLabel": "long getNumDocAppends()"
    },
    {
      "vertexName": "Method public Builder deleteScript(String id)  (ScriptMetaData.java)",
      "comment": "\n         * Delete a script from the existing stored scripts based on a user-specified id.\n         * @param id The user-specified id to use for the look up.\n         ",
      "vertexLabel": "Builder deleteScript()"
    },
    {
      "vertexName": "Method public DirectCandidateGeneratorBuilder maxTermFreq(float maxTermFreq)  (DirectCandidateGeneratorBuilder.java)",
      "comment": "\n     * Sets a maximum threshold in number of documents a suggest text token\n     * can exist in order to be corrected. Can be a relative percentage\n     * number (e.g 0.4) or an absolute number to represent document\n     * frequencies. If an value higher than 1 is specified then fractional\n     * can not be specified. Defaults to {@code 0.01}.\n     * <p>\n     * This can be used to exclude high frequency terms from being\n     * suggested. High frequency terms are usually spelled correctly on top\n     * of this this also improves the suggest performance.\n     ",
      "vertexLabel": "DirectCandidateGeneratorBuilder maxTermFreq()"
    },
    {
      "vertexName": "Method public final Request waitForActiveShards(ActiveShardCount waitForActiveShards)  (ReplicationRequest.java)",
      "comment": "\n     * Sets the number of shard copies that must be active before proceeding with the replication\n     * operation. Defaults to {@link ActiveShardCount#DEFAULT}, which requires one shard copy\n     * (the primary) to be active. Set this value to {@link ActiveShardCount#ALL} to\n     * wait for all shards (primary and all replicas) to be active. Otherwise, use\n     * {@link ActiveShardCount#from(int)} to set this value to any non-negative integer, up to the\n     * total number of shard copies (number of replicas + 1).\n     ",
      "vertexLabel": "final Request waitForActiveShards()"
    },
    {
      "vertexName": "Method public long minDocCount()  (HistogramAggregationBuilder.java)",
      "children": [
        {
          "name": "Method public long minDocCount()  (DateHistogramAggregationBuilder.java)"
        }
      ],
      "comment": " Return the minimum count of documents that buckets need to have in order\n     *  to be included in the response. ",
      "vertexLabel": "long minDocCount()"
    },
    {
      "vertexName": "Method public CommonStatsFlags fieldDataFields(String... fieldDataFields)  (CommonStatsFlags.java)",
      "children": [
        {
          "name": "Method public CommonStatsFlags groups(String... groups)  (CommonStatsFlags.java)"
        }
      ],
      "comment": "\n     * Sets specific search group stats to retrieve the stats for. Mainly affects search\n     * when enabled.\n     ",
      "vertexLabel": "CommonStatsFlags fieldDataFields()"
    },
    {
      "vertexName": "Method Function<String, Predicate<String>> getFieldFilter()  (MapperPlugin.java)",
      "comment": "\n     * Returns a function that given an index name returns a predicate which fields must match in order to be returned by get mappings,\n     * get index, get field mappings and field capabilities API. Useful to filter the fields that such API return. The predicate receives\n     * the field name as input argument and should return true to show the field and false to hide it.\n     ",
      "vertexLabel": "Function<String, Predicate<String>> getFieldFilter()"
    },
    {
      "vertexName": "Method Set<DiscoveryNode> getFaultDetectionNodes()  (ZenDiscovery.java)",
      "children": [
        {
          "name": "Method public Set<DiscoveryNode> getNodes()  (NodesFaultDetection.java)"
        }
      ],
      "comment": "\n     * Gets the current set of nodes involved in the node fault detection.\n     * NB: for testing purposes\n     ",
      "vertexLabel": "Set<DiscoveryNode> getFaultDetectionNodes()"
    },
    {
      "vertexName": "Method public GeoDistanceAggregationBuilder addRange(String key, double from, double to)  (GeoDistanceAggregationBuilder.java)",
      "children": [
        {
          "name": "Method public DateRangeAggregationBuilder addRange(String key, String from, String to)  (DateRangeAggregationBuilder.java)"
        }
      ],
      "comment": "\n     * Add a new range to this aggregation.\n     *\n     * @param key\n     *            the key to use for this range in the response\n     * @param from\n     *            the lower bound on the distances, inclusive\n     * @param to\n     *            the upper bound on the distances, exclusive\n     ",
      "vertexLabel": "GeoDistanceAggregationBuilder addRange()"
    },
    {
      "vertexName": "Method private static boolean isOrder(BucketOrder order, BucketOrder expected)  (InternalOrder.java)",
      "children": [
        {
          "name": "Method public static boolean isKeyAsc(BucketOrder order)  (InternalOrder.java)"
        }
      ],
      "comment": "\n     * Determine if the ordering strategy matches the expected one.\n     *\n     * @param order    bucket ordering strategy to check. If this is a {@link CompoundOrder} the first element will be\n     *                 check instead.\n     * @param expected expected  bucket ordering strategy.\n     * @return {@code true} if the order matches, {@code false} otherwise.\n     ",
      "vertexLabel": "boolean isOrder()"
    },
    {
      "vertexName": "Method RolloverRequestBuilder prepareRolloverIndex(String sourceAlias)  (IndicesAdminClient.java)",
      "comment": "\n     * Swaps the index pointed to by an alias given all provided conditions are satisfied\n     ",
      "vertexLabel": "RolloverRequestBuilder prepareRolloverIndex()"
    },
    {
      "vertexName": "Method public UpdateRequestBuilder setFetchSource(@Nullable String include, @Nullable String exclude)  (UpdateRequestBuilder.java)",
      "children": [
        {
          "name": "Method public SearchRequestBuilder setFetchSource(@Nullable String include, @Nullable String exclude)  (SearchRequestBuilder.java)"
        }
      ],
      "comment": "\n     * Indicate that _source should be returned with every hit, with an\n     * \"include\" and/or \"exclude\" set which can include simple wildcard\n     * elements.\n     *\n     * @param include\n     *            An optional include (optionally wildcarded) pattern to filter\n     *            the returned _source\n     * @param exclude\n     *            An optional exclude (optionally wildcarded) pattern to filter\n     *            the returned _source\n     ",
      "vertexLabel": "UpdateRequestBuilder setFetchSource()"
    },
    {
      "vertexName": "Method void publish(ClusterChangedEvent clusterChangedEvent, AckListener ackListener)  (Discovery.java)",
      "children": [
        {
          "name": "Method public void publish(final ClusterChangedEvent clusterChangedEvent, final int minMasterNodes, final Discovery.AckListener ackListener) throws Discovery.FailedToCommitClusterStateException  (PublishClusterStateAction.java)"
        }
      ],
      "comment": "\n     * Publish all the changes to the cluster from the master (can be called just by the master). The publish\n     * process should apply this state to the master as well!\n     *\n     * The {@link AckListener} allows to keep track of the ack received from nodes, and verify whether\n     * they updated their own cluster state or not.\n     *\n     * The method is guaranteed to throw a {@link FailedToCommitClusterStateException} if the change is not\n     * committed and should be rejected.\n     * Any other exception signals the something wrong happened but the change is committed.\n     ",
      "vertexLabel": "void publish()"
    },
    {
      "vertexName": "EnumConstant PARTIAL_CONTENT  (RestStatus.java)",
      "children": [
        {
          "name": "EnumConstant NOT_MODIFIED  (RestStatus.java)"
        }
      ],
      "comment": "\n     * The server has fulfilled the partial GET request for the resource. The request MUST have included a Range\n     * header field (section 14.35) indicating the desired range, and MAY have included an If-Range header\n     * field (section 14.27) to make the request conditional.\n     * <p>\n     * The response MUST include the following header fields:\n     * <ul>\n     * <li>Either a Content-Range header field (section 14.16) indicating the range included with this response,\n     * or a multipart/byteranges Content-Type including Content-Range fields for each part. If a Content-Length\n     * header field is present in the response, its value MUST match the actual number of OCTETs transmitted in\n     * the message-body.</li>\n     * <li>Date</li>\n     * <li>ETag and/or Content-Location, if the header would have been sent in a 200 response to the same request</li>\n     * <li>Expires, Cache-Control, and/or Vary, if the field-value might differ from that sent in any previous\n     * response for the same variant</li>\n     * </ul>\n     * <p>\n     * If the 206 response is the result of an If-Range request that used a strong cache validator\n     * (see section 13.3.3), the response SHOULD NOT include other entity-headers. If the response is the result\n     * of an If-Range request that used a weak validator, the response MUST NOT include other entity-headers;\n     * this prevents inconsistencies between cached entity-bodies and updated headers. Otherwise, the response MUST\n     * include all of the entity-headers that would have been returned with a 200 (OK) response to the same request.\n     * <p>\n     * A cache MUST NOT combine a 206 response with other previously cached content if the ETag or Last-Modified\n     * headers do not match exactly, see 13.5.4.\n     * <p>\n     * A cache that does not support the Range and Content-Range headers MUST NOT cache 206 (Partial) responses.\n     ",
      "vertexLabel": "EnumConstant PARTIAL_CONTENT"
    },
    {
      "vertexName": "Method protected ClusterBlockLevel indexBlockLevel()  (TransportReplicationAction.java)",
      "comment": "\n     * Index level block to check before request execution. Returning null means that no blocks need to be checked.\n     ",
      "vertexLabel": "ClusterBlockLevel indexBlockLevel()"
    },
    {
      "vertexName": "Method public double getScore(long subsetFreq, long subsetSize, long supersetFreq, long supersetSize)  (ScriptHeuristic.java)",
      "children": [
        {
          "name": "Method public abstract double getScore(long subsetFreq, long subsetSize, long supersetFreq, long supersetSize)  (SignificanceHeuristic.java)"
        }
      ],
      "comment": "\n     * Calculates score with a script\n     *\n     * @param subsetFreq   The frequency of the term in the selected sample\n     * @param subsetSize   The size of the selected sample (typically number of docs)\n     * @param supersetFreq The frequency of the term in the superset from which the sample was taken\n     * @param supersetSize The size of the superset from which the sample was taken  (typically number of docs)\n     * @return a \"significance\" score\n     ",
      "vertexLabel": "double getScore()"
    },
    {
      "vertexName": "Method public static String copyToString(Reader in) throws IOException  (Streams.java)",
      "comment": "\n     * Copy the contents of the given Reader into a String.\n     * Closes the reader when done.\n     *\n     * @param in the reader to copy from\n     * @return the String that has been copied to\n     * @throws IOException in case of I/O errors\n     ",
      "vertexLabel": "String copyToString()"
    },
    {
      "vertexName": "Method public static int toIntExact(Number n)  (Numbers.java)",
      "comment": " Return the int that {@code n} stores, or throws an exception if the\n     *  stored value cannot be converted to an int that stores the exact same\n     *  value. ",
      "vertexLabel": "int toIntExact()"
    },
    {
      "vertexName": "Method public CreateSnapshotRequest settings(Settings.Builder settings)  (CreateSnapshotRequest.java)",
      "children": [
        {
          "name": "Method public CreateSnapshotRequest settings(Settings settings)  (CreateSnapshotRequest.java)"
        }
      ],
      "comment": "\n     * Sets repository-specific snapshot settings.\n     * <p>\n     * See repository documentation for more information.\n     *\n     * @param settings repository-specific snapshot settings\n     * @return this request\n     ",
      "vertexLabel": "CreateSnapshotRequest settings()"
    },
    {
      "vertexName": "Method public DirectCandidateGeneratorBuilder prefixLength(int prefixLength)  (DirectCandidateGeneratorBuilder.java)",
      "comment": "\n     * Sets the number of minimal prefix characters that must match in order\n     * be a candidate suggestion. Defaults to 1. Increasing this number\n     * improves suggest performance. Usually misspellings don't occur in the\n     * beginning of terms.\n     ",
      "vertexLabel": "DirectCandidateGeneratorBuilder prefixLength()"
    },
    {
      "vertexName": "Method public PutMappingRequest source(Object... source)  (PutMappingRequest.java)",
      "children": [
        {
          "name": "Method public CreateIndexRequest mapping(String type, Object... source)  (CreateIndexRequest.java)"
        }
      ],
      "comment": "\n     * A specialized simplified mapping source method, takes the form of simple properties definition:\n     * (\"field1\", \"type=string,store=true\").\n     *\n     * Also supports metadata mapping fields such as `_all` and `_parent` as property definition, these metadata\n     * mapping fields will automatically be put on the top level mapping object.\n     ",
      "vertexLabel": "PutMappingRequest source()"
    },
    {
      "vertexName": "Method static void closeChannels(List<C> channels, boolean blocking)  (CloseableChannel.java)",
      "children": [
        {
          "name": "Method static void closeChannel(C channel, boolean blocking)  (CloseableChannel.java)"
        }
      ],
      "comment": "\n     * Closes the channels.\n     *\n     * @param channels to close\n     * @param blocking indicates if we should block on channel close\n     ",
      "vertexLabel": "void closeChannels()"
    },
    {
      "vertexName": "Method public static ListTasksRequest listTasksRequest()  (Requests.java)",
      "comment": "\n     * Creates a nodes tasks request against all the nodes.\n     *\n     * @return The nodes tasks request\n     * @see org.elasticsearch.client.ClusterAdminClient#listTasks(ListTasksRequest)\n     ",
      "vertexLabel": "ListTasksRequest listTasksRequest()"
    },
    {
      "vertexName": "Method public int predict()  (MovAvgPipelineAggregationBuilder.java)",
      "comment": "\n     * Gets the number of predictions that should be returned. Each\n     * prediction will be spaced at the intervals specified in the\n     * histogram. E.g \"predict: 2\" will return two new buckets at the end of\n     * the histogram with the predicted values.\n     ",
      "vertexLabel": "int predict()"
    },
    {
      "vertexName": "Method Map<String, MetadataFieldMapper.TypeParser> getMetadataMappers()  (MapperPlugin.java)",
      "children": [
        {
          "name": "Method Map<String, Mapper.TypeParser> getMappers()  (MapperPlugin.java)"
        }
      ],
      "comment": "\n     * Returns additional metadata mapper implementations added by this plugin.\n     * <p>\n     * The key of the returned {@link Map} is the unique name for the metadata mapper, which\n     * is used in the mapping json to configure the metadata mapper, and the value is a\n     * {@link MetadataFieldMapper.TypeParser} to parse the mapper settings into a\n     * {@link MetadataFieldMapper}.\n     ",
      "vertexLabel": "Map<String, MetadataFieldMapper.TypeParser> getMetadataMappers()"
    },
    {
      "vertexName": "Method public String[] nonSearchableIndices()  (FieldCapabilities.java)",
      "comment": "\n     * The list of indices where this field is not searchable,\n     * or null if the field is searchable in all indices.\n     ",
      "vertexLabel": "String[] nonSearchableIndices()"
    },
    {
      "vertexName": "Interface UntargettedBinding  (UntargettedBinding.java)",
      "children": [
        {
          "name": "Method V visit(UntargettedBinding<? extends T> binding)  (BindingTargetVisitor.java)"
        }
      ],
      "comment": "\n * An untargetted binding. This binding indicates that the injector should use its implicit binding\n * strategies to resolve injections.\n *\n * @author jessewilson@google.com (Jesse Wilson)\n * @since 2.0\n ",
      "vertexLabel": "Interface UntargettedBinding"
    },
    {
      "vertexName": "Method void onFailure(String source, Exception e)  (ClusterApplier.java)",
      "children": [
        {
          "name": "Method void onSuccess(String source)  (ClusterApplier.java)"
        }
      ],
      "comment": "\n         * Called on failure during cluster state application\n         * @param source information where the cluster state came from\n         * @param e exception that occurred\n         ",
      "vertexLabel": "void onFailure()"
    },
    {
      "vertexName": "Method static AggregationBuilder rewriteAggregation(AggregationBuilder original, QueryRewriteContext context) throws IOException  (AggregationBuilder.java)",
      "comment": "\n     * Rewrites the given aggregation into its primitive form. Aggregations that for instance fetch resources from remote hosts or\n     * can simplify / optimize itself should do their heavy lifting during {@link #rewrite(QueryRewriteContext)}. This method\n     * rewrites the aggregation until it doesn't change anymore.\n     * @throws IOException if an {@link IOException} occurs\n     ",
      "vertexLabel": "AggregationBuilder rewriteAggregation()"
    },
    {
      "vertexName": "Method public static Multibinder<T> newSetBinder(Binder binder, TypeLiteral<T> type)  (Multibinder.java)",
      "comment": "\n     * Returns a new multibinder that collects instances of {@code type} in a {@link Set} that is\n     * itself bound with no binding annotation.\n     ",
      "vertexLabel": "Multibinder<T> newSetBinder()"
    },
    {
      "vertexName": "Method public byte[] getFieldValueAsBytes(String path)  (IngestDocument.java)",
      "children": [
        {
          "name": "Method public T getFieldValue(String path, Class<T> clazz)  (IngestDocument.java)"
        }
      ],
      "comment": "\n     * Returns the value contained in the document for the provided path as a byte array.\n     * If the path value is a string, a base64 decode operation will happen.\n     * If the path value is a byte array, it is just returned\n     * @param path The path within the document in dot-notation\n     * @return the byte array for the provided path if existing\n     * @throws IllegalArgumentException if the path is null, empty, invalid, if the field doesn't exist\n     * or if the field that is found at the provided path is not of the expected type.\n     ",
      "vertexLabel": "byte[] getFieldValueAsBytes()"
    },
    {
      "vertexName": "Method void injectMembers(Object instance)  (Injector.java)",
      "children": [
        {
          "name": "Method void injectMembers(T instance)  (MembersInjector.java)"
        }
      ],
      "comment": "\n     * Injects dependencies into the fields and methods of {@code instance}. Ignores the presence or\n     * absence of an injectable constructor.\n     * <p>\n     * Whenever Guice creates an instance, it performs this injection automatically (after first\n     * performing constructor injection), so if you're able to let Guice create all your objects for\n     * you, you'll never need to use this method.\n     *\n     * @param instance to inject members on\n     * @see Binder#getMembersInjector(Class) for a preferred alternative that supports checks before\n     *      run time\n     ",
      "vertexLabel": "void injectMembers()"
    },
    {
      "vertexName": "Method public static void readFromFileChannelWithEofException(FileChannel channel, long channelPosition, ByteBuffer dest) throws IOException  (Channels.java)",
      "comment": "\n     * read from a file channel into a byte buffer, starting at a certain position.  An EOFException will be thrown if you\n     * attempt to read beyond the end of file.\n     *\n     * @param channel         channel to read from\n     * @param channelPosition position to read from\n     * @param dest            destination {@link java.nio.ByteBuffer} to put data in\n     ",
      "vertexLabel": "void readFromFileChannelWithEofException()"
    },
    {
      "vertexName": "Class AbstractNamedDiffable  (AbstractNamedDiffable.java)",
      "children": [
        {
          "name": "Class AbstractDiffable  (AbstractDiffable.java)"
        }
      ],
      "comment": "\n * Abstract diffable object with simple diffs implementation that sends the entire object if object has changed or\n * nothing is object remained the same. Comparing to AbstractDiffable, this class also works with NamedWriteables\n ",
      "vertexLabel": "Class AbstractNamedDiffable"
    },
    {
      "vertexName": "Method public TermSuggestionBuilder sort(SortBy sort)  (TermSuggestionBuilder.java)",
      "children": [
        {
          "name": "Method public DirectCandidateGeneratorBuilder sort(String sort)  (DirectCandidateGeneratorBuilder.java)"
        }
      ],
      "comment": "\n     * Sets how to sort the suggest terms per suggest text token. Two possible\n     * values:\n     * <ol>\n     * <li><code>score</code> - Sort should first be based on score, then\n     * document frequency and then the term itself.\n     * <li><code>frequency</code> - Sort should first be based on document\n     * frequency, then score and then the term itself.\n     * </ol>\n     * <p>\n     * What the score is depends on the suggester being used.\n     ",
      "vertexLabel": "TermSuggestionBuilder sort()"
    },
    {
      "vertexName": "Method T actionGet(long timeoutMillis)  (ActionFuture.java)",
      "children": [
        {
          "name": "Method T actionGet(String timeout)  (ActionFuture.java)"
        }
      ],
      "comment": "\n     * Similar to {@link #get(long, java.util.concurrent.TimeUnit)}, just catching the {@link InterruptedException} and throwing\n     * an {@link IllegalStateException} instead. Also catches\n     * {@link java.util.concurrent.ExecutionException} and throws the actual cause instead.\n     *\n     * @param timeoutMillis Timeout in millis\n     ",
      "vertexLabel": "T actionGet()"
    },
    {
      "vertexName": "Class UpdateByQueryRequest  (UpdateByQueryRequest.java)",
      "comment": "\n * Request to update some documents. That means you can't change their type, id, index, or anything like that. This implements\n * CompositeIndicesRequest but in a misleading way. Rather than returning all the subrequests that it will make it tries to return a\n * representative set of subrequests. This is best-effort but better than {@linkplain ReindexRequest} because scripts can't change the\n * destination index and things.\n ",
      "vertexLabel": "Class UpdateByQueryRequest"
    },
    {
      "vertexName": "Method public MoreLikeThisQueryBuilder(String[] likeTexts, Item[] likeItems)  (MoreLikeThisQueryBuilder.java)",
      "children": [
        {
          "name": "Method public static MoreLikeThisQueryBuilder moreLikeThisQuery(String[] likeTexts)  (QueryBuilders.java)"
        }
      ],
      "comment": "\n     * Constructs a new more like this query which uses the default search field.\n     * @param likeTexts the text to use when generating the 'More Like This' query.\n     * @param likeItems the documents to use when generating the 'More Like This' query.\n     ",
      "vertexLabel": "MoreLikeThisQueryBuilder()"
    },
    {
      "vertexName": "Method public static FunctionScoreQueryBuilder functionScoreQuery(QueryBuilder queryBuilder, FunctionScoreQueryBuilder.FilterFunctionBuilder[] filterFunctionBuilders)  (QueryBuilders.java)",
      "children": [
        {
          "name": "Method public static FunctionScoreQueryBuilder functionScoreQuery(FunctionScoreQueryBuilder.FilterFunctionBuilder[] filterFunctionBuilders)  (QueryBuilders.java)"
        },
        {
          "name": "Method public static FunctionScoreQueryBuilder functionScoreQuery(QueryBuilder queryBuilder, ScoreFunctionBuilder function)  (QueryBuilders.java)"
        }
      ],
      "comment": "\n     * A query that allows to define a custom scoring function\n     *\n     * @param queryBuilder The query to custom score\n     * @param filterFunctionBuilders the filters and functions to execute\n     * @return the function score query\n     ",
      "vertexLabel": "FunctionScoreQueryBuilder functionScoreQuery()"
    },
    {
      "vertexName": "Method public final Searcher acquireSearcher(String source) throws EngineException  (Engine.java)",
      "comment": "\n     * Returns a new searcher instance. The consumer of this\n     * API is responsible for releasing the returned searcher in a\n     * safe manner, preferably in a try/finally block.\n     *\n     * @param source the source API or routing that triggers this searcher acquire\n     *\n     * @see Searcher#close()\n     ",
      "vertexLabel": "final Searcher acquireSearcher()"
    },
    {
      "vertexName": "Method public IndexRequest(String index, String type, String id)  (IndexRequest.java)",
      "comment": "\n     * Constructs a new index request against the index, type, id and using the source.\n     *\n     * @param index The index to index into\n     * @param type  The type to index into\n     * @param id    The id of document\n     ",
      "vertexLabel": "IndexRequest()"
    },
    {
      "vertexName": "Interface HostsResolver  (UnicastHostsProvider.java)",
      "comment": "\n     * Helper object that allows to resolve a list of hosts to a list of transport addresses.\n     * Each host is resolved into a transport address (or a collection of addresses if the\n     * number of ports is greater than one)\n     ",
      "vertexLabel": "Interface HostsResolver"
    },
    {
      "vertexName": "Method private Updates changes(Snapshot snapshot)  (RestoreService.java)",
      "children": [
        {
          "name": "Method private Updates changes(ShardId shardId)  (IndexMetaDataUpdater.java)"
        }
      ],
      "comment": "\n         * Helper method that creates update entry for the given shard id if such an entry does not exist yet.\n         ",
      "vertexLabel": "Updates changes()"
    },
    {
      "vertexName": "Class DeleteRepositoryRequest  (DeleteRepositoryRequest.java)",
      "children": [
        {
          "name": "Class VerifyRepositoryRequest  (VerifyRepositoryRequest.java)"
        }
      ],
      "comment": "\n * Unregister repository request.\n * <p>\n * The unregister repository command just unregisters the repository. No data is getting deleted from the repository.\n ",
      "vertexLabel": "Class DeleteRepositoryRequest"
    },
    {
      "vertexName": "Method void onFreeScrollContext(SearchContext context)  (SearchOperationListener.java)",
      "children": [
        {
          "name": "Method void onFreeContext(SearchContext context)  (SearchOperationListener.java)"
        }
      ],
      "comment": "\n     * Executed when a scroll search {@link SearchContext} is freed.\n     * This happens either when the scroll search execution finishes, if the\n     * execution failed or if the search context as idle for and needs to be\n     * cleaned up.\n     * @param context the freed search context\n     ",
      "vertexLabel": "void onFreeScrollContext()"
    },
    {
      "vertexName": "Method public MultiGetRequestBuilder setPreference(String preference)  (MultiGetRequestBuilder.java)",
      "children": [
        {
          "name": "Method public MultiGetRequest preference(String preference)  (MultiGetRequest.java)"
        }
      ],
      "comment": "\n     * Sets the preference to execute the search. Defaults to randomize across shards. Can be set to\n     * {@code _local} to prefer local shards or a custom value, which guarantees that the same order\n     * will be used across different requests.\n     ",
      "vertexLabel": "MultiGetRequestBuilder setPreference()"
    },
    {
      "vertexName": "Method public SortMode sortMode()  (GeoDistanceSortBuilder.java)",
      "comment": " Returns which distance to use for sorting in the case a document contains multiple geo points. ",
      "vertexLabel": "SortMode sortMode()"
    },
    {
      "vertexName": "Method public ByteArray newByteArray(long size, boolean clearOnResize)  (BigArrays.java)",
      "children": [
        {
          "name": "Method public IntArray newIntArray(long size, boolean clearOnResize)  (BigArrays.java)"
        }
      ],
      "comment": "\n     * Allocate a new {@link ByteArray}.\n     * @param size          the initial length of the array\n     * @param clearOnResize whether values should be set to 0 on initialization and resize\n     ",
      "vertexLabel": "ByteArray newByteArray()"
    },
    {
      "vertexName": "Method public void write(String str, int off, int len) throws IOException  (UTF8StreamWriter.java)",
      "comment": "\n     * Writes a portion of a string.\n     *\n     * @param str a String.\n     * @param off the offset from which to start writing characters.\n     * @param len the number of characters to write.\n     * @throws IOException if an I/O error occurs\n     ",
      "vertexLabel": "void write()"
    },
    {
      "vertexName": "Method public QueryStringQueryParser(QueryShardContext context, String defaultField, boolean lenient)  (QueryStringQueryParser.java)",
      "children": [
        {
          "name": "Method public QueryStringQueryParser(QueryShardContext context, String defaultField)  (QueryStringQueryParser.java)"
        }
      ],
      "comment": "\n     * @param context The query shard context.\n     * @param defaultField The default field for query terms.\n     * @param lenient If set to `true` will cause format based failures (like providing text to a numeric field) to be ignored.\n     ",
      "vertexLabel": "QueryStringQueryParser()"
    },
    {
      "vertexName": "Method public Long precisionThreshold()  (CardinalityAggregationBuilder.java)",
      "children": [
        {
          "name": "Method public CardinalityAggregationBuilder precisionThreshold(long precisionThreshold)  (CardinalityAggregationBuilder.java)"
        }
      ],
      "comment": "\n     * Get the precision threshold. Higher values improve accuracy but also\n     * increase memory usage. Will return <code>null</code> if the\n     * precisionThreshold has not been set yet.\n     ",
      "vertexLabel": "Long precisionThreshold()"
    },
    {
      "vertexName": "Method public IndicesAliasesRequestBuilder addAlias(String[] indices, String alias, String filter)  (IndicesAliasesRequestBuilder.java)",
      "children": [
        {
          "name": "Method public IndicesAliasesRequestBuilder addAlias(String index, String alias, Map<String, Object> filter)  (IndicesAliasesRequestBuilder.java)"
        }
      ],
      "comment": "\n     * Adds an alias to the index.\n     *\n     * @param indices The indices\n     * @param alias   The alias\n     * @param filter  The filter\n     ",
      "vertexLabel": "IndicesAliasesRequestBuilder addAlias()"
    },
    {
      "vertexName": "Method public Builder setFuzziness(int editDistance)  (FuzzyOptions.java)",
      "comment": "\n         * Sets the level of fuzziness used to create suggestions using a {@link Fuzziness} instance.\n         * The default value is {@link Fuzziness#ONE} which allows for an \"edit distance\" of one.\n         ",
      "vertexLabel": "Builder setFuzziness()"
    },
    {
      "vertexName": "Class ArraySearchPhaseResults  (InitialSearchPhase.java)",
      "children": [
        {
          "name": "Class SearchPhaseResults  (InitialSearchPhase.java)"
        }
      ],
      "comment": "\n     * This class acts as a basic result collection that can be extended to do on-the-fly reduction or result processing\n     ",
      "vertexLabel": "Class ArraySearchPhaseResults"
    },
    {
      "vertexName": "Method void validate(final String key, final Settings settings, final boolean validateDependencies, final boolean validateInternalOrPrivateIndex)  (AbstractScopedSettings.java)",
      "children": [
        {
          "name": "Method public final void validate(final Settings settings, final boolean validateDependencies, final boolean validateInternalOrPrivateIndex)  (AbstractScopedSettings.java)"
        },
        {
          "name": "Method void validate(final String key, final Settings settings, final boolean validateDependencies)  (AbstractScopedSettings.java)"
        }
      ],
      "comment": "\n     * Validates that the settings is valid.\n     *\n     * @param key                            the key of the setting to validate\n     * @param settings                       the settings\n     * @param validateDependencies           true if dependent settings should be validated\n     * @param validateInternalOrPrivateIndex true if internal index settings should be validated\n     * @throws IllegalArgumentException if the setting is invalid\n     ",
      "vertexLabel": "void validate()"
    },
    {
      "vertexName": "Method public RestoreSnapshotRequest partial(boolean partial)  (RestoreSnapshotRequest.java)",
      "children": [
        {
          "name": "Method public boolean partial()  (RestoreSnapshotRequest.java)"
        }
      ],
      "comment": "\n     * Set to true to allow indices with failed to snapshot shards should be partially restored.\n     *\n     * @param partial true if indices with failed to snapshot shards should be partially restored.\n     * @return this request\n     ",
      "vertexLabel": "RestoreSnapshotRequest partial()"
    },
    {
      "vertexName": "Method public IndicesOptions indicesOptions()  (CreateSnapshotRequest.java)",
      "comment": "\n     * Specifies the indices options. Like what type of requested indices to ignore. For example indices that don't exist.\n     *\n     * @return the desired behaviour regarding indices options\n     ",
      "vertexLabel": "IndicesOptions indicesOptions()"
    },
    {
      "vertexName": "Method public OpenIndexRequest indices(String... indices)  (OpenIndexRequest.java)",
      "comment": "\n     * Sets the indices to be opened\n     * @param indices the indices to be opened\n     * @return the request itself\n     ",
      "vertexLabel": "OpenIndexRequest indices()"
    },
    {
      "vertexName": "Method public static SearchScrollRequest searchScrollRequest(String scrollId)  (Requests.java)",
      "children": [
        {
          "name": "Method void searchScroll(SearchScrollRequest request, ActionListener<SearchResponse> listener)  (Client.java)"
        }
      ],
      "comment": "\n     * Creates a search scroll request allowing to continue searching a previous search request.\n     *\n     * @param scrollId The scroll id representing the scrollable search\n     * @return The search scroll request\n     * @see org.elasticsearch.client.Client#searchScroll(org.elasticsearch.action.search.SearchScrollRequest)\n     ",
      "vertexLabel": "SearchScrollRequest searchScrollRequest()"
    },
    {
      "vertexName": "Method public static String readStringProperty(String processorType, String processorTag, Map<String, Object> configuration, String propertyName, String defaultValue)  (ConfigurationUtils.java)",
      "children": [
        {
          "name": "Method public static String readStringProperty(String processorType, String processorTag, Map<String, Object> configuration, String propertyName)  (ConfigurationUtils.java)"
        }
      ],
      "comment": "\n     * Returns and removes the specified property from the specified configuration map.\n     *\n     * If the property value isn't of type string a {@link ElasticsearchParseException} is thrown.\n     * If the property is missing and no default value has been specified a {@link ElasticsearchParseException} is thrown\n     ",
      "vertexLabel": "String readStringProperty()"
    },
    {
      "vertexName": "Method public static Injector createInjector(Module... modules)  (Guice.java)",
      "children": [
        {
          "name": "Method public static Injector createInjector(Iterable<? extends Module> modules)  (Guice.java)"
        }
      ],
      "comment": "\n     * Creates an injector for the given set of modules.\n     *\n     * @throws CreationException if one or more errors occur during Injector\n     *                           construction\n     ",
      "vertexLabel": "Injector createInjector()"
    },
    {
      "vertexName": "Class StaticInjectionRequest  (StaticInjectionRequest.java)",
      "children": [
        {
          "name": "Class InjectionRequest  (InjectionRequest.java)"
        }
      ],
      "comment": "\n * A request to inject the static fields and methods of a type. Requests are created\n * explicitly in a module using {@link org.elasticsearch.common.inject.Binder#requestStaticInjection(Class[])\n * requestStaticInjection()} statements:\n * <pre>\n *     requestStaticInjection(MyLegacyService.class);</pre>\n *\n * @author jessewilson@google.com (Jesse Wilson)\n * @since 2.0\n ",
      "vertexLabel": "Class StaticInjectionRequest"
    },
    {
      "vertexName": "Method public RestoreSnapshotRequest renameReplacement(String renameReplacement)  (RestoreSnapshotRequest.java)",
      "comment": "\n     * Sets rename replacement\n     * <p>\n     * See {@link #renamePattern(String)} for more information.\n     *\n     * @param renameReplacement rename replacement\n     ",
      "vertexLabel": "RestoreSnapshotRequest renameReplacement()"
    },
    {
      "vertexName": "Method public boolean ensureSynced(Location location) throws IOException  (Translog.java)",
      "comment": "\n     * Ensures that the given location has be synced / written to the underlying storage.\n     *\n     * @return Returns <code>true</code> iff this call caused an actual sync operation otherwise <code>false</code>\n     ",
      "vertexLabel": "boolean ensureSynced()"
    },
    {
      "vertexName": "Method protected abstract WriteReplicaResult<ReplicaRequest> shardOperationOnReplica(ReplicaRequest request, IndexShard replica) throws Exception  (TransportWriteAction.java)",
      "children": [
        {
          "name": "Method protected abstract WritePrimaryResult<ReplicaRequest, Response> shardOperationOnPrimary(Request request, IndexShard primary) throws Exception  (TransportWriteAction.java)"
        }
      ],
      "comment": "\n     * Called once per replica with a reference to the replica {@linkplain IndexShard} to modify.\n     *\n     * @return the result of the operation on replica, including current translog location and operation response and failure\n     * async refresh is performed on the <code>replica</code> shard according to the <code>ReplicaRequest</code> refresh policy\n     ",
      "vertexLabel": "abstract WriteReplicaResult<ReplicaRequest> shardOperationOnReplica()"
    },
    {
      "vertexName": "Method public abstract DeleteResult delete(Delete delete) throws IOException  (Engine.java)",
      "children": [
        {
          "name": "Method public abstract IndexResult index(Index index) throws IOException  (Engine.java)"
        }
      ],
      "comment": "\n     * Perform document delete operation on the engine\n     * @param delete operation to perform\n     * @return {@link DeleteResult} containing updated translog location, version and\n     * document specific failures\n     *\n     * Note: engine level failures (i.e. persistent engine failures) are thrown\n     ",
      "vertexLabel": "abstract DeleteResult delete()"
    },
    {
      "vertexName": "Method public CommonStatsFlags groups(String... groups)  (CommonStatsFlags.java)",
      "comment": "\n     * Sets specific search group stats to retrieve the stats for. Mainly affects search\n     * when enabled.\n     ",
      "vertexLabel": "CommonStatsFlags groups()"
    },
    {
      "vertexName": "Method public static QueryStringQueryBuilder queryStringQuery(String queryString)  (QueryBuilders.java)",
      "children": [
        {
          "name": "Class QueryStringQueryBuilder  (QueryStringQueryBuilder.java)"
        }
      ],
      "comment": "\n     * A query that parses a query string and runs it. There are two modes that this operates. The first,\n     * when no field is added (using {@link QueryStringQueryBuilder#field(String)}, will run the query once and non prefixed fields\n     * will use the {@link QueryStringQueryBuilder#defaultField(String)} set. The second, when one or more fields are added\n     * (using {@link QueryStringQueryBuilder#field(String)}), will run the parsed query against the provided fields, and combine\n     * them either using Dismax.\n     *\n     * @param queryString The query string to run\n     ",
      "vertexLabel": "QueryStringQueryBuilder queryStringQuery()"
    },
    {
      "vertexName": "Method public String routing()  (ClusterSearchShardsRequest.java)",
      "children": [
        {
          "name": "Method public SearchRequestBuilder setRouting(String routing)  (SearchRequestBuilder.java)"
        }
      ],
      "comment": "\n     * A comma separated list of routing values to control the shards the search will be executed on.\n     ",
      "vertexLabel": "String routing()"
    },
    {
      "vertexName": "Method public PutIndexTemplateRequestBuilder setCreate(boolean create)  (PutIndexTemplateRequestBuilder.java)",
      "children": [
        {
          "name": "Method public PutIndexTemplateRequest create(boolean create)  (PutIndexTemplateRequest.java)"
        }
      ],
      "comment": "\n     * Set to {@code true} to force only creation, not an update of an index template. If it already\n     * exists, it will fail with an {@link IllegalArgumentException}.\n     ",
      "vertexLabel": "PutIndexTemplateRequestBuilder setCreate()"
    },
    {
      "vertexName": "Method public final void onModule(RepositoriesModule module)  (Plugin.java)",
      "children": [
        {
          "name": "Method public final void onModule(NetworkModule module)  (Plugin.java)"
        }
      ],
      "comment": "\n     * Old-style snapshot/restore extension point. {@code @Deprecated} and {@code final} to act as a signpost for plugin authors upgrading\n     * from 2.x.\n     *\n     * @deprecated implement {@link RepositoryPlugin} instead\n     ",
      "vertexLabel": "final void onModule()"
    },
    {
      "vertexName": "Method public BulkRequestBuilder add(IndexRequest request)  (BulkRequestBuilder.java)",
      "children": [
        {
          "name": "Method public BulkProcessor add(IndexRequest request)  (BulkProcessor.java)"
        }
      ],
      "comment": "\n     * Adds an {@link IndexRequest} to the list of actions to execute. Follows the same behavior of {@link IndexRequest}\n     * (for example, if no id is provided, one will be generated, or usage of the create flag).\n     ",
      "vertexLabel": "BulkRequestBuilder add()"
    },
    {
      "vertexName": "Method public abstract IndexResult index(Index index) throws IOException  (Engine.java)",
      "comment": "\n     * Perform document index operation on the engine\n     * @param index operation to perform\n     * @return {@link IndexResult} containing updated translog location, version and\n     * document specific failures\n     *\n     * Note: engine level failures (i.e. persistent engine failures) are thrown\n     ",
      "vertexLabel": "abstract IndexResult index()"
    },
    {
      "vertexName": "Interface Streamable  (Streamable.java)",
      "children": [
        {
          "name": "Interface Writeable  (Writeable.java)"
        }
      ],
      "comment": "\n * Implementers can be written to a {@linkplain StreamOutput} and read from a {@linkplain StreamInput}. This allows them to be \"thrown\n * across the wire\" using Elasticsearch's internal protocol. If the implementer also implements equals and hashCode then a copy made by\n * serializing and deserializing must be equal and have the same hashCode. It isn't required that such a copy be entirely unchanged.\n *\n * Prefer implementing {@link Writeable} over implementing this interface where possible. Lots of code depends on this interface so this\n * isn't always possible.\n *\n * Implementers of this interface almost always declare a no arg constructor that is exclusively used for creating \"empty\" objects on which\n * you then call {@link #readFrom(StreamInput)}. Because {@linkplain #readFrom(StreamInput)} isn't part of the constructor the fields\n * on implementers cannot be final. It is these reasons that this interface has fallen out of favor compared to {@linkplain Writeable}.\n ",
      "vertexLabel": "Interface Streamable"
    },
    {
      "vertexName": "Method Durability getDurability()  (CircuitBreaker.java)",
      "children": [
        {
          "name": "Method public Durability getDurability()  (ChildMemoryCircuitBreaker.java)"
        }
      ],
      "comment": "\n     * @return whether a tripped circuit breaker will reset itself (transient) or requires manual intervention (permanent).\n     ",
      "vertexLabel": "Durability getDurability()"
    },
    {
      "vertexName": "Class AggregationProfileShardResult  (AggregationProfileShardResult.java)",
      "comment": "\n * A container class to hold the profile results for a single shard in the request.\n * Contains a list of query profiles, a collector tree and a total rewrite tree.\n ",
      "vertexLabel": "Class AggregationProfileShardResult"
    },
    {
      "vertexName": "Method public static TermsQueryBuilder termsQuery(String name, String... values)  (QueryBuilders.java)",
      "comment": "\n     * A filer for a field based on several terms matching on any of them.\n     *\n     * @param name   The field name\n     * @param values The terms\n     ",
      "vertexLabel": "TermsQueryBuilder termsQuery()"
    },
    {
      "vertexName": "Method public CircleBuilder radius(double radius, String unit)  (CircleBuilder.java)",
      "children": [
        {
          "name": "Method public CircleBuilder radius(double radius, DistanceUnit unit)  (CircleBuilder.java)"
        }
      ],
      "comment": "\n     * Set the radius of the circle\n     * @param radius value of the circles radius\n     * @param unit unit name of the radius value (see {@link DistanceUnit})\n     * @return this\n     ",
      "vertexLabel": "CircleBuilder radius()"
    },
    {
      "vertexName": "Method static void check(final BootstrapContext context, final boolean enforceLimits, final List<BootstrapCheck> checks, final Logger logger) throws NodeValidationException  (BootstrapChecks.java)",
      "children": [
        {
          "name": "Method static void check(final BootstrapContext context, final boolean enforceLimits, final List<BootstrapCheck> checks) throws NodeValidationException  (BootstrapChecks.java)"
        }
      ],
      "comment": "\n     * Executes the provided checks and fails the node if {@code enforceLimits} is {@code true}, otherwise logs warnings. If the system\n     * property {@code es.enforce.bootstrap.checks }is set to {@code true} then the bootstrap checks will be enforced regardless of whether\n     * or not the transport protocol is bound to a non-loopback interface.\n     *\n     * @param context the current node boostrap context\n     * @param enforceLimits {@code true} if the checks should be enforced or otherwise warned\n     * @param checks        the checks to execute\n     * @param logger        the logger to\n     ",
      "vertexLabel": "void check()"
    },
    {
      "vertexName": "Method public RestoreSnapshotRequestBuilder setSettings(Settings settings)  (RestoreSnapshotRequestBuilder.java)",
      "children": [
        {
          "name": "Method public RestoreSnapshotRequest settings(Settings settings)  (RestoreSnapshotRequest.java)"
        }
      ],
      "comment": "\n     * Sets repository-specific restore settings.\n     * <p>\n     * See repository documentation for more information.\n     *\n     * @param settings repository-specific snapshot settings\n     * @return this builder\n     ",
      "vertexLabel": "RestoreSnapshotRequestBuilder setSettings()"
    },
    {
      "vertexName": "Method public SearchRequestBuilder addIndexBoost(String index, float indexBoost)  (SearchRequestBuilder.java)",
      "comment": "\n     * Sets the boost a specific index will receive when the query is executed against it.\n     *\n     * @param index      The index to apply the boost against\n     * @param indexBoost The boost to apply to the index\n     ",
      "vertexLabel": "SearchRequestBuilder addIndexBoost()"
    },
    {
      "vertexName": "Method public SnapshotsStatusRequestBuilder setSnapshots(String... snapshots)  (SnapshotsStatusRequestBuilder.java)",
      "children": [
        {
          "name": "Method public GetSnapshotsRequestBuilder setSnapshots(String... snapshots)  (GetSnapshotsRequestBuilder.java)"
        }
      ],
      "comment": "\n     * Sets list of snapshots to return\n     *\n     * @param snapshots list of snapshots\n     * @return this builder\n     ",
      "vertexLabel": "SnapshotsStatusRequestBuilder setSnapshots()"
    },
    {
      "vertexName": "Method public ShardRestoreStatus(String nodeId)  (RestoreInProgress.java)",
      "comment": "\n         * Constructs a new shard restore status in initializing state on the given node\n         *\n         * @param nodeId node id\n         ",
      "vertexLabel": "ShardRestoreStatus()"
    },
    {
      "vertexName": "Method public boolean add(T t)  (EvictingQueue.java)",
      "comment": "\n     * Add the given element to the queue, possibly forcing an eviction from the head if {@link #remainingCapacity()} is\n     * zero.\n     *\n     * @param t the element to add\n     * @return true if the element was added (always the case for {@code EvictingQueue}\n     ",
      "vertexLabel": "boolean add()"
    },
    {
      "vertexName": "Method CompoundOrder(List<BucketOrder> compoundOrder, boolean absoluteOrdering)  (InternalOrder.java)",
      "children": [
        {
          "name": "Method CompoundOrder(List<BucketOrder> compoundOrder)  (InternalOrder.java)"
        },
        {
          "name": "Method CompoundOrderComparator(List<BucketOrder> compoundOrder, Aggregator aggregator)  (InternalOrder.java)"
        }
      ],
      "comment": "\n         * Create a new ordering strategy to sort by multiple criteria.\n         *\n         * @param compoundOrder    a list of {@link BucketOrder}s to sort on, in order of priority.\n         * @param absoluteOrdering {@code true} to add a tie-breaker to avoid non-deterministic ordering if needed,\n         *                         {@code false} otherwise.\n         ",
      "vertexLabel": "CompoundOrder()"
    },
    {
      "vertexName": "Method public DirectCandidateGeneratorBuilder stringDistance(String stringDistance)  (DirectCandidateGeneratorBuilder.java)",
      "children": [
        {
          "name": "EnumConstant INTERNAL  (TermSuggestionBuilder.java)"
        }
      ],
      "comment": "\n     * Sets what string distance implementation to use for comparing how\n     * similar suggested terms are. Four possible values can be specified:\n     * <ol>\n     * <li><code>internal</code> - This is the default and is based on\n     * <code>damerau_levenshtein</code>, but highly optimized for comparing\n     * string distance for terms inside the index.\n     * <li><code>damerau_levenshtein</code> - String distance algorithm\n     * based on Damerau-Levenshtein algorithm.\n     * <li><code>levenshtein</code> - String distance algorithm based on\n     * Levenshtein edit distance algorithm.\n     * <li><code>jaro_winkler</code> - String distance algorithm based on\n     * Jaro-Winkler algorithm.\n     * <li><code>ngram</code> - String distance algorithm based on character\n     * n-grams.\n     * </ol>\n     ",
      "vertexLabel": "DirectCandidateGeneratorBuilder stringDistance()"
    },
    {
      "vertexName": "Class SortedNumericLongFieldData  (SortedNumericDVIndexFieldData.java)",
      "comment": "\n     * FieldData implementation for integral types.\n     * <p>\n     * Order of values within a document is consistent with\n     * {@link Long#compareTo(Long)}.\n     * <p>\n     * Although the API is multi-valued, most codecs in Lucene specialize\n     * for the case where documents have at most one value. In this case\n     * {@link DocValues#unwrapSingleton(SortedNumericDocValues)} will return\n     * the underlying single-valued NumericDocValues representation.\n     ",
      "vertexLabel": "Class SortedNumericLongFieldData"
    },
    {
      "vertexName": "Method public String[] types()  (IndicesStatsRequest.java)",
      "children": [
        {
          "name": "Method public IndicesStatsRequest types(String... types)  (IndicesStatsRequest.java)"
        }
      ],
      "comment": "\n     * Document types to return stats for. Mainly affects {@link #indexing(boolean)} when\n     * enabled, returning specific indexing stats for those types.\n     ",
      "vertexLabel": "String[] types()"
    },
    {
      "vertexName": "Method public UpdateRequest script(String script, ScriptType scriptType)  (UpdateRequest.java)",
      "children": [
        {
          "name": "Method public UpdateRequest script(Script script)  (UpdateRequest.java)"
        }
      ],
      "comment": "\n     * The script to execute. Note, make sure not to send different script each\n     * times and instead use script params if possible with the same\n     * (automatically compiled) script.\n     *\n     * @deprecated Use {@link #script(Script)} instead\n     ",
      "vertexLabel": "UpdateRequest script()"
    },
    {
      "vertexName": "Class SortedNumericHalfFloatFieldData  (SortedNumericDVIndexFieldData.java)",
      "children": [
        {
          "name": "Class SortedNumericLongFieldData  (SortedNumericDVIndexFieldData.java)"
        }
      ],
      "comment": "\n     * FieldData implementation for 16-bit float values.\n     * <p>\n     * Order of values within a document is consistent with\n     * {@link Float#compareTo(Float)}, hence the following reversible\n     * transformation is applied at both index and search:\n     * {@code bits ^ (bits >> 15) & 0x7fff}\n     * <p>\n     * Although the API is multi-valued, most codecs in Lucene specialize\n     * for the case where documents have at most one value. In this case\n     * {@link FieldData#unwrapSingleton(SortedNumericDoubleValues)} will return\n     * the underlying single-valued NumericDoubleValues representation.\n     ",
      "vertexLabel": "Class SortedNumericHalfFloatFieldData"
    },
    {
      "vertexName": "Method public HoltWintersModelBuilder alpha(double alpha)  (HoltWintersModel.java)",
      "children": [
        {
          "name": "Method public EWMAModelBuilder alpha(double alpha)  (EwmaModel.java)"
        }
      ],
      "comment": "\n         * Alpha controls the smoothing of the data.  Alpha = 1 retains no memory of past values\n         * (e.g. a random walk), while alpha = 0 retains infinite memory of past values (e.g.\n         * the series mean).  Useful values are somewhere in between.  Defaults to 0.5.\n         *\n         * @param alpha A double between 0-1 inclusive, controls data smoothing\n         *\n         * @return The builder to continue chaining\n         ",
      "vertexLabel": "HoltWintersModelBuilder alpha()"
    },
    {
      "vertexName": "Method MembersInjector<T> getMembersInjector(TypeLiteral<T> typeLiteral)  (Binder.java)",
      "children": [
        {
          "name": "Method MembersInjector<T> getMembersInjector(TypeLiteral<T> typeLiteral)  (TypeEncounter.java)"
        }
      ],
      "comment": "\n     * Returns the members injector used to inject dependencies into methods and fields on instances\n     * of the given type {@code T}. The returned members injector will not be valid until the main\n     * {@link Injector} has been created. The members injector will throw an {@code\n     * IllegalStateException} if you try to use it beforehand.\n     *\n     * @param typeLiteral type to get members injector for\n     * @since 2.0\n     ",
      "vertexLabel": "MembersInjector<T> getMembersInjector()"
    },
    {
      "vertexName": "Method public static int readFromFileChannel(FileChannel channel, long channelPosition, ByteBuffer dest) throws IOException  (Channels.java)",
      "children": [
        {
          "name": "Method public static void readFromFileChannelWithEofException(FileChannel channel, long channelPosition, ByteBuffer dest) throws IOException  (Channels.java)"
        }
      ],
      "comment": "\n     * read from a file channel into a byte buffer, starting at a certain position.\n     *\n     * @param channel         channel to read from\n     * @param channelPosition position to read from\n     * @param dest            destination {@link java.nio.ByteBuffer} to put data in\n     * @return total bytes read or -1 if an attempt was made to read past EOF. The method always tries to read all the bytes\n     * that will fit in the destination byte buffer.\n     ",
      "vertexLabel": "int readFromFileChannel()"
    },
    {
      "vertexName": "Method public IntArray newIntArray(long size, boolean clearOnResize)  (BigArrays.java)",
      "comment": "\n     * Allocate a new {@link IntArray}.\n     * @param size          the initial length of the array\n     * @param clearOnResize whether values should be set to 0 on initialization and resize\n     ",
      "vertexLabel": "IntArray newIntArray()"
    },
    {
      "vertexName": "Method public static int quadTreeLevelsForPrecision(String distance)  (GeoUtils.java)",
      "children": [
        {
          "name": "Method public static int geoHashLevelsForPrecision(String distance)  (GeoUtils.java)"
        }
      ],
      "comment": "\n     * Calculate the number of levels needed for a specific precision. QuadTree\n     * cells will not exceed the specified size (diagonal) of the precision.\n     * @param distance Maximum size of cells as unit string (must greater or equal to zero)\n     * @return levels need to achieve precision\n     ",
      "vertexLabel": "int quadTreeLevelsForPrecision()"
    },
    {
      "vertexName": "Method ActionFuture<AcknowledgedResponse> delete(DeleteIndexRequest request)  (IndicesAdminClient.java)",
      "children": [
        {
          "name": "Method ActionFuture<AcknowledgedResponse> close(CloseIndexRequest request)  (IndicesAdminClient.java)"
        }
      ],
      "comment": "\n     * Deletes an index based on the index name.\n     *\n     * @param request The delete index request\n     * @return The result future\n     * @see org.elasticsearch.client.Requests#deleteIndexRequest(String)\n     ",
      "vertexLabel": "ActionFuture<AcknowledgedResponse> delete()"
    },
    {
      "vertexName": "Method public GetSnapshotsRequest(String repository, String[] snapshots)  (GetSnapshotsRequest.java)",
      "comment": "\n     * Constructs a new get snapshots request with given repository name and list of snapshots\n     *\n     * @param repository repository name\n     * @param snapshots  list of snapshots\n     ",
      "vertexLabel": "GetSnapshotsRequest()"
    },
    {
      "vertexName": "Method public PutRepositoryRequestBuilder setSettings(String source, XContentType xContentType)  (PutRepositoryRequestBuilder.java)",
      "comment": "\n     * Sets the repository settings in Json or Yaml format\n     *\n     * @param source repository settings\n     * @param xContentType the content type of the source\n     * @return this builder\n     ",
      "vertexLabel": "PutRepositoryRequestBuilder setSettings()"
    },
    {
      "vertexName": "Method public InternalOrder(byte id, String key, boolean asc, Comparator<Bucket> comparator)  (InternalOrder.java)",
      "children": [
        {
          "name": "Method Aggregation(String path, boolean asc)  (InternalOrder.java)"
        }
      ],
      "comment": "\n     * Creates an ordering strategy that sorts {@link Bucket}s by some property.\n     *\n     * @param id         unique ID for this ordering strategy.\n     * @param key        key of the property to sort on.\n     * @param asc        direction to sort by: {@code true} for ascending, {@code false} for descending.\n     * @param comparator determines how buckets will be ordered.\n     ",
      "vertexLabel": "InternalOrder()"
    },
    {
      "vertexName": "Method public final String getRaw(final Settings settings)  (Setting.java)",
      "children": [
        {
          "name": "Method public T get(Settings settings)  (Setting.java)"
        }
      ],
      "comment": "\n     * Returns the raw (string) settings value. If the setting is not present in the given settings object the default value is returned\n     * instead. This is useful if the value can't be parsed due to an invalid value to access the actual value.\n     ",
      "vertexLabel": "final String getRaw()"
    },
    {
      "vertexName": "Method public float getRequestsPerSecond()  (AbstractBulkByScrollRequest.java)",
      "children": [
        {
          "name": "Field requestsPerSecond  (AbstractBulkByScrollRequest.java)"
        }
      ],
      "comment": "\n     * The throttle for this request in sub-requests per second. {@link Float#POSITIVE_INFINITY} means set no throttle and that is the\n     * default. Throttling is done between batches, as we start the next scroll requests. That way we can increase the scroll's timeout to\n     * make sure that it contains any time that we might wait.\n     ",
      "vertexLabel": "float getRequestsPerSecond()"
    },
    {
      "vertexName": "Method public SearchRequestBuilder addDocValueField(String name, String format)  (SearchRequestBuilder.java)",
      "comment": "\n     * Adds a docvalue based field to load and return. The field does not have to be stored,\n     * but its recommended to use non analyzed or numeric fields.\n     *\n     * @param name The field to get from the docvalue\n     ",
      "vertexLabel": "SearchRequestBuilder addDocValueField()"
    },
    {
      "vertexName": "Method public QueryStringQueryBuilder fuzzyTranspositions(boolean fuzzyTranspositions)  (QueryStringQueryBuilder.java)",
      "children": [
        {
          "name": "Method public MatchQueryBuilder fuzzyTranspositions(boolean fuzzyTranspositions)  (MatchQueryBuilder.java)"
        }
      ],
      "comment": "\n     * Sets whether transpositions are supported in fuzzy queries.<p>\n     * The default metric used by fuzzy queries to determine a match is the Damerau-Levenshtein\n     * distance formula which supports transpositions. Setting transposition to false will\n     * switch to classic Levenshtein distance.<br>\n     * If not set, Damerau-Levenshtein distance metric will be used.\n     ",
      "vertexLabel": "QueryStringQueryBuilder fuzzyTranspositions()"
    },
    {
      "vertexName": "Class BigLongArray  (BigLongArray.java)",
      "children": [
        {
          "name": "Class BigByteArray  (BigByteArray.java)"
        }
      ],
      "comment": "\n * Long array abstraction able to support more than 2B values. This implementation slices data into fixed-sized blocks of\n * configurable length.\n ",
      "vertexLabel": "Class BigLongArray"
    },
    {
      "vertexName": "Method static String getShortPathName(final String path)  (Natives.java)",
      "children": [
        {
          "name": "Method static String getShortPathName(String path)  (JNANatives.java)"
        }
      ],
      "comment": "\n     * Retrieves the short path form of the specified path.\n     *\n     * @param path the path\n     * @return the short path name (or the original path if getting the short path name fails for any reason)\n     ",
      "vertexLabel": "String getShortPathName()"
    },
    {
      "vertexName": "Method public HistogramAggregationBuilder keyed(boolean keyed)  (HistogramAggregationBuilder.java)",
      "children": [
        {
          "name": "Method public DateHistogramAggregationBuilder keyed(boolean keyed)  (DateHistogramAggregationBuilder.java)"
        }
      ],
      "comment": " Set whether to return buckets as a hash or as an array, and return the\n     *  builder so that calls can be chained. ",
      "vertexLabel": "HistogramAggregationBuilder keyed()"
    },
    {
      "vertexName": "Method public CreateSnapshotRequest(String repository, String snapshot)  (CreateSnapshotRequest.java)",
      "comment": "\n     * Constructs a new put repository request with the provided snapshot and repository names\n     *\n     * @param repository repository name\n     * @param snapshot   snapshot name\n     ",
      "vertexLabel": "CreateSnapshotRequest()"
    },
    {
      "vertexName": "Method public static BoostingQueryBuilder boostingQuery(QueryBuilder positiveQuery, QueryBuilder negativeQuery)  (QueryBuilders.java)",
      "comment": "\n     * The BoostingQuery class can be used to effectively demote results that match a given query.\n     * Unlike the \"NOT\" clause, this still selects documents that contain undesirable terms,\n     * but reduces their overall score:\n     ",
      "vertexLabel": "BoostingQueryBuilder boostingQuery()"
    },
    {
      "vertexName": "Method public Task executeLocally(Action<Response> action, Request request, TaskListener<Response> listener)  (NodeClient.java)",
      "comment": "\n     * Execute an {@link Action} locally, returning that {@link Task} used to track it, and linking an {@link TaskListener}. Prefer this\n     * method if you need access to the task when listening for the response.\n     ",
      "vertexLabel": "Task executeLocally()"
    },
    {
      "vertexName": "Method public SearchExtensionSpec(ParseField name, Writeable.Reader<? extends W> reader, P parser)  (SearchPlugin.java)",
      "children": [
        {
          "name": "Method public SearchExtensionSpec(String name, Writeable.Reader<? extends W> reader, P parser)  (SearchPlugin.java)"
        }
      ],
      "comment": "\n         * Build the spec with a {@linkplain ParseField}.\n         *\n         * @param name the name of the behavior as a {@linkplain ParseField}. The parser is registered under all names specified by the\n         *        {@linkplain ParseField} but the reader is only registered under the {@link ParseField#getPreferredName()} so be sure that\n         *        that is the name that W's {@link NamedWriteable#getWriteableName()} returns.\n         * @param reader reader that reads the behavior from the internode protocol\n         * @param parser parser that read the behavior from a REST request\n         ",
      "vertexLabel": "SearchExtensionSpec()"
    },
    {
      "vertexName": "Method public SimpleQueryStringQueryParser(Analyzer analyzer, Map<String, Float> weights, int flags, Settings settings, QueryShardContext context)  (SimpleQueryStringQueryParser.java)",
      "children": [
        {
          "name": "Method public SimpleQueryStringQueryParser(Map<String, Float> weights, int flags, Settings settings, QueryShardContext context)  (SimpleQueryStringQueryParser.java)"
        }
      ],
      "comment": " Creates a new parser with custom flags used to enable/disable certain features. ",
      "vertexLabel": "SimpleQueryStringQueryParser()"
    },
    {
      "vertexName": "Method public DiscoveryNode get(String nodeId)  (DiscoveryNodes.java)",
      "children": [
        {
          "name": "Method public DiscoveryNode get(String nodeId)  (DiscoveryNodes.java)"
        }
      ],
      "comment": "\n         * Get a node by its id\n         *\n         * @param nodeId id of the wanted node\n         * @return wanted node if it exists. Otherwise <code>null</code>\n         ",
      "vertexLabel": "DiscoveryNode get()"
    },
    {
      "vertexName": "Method public static String readOptionalStringOrIntProperty(String processorType, String processorTag, Map<String, Object> configuration, String propertyName)  (ConfigurationUtils.java)",
      "comment": "\n     * Returns and removes the specified property from the specified configuration map.\n     *\n     * If the property value isn't of type string or int a {@link ElasticsearchParseException} is thrown.\n     ",
      "vertexLabel": "String readOptionalStringOrIntProperty()"
    },
    {
      "vertexName": "Method public Aggregator resolveAggregator(Aggregator root)  (AggregationPath.java)",
      "children": [
        {
          "name": "Method public Aggregator resolveTopmostAggregator(Aggregator root)  (AggregationPath.java)"
        }
      ],
      "comment": "\n     * Resolves the aggregator pointed by this path using the given root as a point of reference.\n     *\n     * @param root      The point of reference of this path\n     * @return          The aggregator pointed by this path starting from the given aggregator as a point of reference\n     ",
      "vertexLabel": "Aggregator resolveAggregator()"
    },
    {
      "vertexName": "Method public static BucketOrder key(boolean asc)  (BucketOrder.java)",
      "children": [
        {
          "name": "Method public static BucketOrder count(boolean asc)  (BucketOrder.java)"
        }
      ],
      "comment": "\n     * Creates a bucket ordering strategy that sorts buckets by their keys (ascending or descending). This may be\n     * used as a tie-breaker to avoid non-deterministic ordering.\n     *\n     * @param asc direction to sort by: {@code true} for ascending, {@code false} for descending.\n     ",
      "vertexLabel": "BucketOrder key()"
    },
    {
      "vertexName": "Method public UpdateRequestBuilder setUpsert(XContentType xContentType, Object... source)  (UpdateRequestBuilder.java)",
      "children": [
        {
          "name": "Method public UpdateRequest upsert(Object... source)  (UpdateRequest.java)"
        }
      ],
      "comment": "\n     * Sets the doc source of the update request to be used when the document does not exists. The doc\n     * includes field and value pairs.\n     ",
      "vertexLabel": "UpdateRequestBuilder setUpsert()"
    },
    {
      "vertexName": "Method public ClusterHealthRequest waitForNoRelocatingShards(boolean waitForNoRelocatingShards)  (ClusterHealthRequest.java)",
      "comment": "\n     * Sets whether the request should wait for there to be no relocating shards before\n     * retrieving the cluster health status.  Defaults to {@code false}, meaning the\n     * operation does not wait on there being no more relocating shards.  Set to <code>true</code>\n     * to wait until the number of relocating shards in the cluster is 0.\n     ",
      "vertexLabel": "ClusterHealthRequest waitForNoRelocatingShards()"
    },
    {
      "vertexName": "Method public void validateAliasFilter(String alias, byte[] filter, QueryShardContext queryShardContext, NamedXContentRegistry xContentRegistry)  (AliasValidator.java)",
      "children": [
        {
          "name": "Method public void validateAliasFilter(String alias, String filter, QueryShardContext queryShardContext, NamedXContentRegistry xContentRegistry)  (AliasValidator.java)"
        }
      ],
      "comment": "\n     * Validates an alias filter by parsing it using the\n     * provided {@link org.elasticsearch.index.query.QueryShardContext}\n     * @throws IllegalArgumentException if the filter is not valid\n     ",
      "vertexLabel": "void validateAliasFilter()"
    },
    {
      "vertexName": "Method public abstract boolean advanceExact(int doc) throws IOException  (DocValueBits.java)",
      "children": [
        {
          "name": "Method public abstract boolean advanceExact(int doc) throws IOException  (SortedBinaryDocValues.java)"
        }
      ],
      "comment": "\n     * Advance this instance to the given document id\n     *\n     * @return true if there is a value for this document\n     ",
      "vertexLabel": "abstract boolean advanceExact()"
    },
    {
      "vertexName": "Method public DateRangeAggregationBuilder addUnboundedTo(String key, double to)  (DateRangeAggregationBuilder.java)",
      "children": [
        {
          "name": "Method public DateRangeAggregationBuilder addUnboundedTo(String key, String to)  (DateRangeAggregationBuilder.java)"
        }
      ],
      "comment": "\n     * Add a new range with no lower bound.\n     *\n     * @param key\n     *            the key to use for this range in the response\n     * @param to\n     *            the upper bound on the dates, exclusive\n     ",
      "vertexLabel": "DateRangeAggregationBuilder addUnboundedTo()"
    },
    {
      "vertexName": "Method public static BytesReference toXContent(ToXContent toXContent, XContentType xContentType, boolean humanReadable) throws IOException  (XContentHelper.java)",
      "comment": "\n     * Returns the bytes that represent the XContent output of the provided {@link ToXContent} object, using the provided\n     * {@link XContentType}. Wraps the output into a new anonymous object according to the value returned\n     * by the {@link ToXContent#isFragment()} method returns.\n     ",
      "vertexLabel": "BytesReference toXContent()"
    },
    {
      "vertexName": "Method public GeoBoundingBoxQueryBuilder setCornersOGC(GeoPoint bottomLeft, GeoPoint topRight)  (GeoBoundingBoxQueryBuilder.java)",
      "children": [
        {
          "name": "Method public GeoBoundingBoxQueryBuilder setCornersOGC(String bottomLeft, String topRight)  (GeoBoundingBoxQueryBuilder.java)"
        }
      ],
      "comment": "\n     * Adds corners in OGC standard bbox/ envelop format.\n     *\n     * @param bottomLeft bottom left corner of bounding box.\n     * @param topRight top right corner of bounding box.\n     ",
      "vertexLabel": "GeoBoundingBoxQueryBuilder setCornersOGC()"
    },
    {
      "vertexName": "Method T get()  (Provider.java)",
      "children": [
        {
          "name": "Class OutOfScopeException  (OutOfScopeException.java)"
        }
      ],
      "comment": "\n     * Provides an instance of {@code T}. Must never return {@code null}.\n     *\n     * @throws OutOfScopeException when an attempt is made to access a scoped object while the scope\n     *                             in question is not currently active\n     * @throws ProvisionException  if an instance cannot be provided. Such exceptions include messages\n     *                             and throwables to describe why provision failed.\n     ",
      "vertexLabel": "T get()"
    },
    {
      "vertexName": "Class AbstractDiffable  (AbstractDiffable.java)",
      "comment": "\n * Abstract diffable object with simple diffs implementation that sends the entire object if object has changed or\n * nothing is object remained the same.\n ",
      "vertexLabel": "Class AbstractDiffable"
    },
    {
      "vertexName": "Class SortableLongBitsNumericDocValues  (SortableLongBitsNumericDocValues.java)",
      "children": [
        {
          "name": "Class SortableLongBitsToNumericDoubleValues  (SortableLongBitsToNumericDoubleValues.java)"
        }
      ],
      "comment": "\n * {@link NumericDocValues} instance that wraps a {@link NumericDoubleValues}\n * and converts the doubles to sortable long bits using\n * {@link NumericUtils#doubleToSortableLong(double)}.\n ",
      "vertexLabel": "Class SortableLongBitsNumericDocValues"
    },
    {
      "vertexName": "Class Builder  (IndexResponse.java)",
      "comment": "\n     * Builder class for {@link IndexResponse}. This builder is usually used during xcontent parsing to\n     * temporarily store the parsed values, then the {@link Builder#build()} method is called to\n     * instantiate the {@link IndexResponse}.\n     ",
      "vertexLabel": "Class Builder"
    },
    {
      "vertexName": "Method public int getMaxDocFreq()  (XMoreLikeThis.java)",
      "children": [
        {
          "name": "Method public MoreLikeThisQueryBuilder maxDocFreq(int maxDocFreq)  (MoreLikeThisQueryBuilder.java)"
        }
      ],
      "comment": "\n     * Returns the maximum frequency in which words may still appear.\n     * Words that appear in more than this many docs will be ignored. The default frequency is\n     * {@link #DEFAULT_MAX_DOC_FREQ}.\n     *\n     * @return get the maximum frequency at which words are still allowed,\n     *         words which occur in more docs than this are ignored.\n     ",
      "vertexLabel": "int getMaxDocFreq()"
    },
    {
      "vertexName": "Method static void rewriteAndFetch(T original, QueryRewriteContext context, ActionListener<T> rewriteResponse)  (Rewriteable.java)",
      "comment": "\n     * Rewrites the given rewriteable and fetches pending async tasks for each round before rewriting again.\n     ",
      "vertexLabel": "void rewriteAndFetch()"
    },
    {
      "vertexName": "Method MembersInjector<T> getMembersInjector(Class<T> type)  (Binder.java)",
      "children": [
        {
          "name": "Method MembersInjector<T> getMembersInjector(Class<T> type)  (TypeEncounter.java)"
        }
      ],
      "comment": "\n     * Returns the members injector used to inject dependencies into methods and fields on instances\n     * of the given type {@code T}. The returned members injector will not be valid until the main\n     * {@link Injector} has been created. The members injector will throw an {@code\n     * IllegalStateException} if you try to use it beforehand.\n     *\n     * @param type type to get members injector for\n     * @since 2.0\n     ",
      "vertexLabel": "MembersInjector<T> getMembersInjector()"
    },
    {
      "vertexName": "Method public static GeoShapeQueryBuilder geoShapeQuery(String name, ShapeBuilder shape) throws IOException  (QueryBuilders.java)",
      "children": [
        {
          "name": "Method public static GeoShapeQueryBuilder geoIntersectionQuery(String name, ShapeBuilder shape) throws IOException  (QueryBuilders.java)"
        }
      ],
      "comment": "\n     * A filter based on the relationship of a shape and indexed shapes\n     *\n     * @param name  The shape field name\n     * @param shape Shape to use in the filter\n     ",
      "vertexLabel": "GeoShapeQueryBuilder geoShapeQuery()"
    },
    {
      "vertexName": "Method public RestoreSnapshotRequest includeAliases(boolean includeAliases)  (RestoreSnapshotRequest.java)",
      "comment": "\n     * If set to true the restore procedure will restore aliases\n     *\n     * @param includeAliases true if aliases should be restored from the snapshot\n     * @return this request\n     ",
      "vertexLabel": "RestoreSnapshotRequest includeAliases()"
    },
    {
      "vertexName": "Method public void onFailure(DiscoveryNode node, Exception e)  (BlockingClusterStatePublishResponseHandler.java)",
      "comment": "\n     * Called for each failure obtained from non master nodes\n     * @param node the node that replied to the publish event\n     ",
      "vertexLabel": "void onFailure()"
    },
    {
      "vertexName": "Method public final void onModule(ScriptModule module)  (Plugin.java)",
      "children": [
        {
          "name": "Method public final void onModule(NetworkModule module)  (Plugin.java)"
        }
      ],
      "comment": "\n     * Old-style guice scripting extension point. {@code @Deprecated} and {@code final} to act as a signpost for plugin authors upgrading\n     * from 2.x.\n     *\n     * @deprecated implement {@link ScriptPlugin} instead\n     ",
      "vertexLabel": "final void onModule()"
    },
    {
      "vertexName": "Method public String[] getFieldNames()  (XMoreLikeThis.java)",
      "comment": "\n     * Returns the field names that will be used when generating the 'More Like This' query.\n     * The default field names that will be used is {@link #DEFAULT_FIELD_NAMES}.\n     *\n     * @return the field names that will be used when generating the 'More Like This' query.\n     ",
      "vertexLabel": "String[] getFieldNames()"
    },
    {
      "vertexName": "Method public MultiSearchRequest maxConcurrentSearchRequests(int maxConcurrentSearchRequests)  (MultiSearchRequest.java)",
      "comment": "\n     * Sets how many search requests specified in this multi search requests are allowed to be ran concurrently.\n     ",
      "vertexLabel": "MultiSearchRequest maxConcurrentSearchRequests()"
    },
    {
      "vertexName": "Method void clusterStats(ClusterStatsRequest request, ActionListener<ClusterStatsResponse> listener)  (ClusterAdminClient.java)",
      "children": [
        {
          "name": "Method ActionFuture<ClusterStatsResponse> clusterStats(ClusterStatsRequest request)  (ClusterAdminClient.java)"
        }
      ],
      "comment": "\n     * Cluster wide aggregated stats\n     *\n     * @param request  The cluster stats request\n     * @param listener A listener to be notified with a result\n     * @see org.elasticsearch.client.Requests#clusterStatsRequest()\n     ",
      "vertexLabel": "void clusterStats()"
    },
    {
      "vertexName": "Method public static MoveDecision cannotRemain(Decision canRemainDecision, AllocationDecision allocationDecision, DiscoveryNode assignedNode, List<NodeAllocationResult> nodeDecisions)  (MoveDecision.java)",
      "comment": "\n     * Creates a move decision for the shard not being allowed to remain on its current node.\n     *\n     * @param canRemainDecision the decision for whether the shard is allowed to remain on its current node\n     * @param allocationDecision the {@link AllocationDecision} for moving the shard to another node\n     * @param assignedNode the node where the shard should move to\n     * @param nodeDecisions the node-level decisions that comprised the final decision, non-null iff explain is true\n     * @return the {@link MoveDecision} for moving the shard to another node\n     ",
      "vertexLabel": "MoveDecision cannotRemain()"
    },
    {
      "vertexName": "Method public long getTotalStoppedTimeInMillis()  (MergeStats.java)",
      "comment": "\n     * The total time large merges were stopped so smaller merges could finish.\n     ",
      "vertexLabel": "long getTotalStoppedTimeInMillis()"
    },
    {
      "vertexName": "Method public TermSuggestionBuilder accuracy(float accuracy)  (TermSuggestionBuilder.java)",
      "comment": "\n     * s how similar the suggested terms at least need to be compared to the\n     * original suggest text tokens. A value between 0 and 1 can be specified.\n     * This value will be compared to the string distance result of each\n     * candidate spelling correction.\n     * <p>\n     * Default is {@code 0.5}\n     ",
      "vertexLabel": "TermSuggestionBuilder accuracy()"
    },
    {
      "vertexName": "Method public Function<String, Predicate<String>> getFieldFilter()  (IndicesService.java)",
      "children": [
        {
          "name": "Method public Function<String, Predicate<String>> getFieldFilter()  (MapperRegistry.java)"
        }
      ],
      "comment": "\n     * Returns a function which given an index name, returns a predicate which fields must match in order to be returned by get mappings,\n     * get index, get field mappings and field capabilities API. Useful to filter the fields that such API return.\n     * The predicate receives the field name as input argument. In case multiple plugins register a field filter through\n     * {@link org.elasticsearch.plugins.MapperPlugin#getFieldFilter()}, only fields that match all the registered filters will be\n     * returned by get mappings, get index, get field mappings and field capabilities API.\n     ",
      "vertexLabel": "Function<String, Predicate<String>> getFieldFilter()"
    },
    {
      "vertexName": "Method void rolloverIndex(RolloverRequest request, ActionListener<RolloverResponse> listener)  (IndicesAdminClient.java)",
      "children": [
        {
          "name": "Method RolloverRequestBuilder prepareRolloverIndex(String sourceAlias)  (IndicesAdminClient.java)"
        }
      ],
      "comment": "\n     * Swaps the index pointed to by an alias given all provided conditions are satisfied\n     ",
      "vertexLabel": "void rolloverIndex()"
    },
    {
      "vertexName": "Method public ReducedQueryPhase reducedQueryPhase(Collection<? extends SearchPhaseResult> queryResults, boolean isScrollRequest, boolean trackTotalHits)  (SearchPhaseController.java)",
      "children": [
        {
          "name": "Method public ReducedQueryPhase reducedQueryPhase(Collection<? extends SearchPhaseResult> queryResults, boolean isScrollRequest)  (SearchPhaseController.java)"
        }
      ],
      "comment": "\n     * Reduces the given query results and consumes all aggregations and profile results.\n     * @param queryResults a list of non-null query shard results\n     ",
      "vertexLabel": "ReducedQueryPhase reducedQueryPhase()"
    },
    {
      "vertexName": "Method public GetRequestBuilder setVersion(long version)  (GetRequestBuilder.java)",
      "children": [
        {
          "name": "Method public long version()  (GetRequest.java)"
        }
      ],
      "comment": "\n     * Sets the version, which will cause the get operation to only be performed if a matching\n     * version exists and no changes happened on the doc since then.\n     ",
      "vertexLabel": "GetRequestBuilder setVersion()"
    },
    {
      "vertexName": "Method public SearchRequestBuilder fields(String... fields)  (SearchRequestBuilder.java)",
      "children": [
        {
          "name": "Method public SearchRequestBuilder storedFields(String... fields)  (SearchRequestBuilder.java)"
        }
      ],
      "comment": "\n     * Adds stored fields to load and return (note, it must be stored) as part of the search request.\n     * To disable the stored fields entirely (source and metadata fields) use {@code storedField(\"_none_\")}.\n     * @deprecated Use {@link SearchRequestBuilder#storedFields(String...)} instead.\n     ",
      "vertexLabel": "SearchRequestBuilder fields()"
    },
    {
      "vertexName": "Method public DiscoveryNode(String nodeName, String nodeId, String ephemeralId, String hostName, String hostAddress, TransportAddress address, Map<String, String> attributes, Set<Role> roles, Version version)  (DiscoveryNode.java)",
      "children": [
        {
          "name": "Method public DiscoveryNode(String nodeName, String nodeId, TransportAddress address, Map<String, String> attributes, Set<Role> roles, Version version)  (DiscoveryNode.java)"
        }
      ],
      "comment": "\n     * Creates a new {@link DiscoveryNode}.\n     * <p>\n     * <b>Note:</b> if the version of the node is unknown {@link Version#minimumCompatibilityVersion()} should be used for the current\n     * version. it corresponds to the minimum version this elasticsearch version can communicate with. If a higher version is used\n     * the node might not be able to communicate with the remote node. After initial handshakes node versions will be discovered\n     * and updated.\n     * </p>\n     *\n     * @param nodeName         the nodes name\n     * @param nodeId           the nodes unique persistent id\n     * @param ephemeralId      the nodes unique ephemeral id\n     * @param hostAddress      the nodes host address\n     * @param address          the nodes transport address\n     * @param attributes       node attributes\n     * @param roles            node roles\n     * @param version          the version of the node\n     ",
      "vertexLabel": "DiscoveryNode()"
    },
    {
      "vertexName": "Method public static void validateFieldReferences(List<FieldMapper> fieldMappers, List<FieldAliasMapper> fieldAliasMappers, Map<String, ObjectMapper> fullPathObjectMappers, FieldTypeLookup fieldTypes)  (MapperMergeValidator.java)",
      "comment": "\n     * Verifies that each field reference, e.g. the value of copy_to or the target\n     * of a field alias, corresponds to a valid part of the mapping.\n     *\n     * @param fieldMappers The newly added field mappers.\n     * @param fieldAliasMappers The newly added field alias mappers.\n     * @param fullPathObjectMappers All object mappers, indexed by their full path.\n     * @param fieldTypes All field and field alias mappers, collected into a lookup structure.\n     ",
      "vertexLabel": "void validateFieldReferences()"
    },
    {
      "vertexName": "Class DefaultBindingScopingVisitor  (DefaultBindingScopingVisitor.java)",
      "children": [
        {
          "name": "Interface BindingScopingVisitor  (BindingScopingVisitor.java)"
        }
      ],
      "comment": "\n * No-op visitor for subclassing. All interface methods simply delegate to\n * {@link #visitOther()}, returning its result.\n *\n * @param <V> any type to be returned by the visit method. Use {@link Void} with\n *            {@code return null} if no return type is needed.\n * @author jessewilson@google.com (Jesse Wilson)\n * @since 2.0\n ",
      "vertexLabel": "Class DefaultBindingScopingVisitor"
    },
    {
      "vertexName": "Class LoggingAwareMultiCommand  (LoggingAwareMultiCommand.java)",
      "children": [
        {
          "name": "Class LoggingAwareCommand  (LoggingAwareCommand.java)"
        }
      ],
      "comment": "\n * A multi-command that is aware of logging. This class should be preferred over the base {@link MultiCommand} class for any CLI tools that\n * depend on core Elasticsearch as they could directly or indirectly touch classes that touch logging and as such logging needs to be\n * configured.\n ",
      "vertexLabel": "Class LoggingAwareMultiCommand"
    },
    {
      "vertexName": "Method public BaseTermQueryBuilder(String fieldName, float value)  (BaseTermQueryBuilder.java)",
      "children": [
        {
          "name": "Method public BaseTermQueryBuilder(String fieldName, String value)  (BaseTermQueryBuilder.java)"
        }
      ],
      "comment": "\n     * Constructs a new base term query.\n     *\n     * @param fieldName  The name of the field\n     * @param value The value of the term\n     ",
      "vertexLabel": "BaseTermQueryBuilder()"
    },
    {
      "vertexName": "Method public T lookupReturningNullIfNotFound(String name, DeprecationHandler deprecationHandler)  (ParseFieldRegistry.java)",
      "children": [
        {
          "name": "Method public T lookup(String name, XContentLocation xContentLocation, DeprecationHandler deprecationHandler)  (ParseFieldRegistry.java)"
        }
      ],
      "comment": "\n     * Lookup a value from the registry by name while checking that the name matches the ParseField.\n     *\n     * @param name The name of the thing to look up.\n     * @return The value being looked up or null if it wasn't found.\n     * @throws ParsingException if the named thing isn't in the registry or the name was deprecated and deprecated names aren't supported.\n     ",
      "vertexLabel": "T lookupReturningNullIfNotFound()"
    },
    {
      "vertexName": "Method public final long getMaxSeqNoOfUpdatesOrDeletes()  (Engine.java)",
      "children": [
        {
          "name": "Method public long getMaxSeqNoOfUpdatesOrDeletes()  (IndexShard.java)"
        }
      ],
      "comment": "\n     * Returns the maximum sequence number of either update or delete operations have been processed in this engine\n     * or the sequence number from {@link #advanceMaxSeqNoOfUpdatesOrDeletes(long)}. An index request is considered\n     * as an update operation if it overwrites the existing documents in Lucene index with the same document id.\n     * <p>\n     * A note on the optimization using max_seq_no_of_updates_or_deletes:\n     * For each operation O, the key invariants are:\n     * <ol>\n     *     <li> I1: There is no operation on docID(O) with seqno that is {@literal > MSU(O) and < seqno(O)} </li>\n     *     <li> I2: If {@literal MSU(O) < seqno(O)} then docID(O) did not exist when O was applied; more precisely, if there is any O'\n     *              with {@literal seqno(O') < seqno(O) and docID(O') = docID(O)} then the one with the greatest seqno is a delete.</li>\n     * </ol>\n     * <p>\n     * When a receiving shard (either a replica or a follower) receives an operation O, it must first ensure its own MSU at least MSU(O),\n     * and then compares its MSU to its local checkpoint (LCP). If {@literal LCP < MSU} then there's a gap: there may be some operations\n     * that act on docID(O) about which we do not yet know, so we cannot perform an add. Note this also covers the case where a future\n     * operation O' with {@literal seqNo(O') > seqNo(O) and docId(O') = docID(O)} is processed before O. In that case MSU(O') is at least\n     * seqno(O') and this means {@literal MSU >= seqNo(O') > seqNo(O) > LCP} (because O wasn't processed yet).\n     * <p>\n     * However, if {@literal MSU <= LCP} then there is no gap: we have processed every {@literal operation <= LCP}, and no operation O'\n     * with {@literal seqno(O') > LCP and seqno(O') < seqno(O) also has docID(O') = docID(O)}, because such an operation would have\n     * {@literal seqno(O') > LCP >= MSU >= MSU(O)} which contradicts the first invariant. Furthermore in this case we immediately know\n     * that docID(O) has been deleted (or never existed) without needing to check Lucene for the following reason. If there's no earlier\n     * operation on docID(O) then this is clear, so suppose instead that the preceding operation on docID(O) is O':\n     * 1. The first invariant above tells us that {@literal seqno(O') <= MSU(O) <= LCP} so we have already applied O' to Lucene.\n     * 2. Also {@literal MSU(O) <= MSU <= LCP < seqno(O)} (we discard O if {@literal seqno(O) <= LCP}) so the second invariant applies,\n     *    meaning that the O' was a delete.\n     * <p>\n     * Therefore, if {@literal MSU <= LCP < seqno(O)} we know that O can safely be optimized with and added to lucene with addDocument.\n     * Moreover, operations that are optimized using the MSU optimization must not be processed twice as this will create duplicates\n     * in Lucene. To avoid this we check the local checkpoint tracker to see if an operation was already processed.\n     *\n     * @see #initializeMaxSeqNoOfUpdatesOrDeletes()\n     * @see #advanceMaxSeqNoOfUpdatesOrDeletes(long)\n     ",
      "vertexLabel": "final long getMaxSeqNoOfUpdatesOrDeletes()"
    },
    {
      "vertexName": "Method public List<String> getActiveOperations()  (IndexShard.java)",
      "comment": "\n     * @return a list of describing each permit that wasn't released yet. The description consist of the debugInfo supplied\n     *         when the permit was acquired plus a stack traces that was captured when the permit was request.\n     ",
      "vertexLabel": "List<String> getActiveOperations()"
    },
    {
      "vertexName": "Method public MultiMatchQueryBuilder fuzzyTranspositions(boolean fuzzyTranspositions)  (MultiMatchQueryBuilder.java)",
      "children": [
        {
          "name": "Method public MatchQueryBuilder fuzzyTranspositions(boolean fuzzyTranspositions)  (MatchQueryBuilder.java)"
        }
      ],
      "comment": "\n     * Sets whether transpositions are supported in fuzzy queries.<p>\n     * The default metric used by fuzzy queries to determine a match is the Damerau-Levenshtein\n     * distance formula which supports transpositions. Setting transposition to false will\n     * switch to classic Levenshtein distance.<br>\n     * If not set, Damerau-Levenshtein distance metric will be used.\n     ",
      "vertexLabel": "MultiMatchQueryBuilder fuzzyTranspositions()"
    },
    {
      "vertexName": "Method T actionGet(String timeout)  (ActionFuture.java)",
      "children": [
        {
          "name": "Method T actionGet()  (ActionFuture.java)"
        }
      ],
      "comment": "\n     * Similar to {@link #get(long, java.util.concurrent.TimeUnit)}, just catching the {@link InterruptedException} and throwing\n     * an {@link IllegalStateException} instead. Also catches\n     * {@link java.util.concurrent.ExecutionException} and throws the actual cause instead.\n     ",
      "vertexLabel": "T actionGet()"
    },
    {
      "vertexName": "Method public static void copy(String in, Writer out) throws IOException  (Streams.java)",
      "comment": "\n     * Copy the contents of the given String to the given output Writer.\n     * Closes the write when done.\n     *\n     * @param in  the String to copy from\n     * @param out the Writer to copy to\n     * @throws IOException in case of I/O errors\n     ",
      "vertexLabel": "void copy()"
    },
    {
      "vertexName": "Method Provider<T> getProvider(Class<T> type)  (Binder.java)",
      "children": [
        {
          "name": "Method Provider<T> getProvider(Class<T> type)  (TypeEncounter.java)"
        }
      ],
      "comment": "\n     * Returns the provider used to obtain instances for the given injection type.\n     * The returned provider will not be valid until the {@link Injector} has been\n     * created. The provider will throw an {@code IllegalStateException} if you\n     * try to use it beforehand.\n     *\n     * @since 2.0\n     ",
      "vertexLabel": "Provider<T> getProvider()"
    },
    {
      "vertexName": "Method abstract int compareCurrent(int slot)  (SingleDimensionValuesSource.java)",
      "children": [
        {
          "name": "Method abstract int compareCurrentWithAfter()  (SingleDimensionValuesSource.java)"
        }
      ],
      "comment": "\n     * The current value is filled by a {@link LeafBucketCollector} that visits all the\n     * values of each document. This method compares this current value with the value present in\n     * the provided slot and should only be used in the context of a collection.\n     * See {@link #getLeafCollector}.\n     ",
      "vertexLabel": "abstract int compareCurrent()"
    },
    {
      "vertexName": "Method public DirectCandidateGeneratorBuilder minWordLength(int minWordLength)  (DirectCandidateGeneratorBuilder.java)",
      "comment": "\n     * The minimum length a suggest text term must have in order to be\n     * corrected. Defaults to {@code 4}.\n     ",
      "vertexLabel": "DirectCandidateGeneratorBuilder minWordLength()"
    },
    {
      "vertexName": "Method public UnaryOperator<Map<String, IndexTemplateMetaData>> getIndexTemplateMetaDataUpgrader()  (Plugin.java)",
      "children": [
        {
          "name": "Method public UnaryOperator<Map<String, MetaData.Custom>> getCustomMetaDataUpgrader()  (Plugin.java)"
        }
      ],
      "comment": "\n     * Provides a function to modify index template meta data on startup.\n     * <p>\n     * Plugins should return the input template map via {@link UnaryOperator#identity()} if no upgrade is required.\n     * <p>\n     * The order of the template upgrader calls is undefined and can change between runs so, it is expected that\n     * plugins will modify only templates owned by them to avoid conflicts.\n     * <p>\n     * @return Never {@code null}. The same or upgraded {@code IndexTemplateMetaData} map.\n     * @throws IllegalStateException if the node should not start because at least one {@code IndexTemplateMetaData}\n     *                               cannot be upgraded\n     ",
      "vertexLabel": "UnaryOperator<Map<String, IndexTemplateMetaData>> getIndexTemplateMetaDataUpgrader()"
    },
    {
      "vertexName": "EnumConstant FOUND  (RestStatus.java)",
      "children": [
        {
          "name": "EnumConstant SEE_OTHER  (RestStatus.java)"
        }
      ],
      "comment": "\n     * The requested resource resides temporarily under a different URI. Since the redirection might be altered on\n     * occasion, the client SHOULD continue to use the Request-URI for future requests.  This response is only\n     * cacheable if indicated by a Cache-Control or Expires header field.\n     * <p>\n     * The temporary URI SHOULD be given by the Location field in the response. Unless the request method was\n     * HEAD, the entity of the response SHOULD contain a short hypertext note with a hyperlink to the new URI(s).\n     * <p>\n     * If the 302 status code is received in response to a request other than GET or HEAD, the user agent\n     * MUST NOT automatically redirect the request unless it can be confirmed by the user, since this might change\n     * the conditions under which the request was issued.\n     ",
      "vertexLabel": "EnumConstant FOUND"
    },
    {
      "vertexName": "Class Builder  (StoredScriptSource.java)",
      "children": [
        {
          "name": "Class Builder  (Script.java)"
        }
      ],
      "comment": "\n     * Helper class used by {@link ObjectParser} to store mutable {@link StoredScriptSource} variables and then\n     * construct an immutable {@link StoredScriptSource} object based on parsed XContent.\n     ",
      "vertexLabel": "Class Builder"
    },
    {
      "vertexName": "Method public static SnapshotIndexShardStage fromValue(byte value)  (SnapshotIndexShardStage.java)",
      "children": [
        {
          "name": "Method public static SnapshotState fromValue(byte value)  (SnapshotState.java)"
        }
      ],
      "comment": "\n     * Generate snapshot state from code\n     *\n     * @param value the state code\n     * @return state\n     ",
      "vertexLabel": "SnapshotIndexShardStage fromValue()"
    },
    {
      "vertexName": "Method public abstract boolean validateVersionForReads(long version)  (VersionType.java)",
      "children": [
        {
          "name": "Method public abstract boolean validateVersionForWrites(long version)  (VersionType.java)"
        }
      ],
      "comment": "\n     * validate the version is a valid value for this type when reading.\n     *\n     * @return true if valid, false o.w\n     ",
      "vertexLabel": "abstract boolean validateVersionForReads()"
    },
    {
      "vertexName": "Method public static FlushRequest flushRequest(String... indices)  (Requests.java)",
      "children": [
        {
          "name": "Method public static SyncedFlushRequest syncedFlushRequest(String... indices)  (Requests.java)"
        }
      ],
      "comment": "\n     * Creates a flush indices request.\n     *\n     * @param indices The indices to flush. Use {@code null} or {@code _all} to execute against all indices\n     * @return The flush request\n     * @see org.elasticsearch.client.IndicesAdminClient#flush(org.elasticsearch.action.admin.indices.flush.FlushRequest)\n     ",
      "vertexLabel": "FlushRequest flushRequest()"
    },
    {
      "vertexName": "Method public UpdateRequestBuilder setUpsert(IndexRequest indexRequest)  (UpdateRequestBuilder.java)",
      "children": [
        {
          "name": "Method public UpdateRequest upsert(IndexRequest upsertRequest)  (UpdateRequest.java)"
        }
      ],
      "comment": "\n     * Sets the index request to be used if the document does not exists. Otherwise, a {@link org.elasticsearch.index.engine.DocumentMissingException}\n     * is thrown.\n     ",
      "vertexLabel": "UpdateRequestBuilder setUpsert()"
    },
    {
      "vertexName": "Method public void publish(final ClusterChangedEvent clusterChangedEvent, final int minMasterNodes, final Discovery.AckListener ackListener) throws Discovery.FailedToCommitClusterStateException  (PublishClusterStateAction.java)",
      "comment": "\n     * publishes a cluster change event to other nodes. if at least minMasterNodes acknowledge the change it is committed and will\n     * be processed by the master and the other nodes.\n     * <p>\n     * The method is guaranteed to throw a {@link org.elasticsearch.discovery.Discovery.FailedToCommitClusterStateException}\n     * if the change is not committed and should be rejected.\n     * Any other exception signals the something wrong happened but the change is committed.\n     ",
      "vertexLabel": "void publish()"
    },
    {
      "vertexName": "Method private static double[] emptyPredictions(int numPredictions)  (MovingFunctions.java)",
      "children": [
        {
          "name": "Method protected double[] emptyPredictions(int numPredictions)  (MovAvgModel.java)"
        }
      ],
      "comment": "\n     * Returns an empty set of predictions, filled with NaNs\n     * @param numPredictions Number of empty predictions to generate\n     ",
      "vertexLabel": "double[] emptyPredictions()"
    },
    {
      "vertexName": "Method ActionFuture<ResizeResponse> resizeIndex(ResizeRequest request)  (IndicesAdminClient.java)",
      "children": [
        {
          "name": "Method ResizeRequestBuilder prepareResizeIndex(String sourceIndex, String targetIndex)  (IndicesAdminClient.java)"
        }
      ],
      "comment": "\n     * Resize an index using an explicit request allowing to specify the settings, mappings and aliases of the target index of the index.\n     ",
      "vertexLabel": "ActionFuture<ResizeResponse> resizeIndex()"
    },
    {
      "vertexName": "Method public static Map<String, T> readOptionalMap(String processorType, String processorTag, Map<String, Object> configuration, String propertyName)  (ConfigurationUtils.java)",
      "children": [
        {
          "name": "Method public static String readOptionalStringOrIntProperty(String processorType, String processorTag, Map<String, Object> configuration, String propertyName)  (ConfigurationUtils.java)"
        }
      ],
      "comment": "\n     * Returns and removes the specified property of type map from the specified configuration map.\n     *\n     * If the property value isn't of type map an {@link ElasticsearchParseException} is thrown.\n     ",
      "vertexLabel": "Map<String, T> readOptionalMap()"
    },
    {
      "vertexName": "Method public PutIndexTemplateRequest mapping(String type, BytesReference source, XContentType xContentType)  (PutIndexTemplateRequest.java)",
      "children": [
        {
          "name": "Method public CreateIndexRequest mapping(String type, XContentBuilder source)  (CreateIndexRequest.java)"
        }
      ],
      "comment": "\n     * Adds mapping that will be added when the index gets created.\n     *\n     * @param type   The mapping type\n     * @param source The mapping source\n     * @param xContentType the source content type\n     ",
      "vertexLabel": "PutIndexTemplateRequest mapping()"
    },
    {
      "vertexName": "Method String readSysFsCgroupMemoryLimitInBytes(final String controlGroup) throws IOException  (OsProbe.java)",
      "children": [
        {
          "name": "Method private long getCgroupCpuAcctUsageNanos(final String controlGroup) throws IOException  (OsProbe.java)"
        }
      ],
      "comment": "\n     * Returns the line from {@code memory.limit_in_bytes} for the control group to which the Elasticsearch process belongs for the\n     * {@code memory} subsystem. This line represents the maximum amount of user memory (including file cache).\n     *\n     * @param controlGroup the control group to which the Elasticsearch process belongs for the {@code memory} subsystem\n     * @return the line from {@code memory.limit_in_bytes}\n     * @throws IOException if an I/O exception occurs reading {@code memory.limit_in_bytes} for the control group\n     ",
      "vertexLabel": "String readSysFsCgroupMemoryLimitInBytes()"
    },
    {
      "vertexName": "Method void postDelete(ShardId shardId, Engine.Delete delete, Engine.DeleteResult result)  (IndexingOperationListener.java)",
      "children": [
        {
          "name": "Method void postIndex(ShardId shardId, Engine.Index index, Engine.IndexResult result)  (IndexingOperationListener.java)"
        }
      ],
      "comment": "\n     * Called after the delete operation occurred. Note that this is\n     * also called when deleting a document did not succeed due to document\n     * related failures. See {@link #postDelete(ShardId, Engine.Delete, Exception)}\n     * for engine level failures\n     ",
      "vertexLabel": "void postDelete()"
    },
    {
      "vertexName": "EnumConstant MOVED_PERMANENTLY  (RestStatus.java)",
      "children": [
        {
          "name": "EnumConstant FOUND  (RestStatus.java)"
        }
      ],
      "comment": "\n     * The requested resource has been assigned a new permanent URI and any future references to this resource\n     * SHOULD use one of the returned URIs.  Clients with link editing capabilities ought to automatically re-link\n     * references to the Request-URI to one or more of the new references returned by the server, where possible.\n     * This response is cacheable unless indicated otherwise.\n     * <p>\n     * The new permanent URI SHOULD be given by the Location field in the response. Unless the request method\n     * was HEAD, the entity of the response SHOULD contain a short hypertext note with a hyperlink to the new URI(s).\n     * <p>\n     * If the 301 status code is received in response to a request other than GET or HEAD, the user agent\n     * MUST NOT automatically redirect the request unless it can be confirmed by the user, since this might change\n     * the conditions under which the request was issued.\n     ",
      "vertexLabel": "EnumConstant MOVED_PERMANENTLY"
    },
    {
      "vertexName": "Method public GetRequest routing(String routing)  (GetRequest.java)",
      "children": [
        {
          "name": "Method public DeleteRequest routing(String routing)  (DeleteRequest.java)"
        }
      ],
      "comment": "\n     * Controls the shard routing of the request. Using this value to hash the shard\n     * and not the id.\n     ",
      "vertexLabel": "GetRequest routing()"
    },
    {
      "vertexName": "Method public UpdateRequestBuilder setUpsert(Map<String, Object> source, XContentType contentType)  (UpdateRequestBuilder.java)",
      "children": [
        {
          "name": "Method public UpdateRequest upsert(byte[] source, XContentType xContentType)  (UpdateRequest.java)"
        }
      ],
      "comment": "\n     * Sets the doc source of the update request to be used when the document does not exists.\n     ",
      "vertexLabel": "UpdateRequestBuilder setUpsert()"
    },
    {
      "vertexName": "Method public void setMaxDocFreqPct(int maxPercentage)  (XMoreLikeThis.java)",
      "children": [
        {
          "name": "Method public void setMaxDocFreq(int maxFreq)  (XMoreLikeThis.java)"
        }
      ],
      "comment": "\n     * Set the maximum percentage in which words may still appear. Words that appear\n     * in more than this many percent of all docs will be ignored.\n     *\n     * @param maxPercentage the maximum percentage of documents (0-100) that a term may appear\n     * in to be still considered relevant\n     ",
      "vertexLabel": "void setMaxDocFreqPct()"
    },
    {
      "vertexName": "Interface HttpRequest  (HttpRequest.java)",
      "comment": "\n * A basic http request abstraction. Http modules needs to implement this interface to integrate with the\n * server package's rest handling.\n ",
      "vertexLabel": "Interface HttpRequest"
    },
    {
      "vertexName": "Method List<String> consumedParams()  (RestRequest.java)",
      "comment": "\n     * Returns a list of parameters that have been consumed. This method returns a copy, callers\n     * are free to modify the returned list.\n     *\n     * @return the list of currently consumed parameters.\n     ",
      "vertexLabel": "List<String> consumedParams()"
    },
    {
      "vertexName": "Method public RangeAggregationBuilder addRange(String key, double from, double to)  (RangeAggregationBuilder.java)",
      "children": [
        {
          "name": "Method public GeoDistanceAggregationBuilder addRange(String key, double from, double to)  (GeoDistanceAggregationBuilder.java)"
        }
      ],
      "comment": "\n     * Add a new range to this aggregation.\n     *\n     * @param key\n     *            the key to use for this range in the response\n     * @param from\n     *            the lower bound on the distances, inclusive\n     * @param to\n     *            the upper bound on the distances, exclusive\n     ",
      "vertexLabel": "RangeAggregationBuilder addRange()"
    },
    {
      "vertexName": "Method public OpenIndexRequest waitForActiveShards(final int waitForActiveShards)  (OpenIndexRequest.java)",
      "children": [
        {
          "name": "Method public CreateIndexRequest waitForActiveShards(final int waitForActiveShards)  (CreateIndexRequest.java)"
        }
      ],
      "comment": "\n     * A shortcut for {@link #waitForActiveShards(ActiveShardCount)} where the numerical\n     * shard count is passed in, instead of having to first call {@link ActiveShardCount#from(int)}\n     * to get the ActiveShardCount.\n     ",
      "vertexLabel": "OpenIndexRequest waitForActiveShards()"
    },
    {
      "vertexName": "Method public final void validate(final Settings settings, final boolean validateDependencies)  (AbstractScopedSettings.java)",
      "comment": "\n     * Validates that all settings are registered and valid.\n     *\n     * @param settings             the settings to validate\n     * @param validateDependencies true if dependent settings should be validated\n     * @see Setting#getSettingsDependencies(String)\n     ",
      "vertexLabel": "final void validate()"
    },
    {
      "vertexName": "Method public synchronized void updateGlobalCheckpointOnReplica(final long globalCheckpoint, final String reason)  (ReplicationTracker.java)",
      "comment": "\n     * Updates the global checkpoint on a replica shard after it has been updated by the primary.\n     *\n     * @param globalCheckpoint the global checkpoint\n     * @param reason           the reason the global checkpoint was updated\n     ",
      "vertexLabel": "synchronized void updateGlobalCheckpointOnReplica()"
    },
    {
      "vertexName": "Method public Set<InjectionPoint> getInjectionPoints() throws ConfigurationException  (InjectionRequest.java)",
      "children": [
        {
          "name": "Method public Set<InjectionPoint> getInjectionPoints() throws ConfigurationException  (StaticInjectionRequest.java)"
        }
      ],
      "comment": "\n     * {@section getInjectionPoints:\n     * Returns the {@item methodType: instance} methods and fields of {@code {@item Instance: instance}} that will be injected to fulfill\n     * this request.\n     *\n     * @return a possibly empty set of injection points. The set has a specified iteration order. All\n     *         fields are returned and then all methods. Within the fields, supertype fields are returned\n     *         before subtype fields. Similarly, supertype methods are returned before subtype methods.\n     * @throws ConfigurationException if there is a malformed injection point on {@item classClarification: the class of} {@code\n     *                                {@reuse getInjectionPoints#Instance}}, such as a field with multiple binding annotations. The exception's {@link\n     *                                ConfigurationException#getPartialValue() partial value} is a {@code Set<InjectionPoint>}\n     *                                of the valid injection points.\n     * }\n     ",
      "vertexLabel": "Set<InjectionPoint> getInjectionPoints()"
    },
    {
      "vertexName": "Method public UpdateRequest waitForActiveShards(ActiveShardCount waitForActiveShards)  (UpdateRequest.java)",
      "children": [
        {
          "name": "Method public BulkRequest waitForActiveShards(ActiveShardCount waitForActiveShards)  (BulkRequest.java)"
        }
      ],
      "comment": "\n     * Sets the number of shard copies that must be active before proceeding with the write.\n     * See {@link ReplicationRequest#waitForActiveShards(ActiveShardCount)} for details.\n     ",
      "vertexLabel": "UpdateRequest waitForActiveShards()"
    },
    {
      "vertexName": "Method public static String collectionToDelimitedString(Iterable<?> coll, String delim)  (Strings.java)",
      "children": [
        {
          "name": "Method public static String arrayToDelimitedString(Object[] arr, String delim)  (Strings.java)"
        },
        {
          "name": "Method public static String collectionToCommaDelimitedString(Iterable<?> coll)  (Strings.java)"
        }
      ],
      "comment": "\n     * Convenience method to return a Collection as a delimited (e.g. CSV)\n     * String. E.g. useful for <code>toString()</code> implementations.\n     *\n     * @param coll  the Collection to display\n     * @param delim the delimiter to use (probably a \",\")\n     * @return the delimited String\n     ",
      "vertexLabel": "String collectionToDelimitedString()"
    },
    {
      "vertexName": "Method public static MovAvgModel minimize(MovAvgModel model, EvictingQueue<Double> train, double[] test)  (SimulatedAnealingMinimizer.java)",
      "children": [
        {
          "name": "Method private static double cost(MovAvgModel model, EvictingQueue<Double> train, double[] test)  (SimulatedAnealingMinimizer.java)"
        }
      ],
      "comment": "\n     * Runs the simulated annealing algorithm and produces a model with new coefficients that, theoretically\n     * fit the data better and generalizes to future forecasts without overfitting.\n     *\n     * @param model         The MovAvgModel to be optimized for\n     * @param train         A training set provided to the model, which predictions will be\n     *                      generated from\n     * @param test          A test set of data to compare the predictions against and derive\n     *                      a cost for the model\n     * @return              A new, minimized model that (theoretically) better fits the data\n     ",
      "vertexLabel": "MovAvgModel minimize()"
    },
    {
      "vertexName": "Method public SuggesterSpec(ParseField name, Writeable.Reader<T> builderReader, CheckedFunction<XContentParser, T, IOException> builderParser, Writeable.Reader<? extends Suggest.Suggestion> suggestionReader)  (SearchPlugin.java)",
      "children": [
        {
          "name": "Method public SuggesterSpec(String name, Writeable.Reader<T> builderReader, CheckedFunction<XContentParser, T, IOException> builderParser, Writeable.Reader<? extends Suggest.Suggestion> suggestionReader)  (SearchPlugin.java)"
        },
        {
          "name": "Method public QuerySpec(ParseField name, Writeable.Reader<T> reader, QueryParser<T> parser)  (SearchPlugin.java)"
        }
      ],
      "comment": "\n         * Specification of custom {@link Suggester}.\n         *\n         * @param name holds the names by which this suggester might be parsed. The {@link ParseField#getPreferredName()} is special as it\n         *        is the name by under which the request builder and Suggestion response readers are registered. So it is the name that the\n         *        query and Suggestion response should use as their {@link NamedWriteable#getWriteableName()} return values too.\n         * @param builderReader the reader registered for this suggester's builder. Typically a reference to a constructor that takes a\n         *        {@link StreamInput}\n         * @param builderParser a parser that reads the suggester's builder from xcontent\n         * @param suggestionReader the reader registered for this suggester's Suggestion response. Typically a reference to a constructor\n         *        that takes a {@link StreamInput}\n         ",
      "vertexLabel": "SuggesterSpec()"
    },
    {
      "vertexName": "Method public static Matcher<AnnotatedElement> annotatedWith(final Class<? extends Annotation> annotationType)  (Matchers.java)",
      "comment": "\n     * Returns a matcher which matches elements (methods, classes, etc.)\n     * with a given annotation.\n     ",
      "vertexLabel": "Matcher<AnnotatedElement> annotatedWith()"
    },
    {
      "vertexName": "Method void dispatchRequest(RestRequest request, RestChannel channel, ThreadContext threadContext)  (HttpServerTransport.java)",
      "comment": "\n         * Dispatches the {@link RestRequest} to the relevant request handler or responds to the given rest channel directly if\n         * the request can't be handled by any request handler.\n         *\n         * @param request       the request to dispatch\n         * @param channel       the response channel of this request\n         * @param threadContext the thread context\n         ",
      "vertexLabel": "void dispatchRequest()"
    },
    {
      "vertexName": "Method public RangeQueryBuilder from(Object from, boolean includeLower)  (RangeQueryBuilder.java)",
      "children": [
        {
          "name": "Method public Object to()  (RangeQueryBuilder.java)"
        }
      ],
      "comment": "\n     * The from part of the range query. Null indicates unbounded.\n     * In case lower bound is assigned to a string, we internally convert it to a {@link BytesRef} because\n     * in {@link RangeQueryBuilder} field are later parsed as {@link BytesRef} and we need internal representation\n     * of query to be equal regardless of whether it was created from XContent or via Java API.\n     ",
      "vertexLabel": "RangeQueryBuilder from()"
    },
    {
      "vertexName": "Method public static BytesReference toXContent(ToXContent toXContent, XContentType xContentType, Params params, boolean humanReadable) throws IOException  (XContentHelper.java)",
      "children": [
        {
          "name": "Method public static BytesReference toXContent(ToXContent toXContent, XContentType xContentType, boolean humanReadable) throws IOException  (XContentHelper.java)"
        }
      ],
      "comment": "\n     * Returns the bytes that represent the XContent output of the provided {@link ToXContent} object, using the provided\n     * {@link XContentType}. Wraps the output into a new anonymous object according to the value returned\n     * by the {@link ToXContent#isFragment()} method returns.\n     ",
      "vertexLabel": "BytesReference toXContent()"
    },
    {
      "vertexName": "Class RefreshRequestBuilder  (RefreshRequestBuilder.java)",
      "comment": "\n * A refresh request making all operations performed since the last refresh available for search. The (near) real-time\n * capabilities depends on the index engine used. For example, the internal one requires refresh to be called, but by\n * default a refresh is scheduled periodically.\n ",
      "vertexLabel": "Class RefreshRequestBuilder"
    },
    {
      "vertexName": "Method public Iterable<K> keys()  (Cache.java)",
      "children": [
        {
          "name": "Method public Iterable<V> values()  (Cache.java)"
        }
      ],
      "comment": "\n     * An LRU sequencing of the keys in the cache that supports removal. This sequence is not protected from mutations\n     * to the cache (except for {@link Iterator#remove()}. The result of iteration under any other mutation is\n     * undefined.\n     *\n     * @return an LRU-ordered {@link Iterable} over the keys in the cache\n     ",
      "vertexLabel": "Iterable<K> keys()"
    },
    {
      "vertexName": "Interface ConvertedConstantBinding  (ConvertedConstantBinding.java)",
      "comment": "\n * A binding created from converting a bound instance to a new type. The source binding has the same\n * binding annotation but a different type.\n *\n * @author jessewilson@google.com (Jesse Wilson)\n * @since 2.0\n ",
      "vertexLabel": "Interface ConvertedConstantBinding"
    },
    {
      "vertexName": "Method public String[] filteringAliases(ClusterState state, String index, String... expressions)  (IndexNameExpressionResolver.java)",
      "comment": "\n     * Iterates through the list of indices and selects the effective list of filtering aliases for the\n     * given index.\n     * <p>Only aliases with filters are returned. If the indices list contains a non-filtering reference to\n     * the index itself - null is returned. Returns {@code null} if no filtering is required.\n     ",
      "vertexLabel": "String[] filteringAliases()"
    },
    {
      "vertexName": "Method AggregationBuilder parse(String aggregationName, XContentParser parser) throws IOException  (Aggregator.java)",
      "children": [
        {
          "name": "Method PipelineAggregationBuilder parse(String pipelineAggregatorName, XContentParser parser) throws IOException  (PipelineAggregator.java)"
        }
      ],
      "comment": "\n         * Returns the aggregator factory with which this parser is associated, may return {@code null} indicating the\n         * aggregation should be skipped (e.g. when trying to aggregate on unmapped fields).\n         *\n         * @param aggregationName   The name of the aggregation\n         * @param parser            The parser\n         * @return                  The resolved aggregator factory or {@code null} in case the aggregation should be skipped\n         * @throws java.io.IOException      When parsing fails\n         ",
      "vertexLabel": "AggregationBuilder parse()"
    },
    {
      "vertexName": "Method public void setMinDocFreq(int minDocFreq)  (XMoreLikeThis.java)",
      "comment": "\n     * Sets the frequency at which words will be ignored which do not occur in at least this\n     * many docs.\n     *\n     * @param minDocFreq the frequency at which words will be ignored which do not occur in at\n     * least this many docs.\n     ",
      "vertexLabel": "void setMinDocFreq()"
    },
    {
      "vertexName": "Method private SimpleTopDocsCollectorContext(IndexReader reader, Query query, @Nullable SortAndFormats sortAndFormats, @Nullable ScoreDoc searchAfter, int numHits, boolean trackMaxScore, boolean trackTotalHits, boolean hasFilterCollector) throws IOException  (TopDocsCollectorContext.java)",
      "children": [
        {
          "name": "Method private CollapsingTopDocsCollectorContext(CollapseContext collapseContext, @Nullable SortAndFormats sortAndFormats, int numHits, boolean trackMaxScore)  (TopDocsCollectorContext.java)"
        },
        {
          "name": "Method private EmptyTopDocsCollectorContext(IndexReader reader, Query query, boolean trackTotalHits, boolean hasFilterCollector) throws IOException  (TopDocsCollectorContext.java)"
        },
        {
          "name": "Method static TopDocsCollectorContext createTopDocsCollectorContext(SearchContext searchContext, IndexReader reader, boolean hasFilterCollector) throws IOException  (TopDocsCollectorContext.java)"
        }
      ],
      "comment": "\n         * Ctr\n         * @param reader The index reader\n         * @param query The Lucene query\n         * @param sortAndFormats The query sort\n         * @param numHits The number of top hits to retrieve\n         * @param searchAfter The doc this request should \"search after\"\n         * @param trackMaxScore True if max score should be tracked\n         * @param trackTotalHits True if the total number of hits should be tracked\n         * @param hasFilterCollector True if the collector chain contains at least one collector that can filters document\n         ",
      "vertexLabel": "SimpleTopDocsCollectorContext()"
    },
    {
      "vertexName": "Method public SearchRequest types(String... types)  (SearchRequest.java)",
      "comment": "\n     * The document types to execute the search against. Defaults to be executed against\n     * all types.\n     * @deprecated Types are going away, prefer filtering on a type.\n     ",
      "vertexLabel": "SearchRequest types()"
    },
    {
      "vertexName": "Method public IndexFieldData.Builder fielddataBuilder(String fullyQualifiedIndexName)  (MappedFieldType.java)",
      "children": [
        {
          "name": "Method protected final void failIfNoDocValues()  (MappedFieldType.java)"
        }
      ],
      "comment": " Return a fielddata builder for this field\n     *  @throws IllegalArgumentException if the fielddata is not supported on this type.\n     *  An IllegalArgumentException is needed in order to return an http error 400\n     *  when this error occurs in a request. see: {@link org.elasticsearch.ExceptionsHelper#status}\n     *\n     * @param fullyQualifiedIndexName the name of the index this field-data is build for\n     * ",
      "vertexLabel": "IndexFieldData.Builder fielddataBuilder()"
    },
    {
      "vertexName": "Method public long getLastSyncedGlobalCheckpoint()  (IndexShard.java)",
      "children": [
        {
          "name": "Method public abstract long getLastSyncedGlobalCheckpoint()  (Engine.java)"
        }
      ],
      "comment": "\n     * Returns the latest global checkpoint value that has been persisted in the underlying storage (i.e. translog's checkpoint)\n     ",
      "vertexLabel": "long getLastSyncedGlobalCheckpoint()"
    },
    {
      "vertexName": "Method public Setting(String key, String defaultValue, Function<String, T> parser, Property... properties)  (Setting.java)",
      "children": [
        {
          "name": "Method public static Setting<String> simpleString(String key, String defaultValue, Property... properties)  (Setting.java)"
        }
      ],
      "comment": "\n     * Creates a new Setting instance\n     * @param key the settings key for this setting.\n     * @param defaultValue a default value.\n     * @param parser a parser that parses the string rep into a complex datatype.\n     * @param properties properties for this setting like scope, filtering...\n     ",
      "vertexLabel": "Setting()"
    },
    {
      "vertexName": "Method public IndicesStatsRequest groups(String... groups)  (IndicesStatsRequest.java)",
      "children": [
        {
          "name": "Method public CommonStatsFlags groups(String... groups)  (CommonStatsFlags.java)"
        }
      ],
      "comment": "\n     * Sets specific search group stats to retrieve the stats for. Mainly affects search\n     * when enabled.\n     ",
      "vertexLabel": "IndicesStatsRequest groups()"
    },
    {
      "vertexName": "Method protected AbstractBulkIndexByScrollRequest(SearchRequest searchRequest, boolean setDefaults)  (AbstractBulkIndexByScrollRequest.java)",
      "children": [
        {
          "name": "Method public AbstractBulkByScrollRequest(SearchRequest searchRequest, boolean setDefaults)  (AbstractBulkByScrollRequest.java)"
        }
      ],
      "comment": "\n     * Constructor for actual use.\n     *\n     * @param searchRequest the search request to execute to get the documents to process\n     * @param setDefaults should this request set the defaults on the search request? Usually set to true but leave it false to support\n     *        request slicing\n     ",
      "vertexLabel": "AbstractBulkIndexByScrollRequest()"
    },
    {
      "vertexName": "Method public abstract Translog.Snapshot readHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException  (Engine.java)",
      "children": [
        {
          "name": "Method public Translog.Snapshot readHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException  (InternalEngine.java)"
        }
      ],
      "comment": "\n     * Creates a new history snapshot for reading operations since {@code startingSeqNo} (inclusive).\n     * The returned snapshot can be retrieved from either Lucene index or translog files.\n     ",
      "vertexLabel": "abstract Translog.Snapshot readHistoryOperations()"
    },
    {
      "vertexName": "Method public static Injector createInjector(Stage stage, Iterable<? extends Module> modules)  (Guice.java)",
      "children": [
        {
          "name": "Method public static Injector createInjector(Stage stage, Module... modules)  (Guice.java)"
        }
      ],
      "comment": "\n     * Creates an injector for the given set of modules, in a given development\n     * stage.\n     *\n     * @throws CreationException if one or more errors occur during Injector\n     *                           construction\n     ",
      "vertexLabel": "Injector createInjector()"
    },
    {
      "vertexName": "Method public boolean hasPendingAsyncFetch()  (RoutingAllocation.java)",
      "comment": "\n     * Returns <code>true</code> iff the current allocation run has not processed all of the in-flight or available\n     * shard or store fetches. Otherwise <code>true</code>\n     ",
      "vertexLabel": "boolean hasPendingAsyncFetch()"
    },
    {
      "vertexName": "Method public Task executeLocally(Action<Response> action, Request request, ActionListener<Response> listener)  (NodeClient.java)",
      "children": [
        {
          "name": "Method public Task executeLocally(Action<Response> action, Request request, TaskListener<Response> listener)  (NodeClient.java)"
        }
      ],
      "comment": "\n     * Execute an {@link Action} locally, returning that {@link Task} used to track it, and linking an {@link ActionListener}. Prefer this\n     * method if you don't need access to the task when listening for the response. This is the method used to implement the {@link Client}\n     * interface.\n     ",
      "vertexLabel": "Task executeLocally()"
    },
    {
      "vertexName": "Method public SignificantTextAggregationBuilder shardSize(int shardSize)  (SignificantTextAggregationBuilder.java)",
      "children": [
        {
          "name": "Method public TermsAggregationBuilder shardSize(int shardSize)  (TermsAggregationBuilder.java)"
        }
      ],
      "comment": "\n     * Sets the shard_size - indicating the number of term buckets each shard\n     * will return to the coordinating node (the node that coordinates the\n     * search execution). The higher the shard size is, the more accurate the\n     * results are.\n     ",
      "vertexLabel": "SignificantTextAggregationBuilder shardSize()"
    },
    {
      "vertexName": "Method public MultiMatchQueryBuilder tieBreaker(Float tieBreaker)  (MultiMatchQueryBuilder.java)",
      "children": [
        {
          "name": "Method public MultiMatchQueryBuilder tieBreaker(float tieBreaker)  (MultiMatchQueryBuilder.java)"
        }
      ],
      "comment": "\n     * <p>Tie-Breaker for \"best-match\" disjunction queries (OR-Queries).\n     * The tie breaker capability allows documents that match more than one query clause\n     * (in this case on more than one field) to be scored better than documents that\n     * match only the best of the fields, without confusing this with the better case of\n     * two distinct matches in the multiple fields.</p>\n     *\n     * <p>A tie-breaker value of {@code 1.0} is interpreted as a signal to score queries as\n     * \"most-match\" queries where all matching query clauses are considered for scoring.</p>\n     *\n     * @see Type\n     ",
      "vertexLabel": "MultiMatchQueryBuilder tieBreaker()"
    },
    {
      "vertexName": "Method public E coordinate(double longitude, double latitude)  (ShapeBuilder.java)",
      "children": [
        {
          "name": "Method public CoordinatesBuilder coordinate(double longitude, double latitude)  (CoordinatesBuilder.java)"
        }
      ],
      "comment": "\n     * Add a new coordinate to the collection\n     * @param longitude longitude of the coordinate\n     * @param latitude latitude of the coordinate\n     * @return this\n     ",
      "vertexLabel": "E coordinate()"
    },
    {
      "vertexName": "Method public void deleteIndexDirectorySafe(Index index, long lockTimeoutMS, IndexSettings indexSettings) throws IOException, ShardLockObtainFailedException  (NodeEnvironment.java)",
      "children": [
        {
          "name": "Method public List<ShardLock> lockAllForIndex(Index index, IndexSettings settings, long lockTimeoutMS) throws ShardLockObtainFailedException  (NodeEnvironment.java)"
        }
      ],
      "comment": "\n     * Deletes an indexes data directory recursively iff all of the indexes\n     * shards locks were successfully acquired. If any of the indexes shard directories can't be locked\n     * non of the shards will be deleted\n     *\n     * @param index the index to delete\n     * @param lockTimeoutMS how long to wait for acquiring the indices shard locks\n     * @param indexSettings settings for the index being deleted\n     * @throws IOException if any of the shards data directories can't be locked or deleted\n     ",
      "vertexLabel": "void deleteIndexDirectorySafe()"
    },
    {
      "vertexName": "Method public Path resolveCustomLocation(IndexSettings indexSettings, final ShardId shardId)  (NodeEnvironment.java)",
      "children": [
        {
          "name": "Method public static Path resolveBaseCustomLocation(IndexSettings indexSettings, Path sharedDataPath, int nodeLockId)  (NodeEnvironment.java)"
        }
      ],
      "comment": "\n     * Resolve the custom path for a index's shard.\n     * Uses the {@code IndexMetaData.SETTING_DATA_PATH} setting to determine\n     * the root path for the index.\n     *\n     * @param indexSettings settings for the index\n     * @param shardId shard to resolve the path to\n     ",
      "vertexLabel": "Path resolveCustomLocation()"
    },
    {
      "vertexName": "Method public static boolean isAllTypes(String[] types)  (MetaData.java)",
      "comment": "\n     * Identifies whether the array containing type names given as argument refers to all types\n     * The empty or null array identifies all types\n     *\n     * @param types the array containing types\n     * @return true if the provided array maps to all types, false otherwise\n     ",
      "vertexLabel": "boolean isAllTypes()"
    },
    {
      "vertexName": "Method public synchronized IndexService createIndex(final IndexMetaData indexMetaData, final List<IndexEventListener> builtInListeners) throws IOException  (IndicesService.java)",
      "comment": "\n     * Creates a new {@link IndexService} for the given metadata.\n     *\n     * @param indexMetaData          the index metadata to create the index for\n     * @param builtInListeners       a list of built-in lifecycle {@link IndexEventListener} that should should be used along side with the\n     *                               per-index listeners\n     * @throws ResourceAlreadyExistsException if the index already exists.\n     ",
      "vertexLabel": "synchronized IndexService createIndex()"
    },
    {
      "vertexName": "Method public static Path resolveBaseCustomLocation(IndexSettings indexSettings, Path sharedDataPath, int nodeLockId)  (NodeEnvironment.java)",
      "comment": "\n     * Resolve the custom path for a index's shard.\n     * Uses the {@code IndexMetaData.SETTING_DATA_PATH} setting to determine\n     * the root path for the index.\n     *\n     * @param indexSettings settings for the index\n     ",
      "vertexLabel": "Path resolveBaseCustomLocation()"
    },
    {
      "vertexName": "Method public PolygonBuilder hole(LineStringBuilder hole)  (PolygonBuilder.java)",
      "comment": "\n     * Add a new hole to the polygon\n     * @param hole linear ring defining the hole\n     * @return this\n     ",
      "vertexLabel": "PolygonBuilder hole()"
    },
    {
      "vertexName": "Method public static WrapperQueryBuilder wrapperQuery(byte[] source)  (QueryBuilders.java)",
      "children": [
        {
          "name": "Method public static WrapperQueryBuilder wrapperQuery(String source)  (QueryBuilders.java)"
        }
      ],
      "comment": "\n     * A Query builder which allows building a query thanks to a JSON string or binary data.\n     ",
      "vertexLabel": "WrapperQueryBuilder wrapperQuery()"
    },
    {
      "vertexName": "Method public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale)  (Joda.java)",
      "comment": "\n         * We adjust the instant by displayOffset to adjust for the offset that might have been added in\n         * {@link DateTimeFormatter#printTo(Appendable, long, Chronology)} when using a time zone.\n         ",
      "vertexLabel": "void printTo()"
    },
    {
      "vertexName": "Method private long getCgroupCpuAcctCpuCfsPeriodMicros(final String controlGroup) throws IOException  (OsProbe.java)",
      "children": [
        {
          "name": "Method private OsStats.Cgroup.CpuStat getCgroupCpuAcctCpuStat(final String controlGroup) throws IOException  (OsProbe.java)"
        }
      ],
      "comment": "\n     * The total period of time in microseconds for how frequently the Elasticsearch control group's access to CPU resources will be\n     * reallocated.\n     *\n     * @param controlGroup the control group for the Elasticsearch process for the {@code cpuacct} subsystem\n     * @return the CFS quota period in microseconds\n     * @throws IOException if an I/O exception occurs reading {@code cpu.cfs_period_us} for the control group\n     ",
      "vertexLabel": "long getCgroupCpuAcctCpuCfsPeriodMicros()"
    },
    {
      "vertexName": "Method public FunctionScoreQueryBuilder(QueryBuilder query, ScoreFunctionBuilder<?> scoreFunctionBuilder)  (FunctionScoreQueryBuilder.java)",
      "children": [
        {
          "name": "Method public FunctionScoreQueryBuilder(ScoreFunctionBuilder<?> scoreFunctionBuilder)  (FunctionScoreQueryBuilder.java)"
        }
      ],
      "comment": "\n     * Creates a function_score query that will execute the function provided in the context of the provided query\n     *\n     * @param query the query to custom score\n     * @param scoreFunctionBuilder score function that is executed\n     ",
      "vertexLabel": "FunctionScoreQueryBuilder()"
    },
    {
      "vertexName": "Method public ScalingExecutorBuilder(final String name, final int core, final int max, final TimeValue keepAlive)  (ScalingExecutorBuilder.java)",
      "comment": "\n     * Construct a scaling executor builder; the settings will have the\n     * key prefix \"thread_pool.\" followed by the executor name.\n     *\n     * @param name      the name of the executor\n     * @param core      the minimum number of threads in the pool\n     * @param max       the maximum number of threads in the pool\n     * @param keepAlive the time that spare threads above {@code core}\n     *                  threads will be kept alive\n     ",
      "vertexLabel": "ScalingExecutorBuilder()"
    },
    {
      "vertexName": "Method public SearchSourceBuilder postFilter(QueryBuilder postFilter)  (SearchSourceBuilder.java)",
      "children": [
        {
          "name": "Method public SearchRequestBuilder setPostFilter(QueryBuilder postFilter)  (SearchRequestBuilder.java)"
        }
      ],
      "comment": "\n     * Sets a filter that will be executed after the query has been executed and\n     * only has affect on the search hits (not aggregations). This filter is\n     * always executed as last filtering mechanism.\n     ",
      "vertexLabel": "SearchSourceBuilder postFilter()"
    },
    {
      "vertexName": "Method void hear(TypeLiteral<I> type, TypeEncounter<I> encounter)  (TypeListener.java)",
      "children": [
        {
          "name": "Interface TypeEncounter  (TypeEncounter.java)"
        }
      ],
      "comment": "\n     * Invoked when Guice encounters a new type eligible for constructor or members injection.\n     * Called during injector creation (or afterwords if Guice encounters a type at run time and\n     * creates a JIT binding).\n     *\n     * @param type      encountered by Guice\n     * @param encounter context of this encounter, enables reporting errors, registering injection\n     *                  listeners and binding method interceptors for {@code type}.\n     * @param <I>       the injectable type\n     ",
      "vertexLabel": "void hear()"
    },
    {
      "vertexName": "Method public Integer getAsInt(String setting, Integer defaultValue)  (Settings.java)",
      "children": [
        {
          "name": "Method public String get(String setting, String defaultValue)  (Settings.java)"
        }
      ],
      "comment": "\n     * Returns the setting value (as int) associated with the setting key. If it does not exists,\n     * returns the default value provided.\n     ",
      "vertexLabel": "Integer getAsInt()"
    },
    {
      "vertexName": "Method public boolean completed()  (SnapshotIndexShardStage.java)",
      "children": [
        {
          "name": "Method public boolean completed()  (SnapshotState.java)"
        }
      ],
      "comment": "\n     * Returns true if snapshot completed (successfully or not)\n     *\n     * @return true if snapshot completed, false otherwise\n     ",
      "vertexLabel": "boolean completed()"
    },
    {
      "vertexName": "Method public synchronized void addAffixMapUpdateConsumer(Setting.AffixSetting<T> setting, Consumer<Map<String, T>> consumer, BiConsumer<String, T> validator)  (AbstractScopedSettings.java)",
      "children": [
        {
          "name": "Method public synchronized void addAffixUpdateConsumer(Setting.AffixSetting<T> setting, BiConsumer<String, T> consumer, BiConsumer<String, T> validator)  (AbstractScopedSettings.java)"
        }
      ],
      "comment": "\n     * Adds a settings consumer for affix settings. Affix settings have a namespace associated to it that needs to be available to the\n     * consumer in order to be processed correctly. This consumer will get a namespace to value map instead of each individual namespace\n     * and value as in {@link #addAffixUpdateConsumer(Setting.AffixSetting, BiConsumer, BiConsumer)}\n     ",
      "vertexLabel": "synchronized void addAffixMapUpdateConsumer()"
    },
    {
      "vertexName": "Class OutOfScopeException  (OutOfScopeException.java)",
      "comment": "\n * Thrown from {@link Provider#get} when an attempt is made to access a scoped\n * object while the scope in question is not currently active.\n *\n * @author kevinb@google.com (Kevin Bourrillion)\n * @since 2.0\n ",
      "vertexLabel": "Class OutOfScopeException"
    },
    {
      "vertexName": "Method public ElasticsearchException[] guessRootCauses()  (ElasticsearchException.java)",
      "comment": "\n     * Returns the root cause of this exception or multiple if different shards caused different exceptions\n     ",
      "vertexLabel": "ElasticsearchException[] guessRootCauses()"
    },
    {
      "vertexName": "Method public double getTimeInSeconds()  (ThreadBarrier.java)",
      "comment": "\n         * Returns the elapsed time between two successive barrier executions.\n         *\n         * @return elapsed time in seconds.\n         ",
      "vertexLabel": "double getTimeInSeconds()"
    },
    {
      "vertexName": "Method public abstract boolean validateVersionForWrites(long version)  (VersionType.java)",
      "comment": "\n     * validate the version is a valid value for this type when writing.\n     *\n     * @return true if valid, false o.w\n     ",
      "vertexLabel": "abstract boolean validateVersionForWrites()"
    },
    {
      "vertexName": "Method public static ObjectObjectHashMap<K, V> ensureNoNullKeys(int expectedElements)  (HppcMaps.java)",
      "children": [
        {
          "name": "Method public static ObjectObjectHashMap<K, V> newMap(int expectedElements)  (HppcMaps.java)"
        }
      ],
      "comment": "\n     * Wraps the given map and prevent adding of <code>null</code> keys.\n     * \n     * @param expectedElements\n     *          The expected number of elements guaranteed not to cause buffer\n     *          expansion (inclusive).\n     ",
      "vertexLabel": "ObjectObjectHashMap<K, V> ensureNoNullKeys()"
    },
    {
      "vertexName": "Method static String getShortPathName(String path)  (JNANatives.java)",
      "comment": "\n     * Retrieves the short path form of the specified path.\n     *\n     * @param path the path\n     * @return the short path name (or the original path if getting the short path name fails for any reason)\n     ",
      "vertexLabel": "String getShortPathName()"
    },
    {
      "vertexName": "Field maxRetries  (AbstractBulkByScrollRequest.java)",
      "comment": "\n     * Total number of retries attempted for rejections. There is no way to ask for unlimited retries.\n     ",
      "vertexLabel": "Field maxRetries"
    },
    {
      "vertexName": "Method public static IndicesOptions strictExpandOpenAndForbidClosedIgnoreThrottled()  (IndicesOptions.java)",
      "children": [
        {
          "name": "Method public static IndicesOptions strictExpandOpenAndForbidClosed()  (IndicesOptions.java)"
        }
      ],
      "comment": "\n     * @return indices options that requires every specified index to exist, expands wildcards only to open indices,\n     *         allows that no indices are resolved from wildcard expressions (not returning an error) and forbids the\n     *         use of closed indices by throwing an error and ignores indices that are throttled.\n     ",
      "vertexLabel": "IndicesOptions strictExpandOpenAndForbidClosedIgnoreThrottled()"
    },
    {
      "vertexName": "Method public static SpanWithinQueryBuilder spanWithinQuery(SpanQueryBuilder big, SpanQueryBuilder little)  (QueryBuilders.java)",
      "children": [
        {
          "name": "Method public SpanContainingQueryBuilder(SpanQueryBuilder big, SpanQueryBuilder little)  (SpanContainingQueryBuilder.java)"
        }
      ],
      "comment": " Creates a new {@code span_within} builder.\n    * @param big the big clause, it must enclose {@code little} for a match.\n    * @param little the little clause, it must be contained within {@code big} for a match.\n    ",
      "vertexLabel": "SpanWithinQueryBuilder spanWithinQuery()"
    },
    {
      "vertexName": "Method public static byte[] doubleToBytes(double val)  (Numbers.java)",
      "children": [
        {
          "name": "Method public static byte[] floatToBytes(float val)  (Numbers.java)"
        }
      ],
      "comment": "\n     * Converts a double to a byte array.\n     *\n     * @param val The double to convert to a byte array\n     * @return The byte array converted\n     ",
      "vertexLabel": "byte[] doubleToBytes()"
    },
    {
      "vertexName": "Method public abstract boolean shouldRollTranslogGeneration()  (Engine.java)",
      "comment": "\n     * Tests whether or not the translog generation should be rolled to a new generation.\n     * This test is based on the size of the current generation compared to the configured generation threshold size.\n     *\n     * @return {@code true} if the current generation should be rolled to a new generation\n     ",
      "vertexLabel": "abstract boolean shouldRollTranslogGeneration()"
    },
    {
      "vertexName": "Method public UpdateRequestBuilder setDoc(Object... source)  (UpdateRequestBuilder.java)",
      "children": [
        {
          "name": "Method public UpdateRequest doc(Object... source)  (UpdateRequest.java)"
        }
      ],
      "comment": "\n     * Sets the doc to use for updates when a script is not specified, the doc provided\n     * is a field and value pairs.\n     ",
      "vertexLabel": "UpdateRequestBuilder setDoc()"
    },
    {
      "vertexName": "Method public static double linearWeightedAvg(double[] values)  (MovingFunctions.java)",
      "children": [
        {
          "name": "Method public static double unweightedAvg(double[] values)  (MovingFunctions.java)"
        },
        {
          "name": "Class LinearModel  (LinearModel.java)"
        }
      ],
      "comment": "\n     * Calculate a linearly weighted moving average, such that older values are\n     * linearly less important.  \"Time\" is determined by position in collection\n     *\n     * Only finite values are averaged.  NaN or null are ignored.\n     * If all values are missing/null/NaN, the return value will be NaN\n     * The average is based on the count of non-null, non-NaN values.\n     ",
      "vertexLabel": "double linearWeightedAvg()"
    },
    {
      "vertexName": "Method public static ConcurrentMap<K, V> newConcurrentMapWithAggressiveConcurrency()  (ConcurrentCollections.java)",
      "comment": "\n     * Creates a new CHM with an aggressive concurrency level, aimed at high concurrent update rate long living maps.\n     ",
      "vertexLabel": "ConcurrentMap<K, V> newConcurrentMapWithAggressiveConcurrency()"
    },
    {
      "vertexName": "Method public UpdateRequestBuilder setVersion(long version)  (UpdateRequestBuilder.java)",
      "children": [
        {
          "name": "Method public IndexRequestBuilder setVersion(long version)  (IndexRequestBuilder.java)"
        }
      ],
      "comment": "\n     * Sets the version, which will cause the index operation to only be performed if a matching\n     * version exists and no changes happened on the doc since then.\n     ",
      "vertexLabel": "UpdateRequestBuilder setVersion()"
    },
    {
      "vertexName": "Method ActionFuture<RefreshResponse> refresh(RefreshRequest request)  (IndicesAdminClient.java)",
      "children": [
        {
          "name": "Method RefreshRequestBuilder prepareRefresh(String... indices)  (IndicesAdminClient.java)"
        }
      ],
      "comment": "\n     * Explicitly refresh one or more indices (making the content indexed since the last refresh searchable).\n     *\n     * @param request The refresh request\n     * @return The result future\n     * @see org.elasticsearch.client.Requests#refreshRequest(String...)\n     ",
      "vertexLabel": "ActionFuture<RefreshResponse> refresh()"
    },
    {
      "vertexName": "Method public TermsAggregationBuilder order(BucketOrder order)  (TermsAggregationBuilder.java)",
      "comment": " Set a new order on this builder and return the builder so that calls\n     *  can be chained. A tie-breaker may be added to avoid non-deterministic ordering. ",
      "vertexLabel": "TermsAggregationBuilder order()"
    },
    {
      "vertexName": "Method Object format(double value)  (DocValueFormat.java)",
      "children": [
        {
          "name": "Method Object format(long value)  (DocValueFormat.java)"
        }
      ],
      "comment": " Format a double value. This is used by terms and stats aggregations\n     *  to format keys for fields that use numbers as a doc value representation\n     *  such as the {@code long}, {@code double} or {@code date} fields. ",
      "vertexLabel": "Object format()"
    },
    {
      "vertexName": "Method public HighlightBuilder field(String name, int fragmentSize, int numberOfFragments)  (HighlightBuilder.java)",
      "children": [
        {
          "name": "Method public HighlightBuilder field(String name, int fragmentSize)  (HighlightBuilder.java)"
        }
      ],
      "comment": "\n     * Adds a field to be highlighted with a provided fragment size (in characters), and\n     * a provided (maximum) number of fragments.\n     *\n     * @param name              The field to highlight\n     * @param fragmentSize      The size of a fragment in characters\n     * @param numberOfFragments The (maximum) number of fragments\n     ",
      "vertexLabel": "HighlightBuilder field()"
    },
    {
      "vertexName": "Class AbstractSortedDocValues  (AbstractSortedDocValues.java)",
      "comment": "\n * Base implementation that throws an {@link IOException} for the\n * {@link DocIdSetIterator} APIs. This impl is safe to use for sorting and\n * aggregations, which only use {@link #advanceExact(int)} and\n * {@link #ordValue()}.\n ",
      "vertexLabel": "Class AbstractSortedDocValues"
    },
    {
      "vertexName": "Method public static AllocateUnassignedDecision no(AllocationStatus allocationStatus, @Nullable List<NodeAllocationResult> decisions)  (AllocateUnassignedDecision.java)",
      "comment": "\n     * Returns a NO decision with the given {@link AllocationStatus}, and the individual node-level\n     * decisions that comprised the final NO decision if in explain mode.\n     ",
      "vertexLabel": "AllocateUnassignedDecision no()"
    },
    {
      "vertexName": "Method public void waitForOpsToComplete(final long seqNo) throws InterruptedException  (IndexShard.java)",
      "children": [
        {
          "name": "Method public synchronized void waitForOpsToComplete(final long seqNo) throws InterruptedException  (LocalCheckpointTracker.java)"
        }
      ],
      "comment": "\n     * Waits for all operations up to the provided sequence number to complete.\n     *\n     * @param seqNo the sequence number that the checkpoint must advance to before this method returns\n     * @throws InterruptedException if the thread was interrupted while blocking on the condition\n     ",
      "vertexLabel": "void waitForOpsToComplete()"
    },
    {
      "vertexName": "Method public static ShardId selectSplitShard(int shardId, IndexMetaData sourceIndexMetadata, int numTargetShards)  (IndexMetaData.java)",
      "comment": "\n     * Returns the source shard ID to split the given target shard off\n     * @param shardId the id of the target shard to split into\n     * @param sourceIndexMetadata the source index metadata\n     * @param numTargetShards the total number of shards in the target index\n     * @return a the source shard ID to split off from\n     ",
      "vertexLabel": "ShardId selectSplitShard()"
    },
    {
      "vertexName": "Method public ClusterSearchShardsRequestBuilder setIndicesOptions(IndicesOptions indicesOptions)  (ClusterSearchShardsRequestBuilder.java)",
      "children": [
        {
          "name": "Method public DeleteIndexRequestBuilder setIndicesOptions(IndicesOptions options)  (DeleteIndexRequestBuilder.java)"
        }
      ],
      "comment": "\n     * Specifies what type of requested indices to ignore and how to deal indices wildcard expressions.\n     * For example indices that don't exist.\n     ",
      "vertexLabel": "ClusterSearchShardsRequestBuilder setIndicesOptions()"
    },
    {
      "vertexName": "Method public IndicesStatsRequest types(String... types)  (IndicesStatsRequest.java)",
      "children": [
        {
          "name": "Method public CommonStatsFlags types(String... types)  (CommonStatsFlags.java)"
        }
      ],
      "comment": "\n     * Document types to return stats for. Mainly affects {@link #indexing(boolean)} when\n     * enabled, returning specific indexing stats for those types.\n     ",
      "vertexLabel": "IndicesStatsRequest types()"
    },
    {
      "vertexName": "Method public Builder put(String setting, long value, ByteSizeUnit sizeUnit)  (Settings.java)",
      "children": [
        {
          "name": "Method public Builder put(String setting, int value)  (Settings.java)"
        }
      ],
      "comment": "\n         * Sets the setting with the provided setting key and the size value.\n         *\n         * @param setting The setting key\n         * @param value   The size value\n         * @return The builder\n         ",
      "vertexLabel": "Builder put()"
    },
    {
      "vertexName": "Method public SearchRequest requestCache(Boolean requestCache)  (SearchRequest.java)",
      "comment": "\n     * Sets if this request should use the request cache or not, assuming that it can (for\n     * example, if \"now\" is used, it will never be cached). By default (not set, or null,\n     * will default to the index level setting if request cache is enabled or not).\n     ",
      "vertexLabel": "SearchRequest requestCache()"
    },
    {
      "vertexName": "EnumConstant NO_LONGER_ASSIGNED  (IndicesClusterStateService.java)",
      "children": [
        {
          "name": "EnumConstant CLOSED  (IndicesClusterStateService.java)"
        }
      ],
      "comment": "\n             * Shard of this index were previously assigned to this node but all shards have been relocated.\n             * The index should be removed and all associated resources released. Persistent parts of the index\n             * like the shards files, state and transaction logs are kept around in the case of a disaster recovery.\n             ",
      "vertexLabel": "EnumConstant NO_LONGER_ASSIGNED"
    },
    {
      "vertexName": "Method String readSysFsCgroupMemoryUsageInBytes(final String controlGroup) throws IOException  (OsProbe.java)",
      "children": [
        {
          "name": "Method String readSysFsCgroupMemoryLimitInBytes(final String controlGroup) throws IOException  (OsProbe.java)"
        }
      ],
      "comment": "\n     * Returns the line from {@code memory.usage_in_bytes} for the control group to which the Elasticsearch process belongs for the\n     * {@code memory} subsystem. This line represents the total current memory usage by processes in the cgroup (in bytes).\n     *\n     * @param controlGroup the control group to which the Elasticsearch process belongs for the {@code memory} subsystem\n     * @return the line from {@code memory.usage_in_bytes}\n     * @throws IOException if an I/O exception occurs reading {@code memory.usage_in_bytes} for the control group\n     ",
      "vertexLabel": "String readSysFsCgroupMemoryUsageInBytes()"
    },
    {
      "vertexName": "Method protected final void failIfNoDocValues()  (MappedFieldType.java)",
      "comment": " @throws IllegalArgumentException if the fielddata is not supported on this type.\n     *  An IllegalArgumentException is needed in order to return an http error 400\n     *  when this error occurs in a request. see: {@link org.elasticsearch.ExceptionsHelper#status}\n     *",
      "vertexLabel": "final void failIfNoDocValues()"
    },
    {
      "vertexName": "Method public UpdateRequest waitForActiveShards(final int waitForActiveShards)  (UpdateRequest.java)",
      "children": [
        {
          "name": "Method public BulkRequest waitForActiveShards(final int waitForActiveShards)  (BulkRequest.java)"
        }
      ],
      "comment": "\n     * A shortcut for {@link #waitForActiveShards(ActiveShardCount)} where the numerical\n     * shard count is passed in, instead of having to first call {@link ActiveShardCount#from(int)}\n     * to get the ActiveShardCount.\n     ",
      "vertexLabel": "UpdateRequest waitForActiveShards()"
    },
    {
      "vertexName": "Method public Self setRetryBackoffInitialTime(TimeValue retryBackoffInitialTime)  (AbstractBulkByScrollRequestBuilder.java)",
      "children": [
        {
          "name": "Field retryBackoffInitialTime  (AbstractBulkByScrollRequest.java)"
        }
      ],
      "comment": "\n     * Initial delay after a rejection before retrying a bulk request. With the default maxRetries the total backoff for retrying rejections\n     * is about one minute per bulk request. Once the entire bulk request is successful the retry counter resets.\n     ",
      "vertexLabel": "Self setRetryBackoffInitialTime()"
    },
    {
      "vertexName": "Method public QueryStringQueryParser(QueryShardContext context, Map<String, Float> fieldsAndWeights, boolean lenient)  (QueryStringQueryParser.java)",
      "children": [
        {
          "name": "Method public QueryStringQueryParser(QueryShardContext context, String defaultField, boolean lenient)  (QueryStringQueryParser.java)"
        },
        {
          "name": "Method public QueryStringQueryParser(QueryShardContext context, Map<String, Float> fieldsAndWeights)  (QueryStringQueryParser.java)"
        }
      ],
      "comment": "\n     * @param context The query shard context.\n     * @param fieldsAndWeights The default fields and weights expansion for query terms.\n     * @param lenient If set to `true` will cause format based failures (like providing text to a numeric field) to be ignored.\n     ",
      "vertexLabel": "QueryStringQueryParser()"
    },
    {
      "vertexName": "Method public SearchRequest preference(String preference)  (SearchRequest.java)",
      "comment": "\n     * Sets the preference to execute the search. Defaults to randomize across shards. Can be set to\n     * {@code _local} to prefer local shards or a custom value, which guarantees that the same order\n     * will be used across different requests.\n     ",
      "vertexLabel": "SearchRequest preference()"
    },
    {
      "vertexName": "Method public ImmutableOpenMap<String, List<AliasMetaData>> findAllAliases(final String[] concreteIndices)  (MetaData.java)",
      "comment": "\n     * Finds the specific index aliases that point to the requested concrete indices directly\n     * or that match with the indices via wildcards.\n     *\n     * @param concreteIndices The concrete indices that the aliases must point to in order to be returned.\n     * @return A map of index name to the list of aliases metadata. If a concrete index does not have matching\n     * aliases then the result will <b>not</b> include the index's key.\n     ",
      "vertexLabel": "ImmutableOpenMap<String, List<AliasMetaData>> findAllAliases()"
    },
    {
      "vertexName": "Method public static MessageDigest md5()  (MessageDigests.java)",
      "comment": "\n     * Returns a {@link MessageDigest} instance for MD5 digests; note\n     * that the instance returned is thread local and must not be\n     * shared amongst threads.\n     *\n     * @return a thread local {@link MessageDigest} instance that\n     * provides MD5 message digest functionality.\n     ",
      "vertexLabel": "MessageDigest md5()"
    },
    {
      "vertexName": "Method protected DirectoryReader wrap(DirectoryReader reader) throws IOException  (IndexSearcherWrapper.java)",
      "children": [
        {
          "name": "Method protected IndexSearcher wrap(IndexSearcher searcher) throws IOException  (IndexSearcherWrapper.java)"
        }
      ],
      "comment": "\n     * Wraps the given {@link DirectoryReader}. The wrapped reader can filter out document just like delete documents etc. but\n     * must not change any term or document content.\n     * <p>\n     * NOTE: The wrapper has a per-request lifecycle, must delegate {@link IndexReader#getReaderCacheHelper()},\n     * {@link LeafReader#getCoreCacheHelper()} and must be an instance of {@link FilterDirectoryReader} that\n     * eventually exposes the original reader via  {@link FilterDirectoryReader#getDelegate()}.\n     * The returned reader is closed once it goes out of scope.\n     * </p>\n     * @param reader The provided directory reader to be wrapped to add custom functionality\n     * @return a new directory reader wrapping the provided directory reader or if no wrapping was performed\n     *         the provided directory reader\n     ",
      "vertexLabel": "DirectoryReader wrap()"
    },
    {
      "vertexName": "Method protected AggregationBuilder doRewrite(QueryRewriteContext queryShardContext) throws IOException  (AggregationBuilder.java)",
      "children": [
        {
          "name": "Method QueryBuilder rewrite(QueryRewriteContext queryShardContext) throws IOException  (QueryBuilder.java)"
        }
      ],
      "comment": "\n     * Rewrites this aggregation builder into its primitive form. By default\n     * this method return the builder itself. If the builder did not change the\n     * identity reference must be returned otherwise the builder will be\n     * rewritten infinitely.\n     ",
      "vertexLabel": "AggregationBuilder doRewrite()"
    },
    {
      "vertexName": "Method public boolean keyed()  (HistogramAggregationBuilder.java)",
      "children": [
        {
          "name": "Method public boolean keyed()  (DateHistogramAggregationBuilder.java)"
        }
      ],
      "comment": " Return whether buckets should be returned as a hash. In case\n     *  {@code keyed} is false, buckets will be returned as an array. ",
      "vertexLabel": "boolean keyed()"
    },
    {
      "vertexName": "Method public TermSuggestionBuilder maxInspections(int maxInspections)  (TermSuggestionBuilder.java)",
      "children": [
        {
          "name": "Method public DirectCandidateGeneratorBuilder maxInspections(Integer maxInspections)  (DirectCandidateGeneratorBuilder.java)"
        }
      ],
      "comment": "\n     * A factor that is used to multiply with the size in order to inspect more\n     * candidate suggestions. Can improve accuracy at the cost of performance.\n     * Defaults to {@code 5}.\n     ",
      "vertexLabel": "TermSuggestionBuilder maxInspections()"
    },
    {
      "vertexName": "Method public static Map<String, T> readMap(String processorType, String processorTag, Map<String, Object> configuration, String propertyName)  (ConfigurationUtils.java)",
      "children": [
        {
          "name": "Method public static Map<String, T> readOptionalMap(String processorType, String processorTag, Map<String, Object> configuration, String propertyName)  (ConfigurationUtils.java)"
        }
      ],
      "comment": "\n     * Returns and removes the specified property of type map from the specified configuration map.\n     *\n     * If the property value isn't of type map an {@link ElasticsearchParseException} is thrown.\n     * If the property is missing an {@link ElasticsearchParseException} is thrown\n     ",
      "vertexLabel": "Map<String, T> readMap()"
    },
    {
      "vertexName": "Method public static BackoffPolicy exponentialBackoff(TimeValue initialDelay, int maxNumberOfRetries)  (BackoffPolicy.java)",
      "children": [
        {
          "name": "Method public static BackoffPolicy constantBackoff(TimeValue delay, int maxNumberOfRetries)  (BackoffPolicy.java)"
        }
      ],
      "comment": "\n     * Creates an new exponential backoff policy with the provided configuration.\n     *\n     * @param initialDelay       The initial delay defines how long to wait for the first retry attempt. Must not be null.\n     *                           Must be &lt;= <code>Integer.MAX_VALUE</code> ms.\n     * @param maxNumberOfRetries The maximum number of retries. Must be a non-negative number.\n     * @return A backoff policy with an exponential increase in wait time for retries. The returned instance is thread safe but each\n     * iterator created from it should only be used by a single thread.\n     ",
      "vertexLabel": "BackoffPolicy exponentialBackoff()"
    },
    {
      "vertexName": "Method public RestoreSnapshotRequestBuilder setIndexSettings(Map<String, Object> source)  (RestoreSnapshotRequestBuilder.java)",
      "comment": "\n     * Sets index settings that should be added or replaced during restore\n     *\n     * @param source index settings\n     * @return this builder\n     ",
      "vertexLabel": "RestoreSnapshotRequestBuilder setIndexSettings()"
    },
    {
      "vertexName": "Method public BoolQueryBuilder filter(QueryBuilder queryBuilder)  (BoolQueryBuilder.java)",
      "children": [
        {
          "name": "Method public BoolQueryBuilder must(QueryBuilder queryBuilder)  (BoolQueryBuilder.java)"
        }
      ],
      "comment": "\n     * Adds a query that <b>must</b> appear in the matching documents but will\n     * not contribute to scoring. No {@code null} value allowed.\n     ",
      "vertexLabel": "BoolQueryBuilder filter()"
    },
    {
      "vertexName": "Method public synchronized void updateGlobalCheckpointForShard(final String allocationId, final long globalCheckpoint)  (ReplicationTracker.java)",
      "comment": "\n     * Update the local knowledge of the global checkpoint for the specified allocation ID.\n     *\n     * @param allocationId     the allocation ID to update the global checkpoint for\n     * @param globalCheckpoint the global checkpoint\n     ",
      "vertexLabel": "synchronized void updateGlobalCheckpointForShard()"
    },
    {
      "vertexName": "Method public static void writeToChannel(byte[] source, int offset, int length, WritableByteChannel channel) throws IOException  (Channels.java)",
      "children": [
        {
          "name": "Method public static void writeToChannel(byte[] source, WritableByteChannel channel) throws IOException  (Channels.java)"
        }
      ],
      "comment": "\n     * Writes part of a byte array to a {@link java.nio.channels.WritableByteChannel}\n     *\n     * @param source  byte array to copy from\n     * @param offset  start copying from this offset\n     * @param length  how many bytes to copy\n     * @param channel target WritableByteChannel\n     ",
      "vertexLabel": "void writeToChannel()"
    },
    {
      "vertexName": "Method public synchronized void addAffixUpdateConsumer(Setting.AffixSetting<A> settingA, Setting.AffixSetting<B> settingB, BiConsumer<String, Tuple<A, B>> consumer, BiConsumer<String, Tuple<A, B>> validator)  (AbstractScopedSettings.java)",
      "children": [
        {
          "name": "Method public synchronized void addSettingsUpdateConsumer(Setting<A> a, Setting<B> b, BiConsumer<A, B> consumer, BiConsumer<A, B> validator)  (AbstractScopedSettings.java)"
        }
      ],
      "comment": "\n     * Adds a affix settings consumer that accepts the values for two settings. The consumer is only notified if one or both settings change\n     * and if the provided validator succeeded.\n     * <p>\n     * Note: Only settings registered in {@link SettingsModule} can be changed dynamically.\n     * </p>\n     * This method registers a compound updater that is useful if two settings are depending on each other.\n     * The consumer is always provided with both values even if only one of the two changes.\n     ",
      "vertexLabel": "synchronized void addAffixUpdateConsumer()"
    },
    {
      "vertexName": "Method public long runAsLong()  (AggregationScript.java)",
      "comment": "\n     * Return the result as a long. This is used by aggregation scripts over long fields.\n     ",
      "vertexLabel": "long runAsLong()"
    },
    {
      "vertexName": "Method public UpdateRequest retryOnConflict(int retryOnConflict)  (UpdateRequest.java)",
      "comment": "\n     * Sets the number of retries of a version conflict occurs because the document was updated between\n     * getting it and updating it. Defaults to 0.\n     ",
      "vertexLabel": "UpdateRequest retryOnConflict()"
    },
    {
      "vertexName": "Method public static ObjectObjectHashMap<K, V> newNoNullKeysMap(int expectedElements)  (HppcMaps.java)",
      "children": [
        {
          "name": "Method public static ObjectObjectHashMap<K, V> ensureNoNullKeys(int expectedElements)  (HppcMaps.java)"
        }
      ],
      "comment": "\n     * Returns a map like {@link #newMap(int)} that does not accept <code>null</code> keys\n     * \n     * @param expectedElements\n     *          The expected number of elements guaranteed not to cause buffer\n     *          expansion (inclusive).\n     ",
      "vertexLabel": "ObjectObjectHashMap<K, V> newNoNullKeysMap()"
    },
    {
      "vertexName": "Method public void removePersistentTask(String id, ActionListener<PersistentTask<?>> listener)  (PersistentTasksClusterService.java)",
      "comment": "\n     * Removes the persistent task\n     *\n     * @param id       the id of a persistent task\n     * @param listener the listener that will be called when task is removed\n     ",
      "vertexLabel": "void removePersistentTask()"
    },
    {
      "vertexName": "Method protected LeafOnly(StreamInput in, ValuesSourceType valuesSourceType, ValueType targetValueType) throws IOException  (ValuesSourceAggregationBuilder.java)",
      "children": [
        {
          "name": "Method protected ValuesSourceAggregationBuilder(StreamInput in, ValuesSourceType valuesSourceType, ValueType targetValueType) throws IOException  (ValuesSourceAggregationBuilder.java)"
        }
      ],
      "comment": "\n         * Read an aggregation from a stream that does not serialize its targetValueType. This should be used by most subclasses.\n         ",
      "vertexLabel": "LeafOnly()"
    },
    {
      "vertexName": "Method protected ClusterBlockLevel globalBlockLevel()  (TransportReplicationAction.java)",
      "children": [
        {
          "name": "Method protected ClusterBlockLevel indexBlockLevel()  (TransportReplicationAction.java)"
        }
      ],
      "comment": "\n     * Cluster level block to check before request execution. Returning null means that no blocks need to be checked.\n     ",
      "vertexLabel": "ClusterBlockLevel globalBlockLevel()"
    },
    {
      "vertexName": "Method public CreateIndexRequest mapping(String type, String source, XContentType xContentType)  (CreateIndexRequest.java)",
      "children": [
        {
          "name": "Method public PutIndexTemplateRequest mapping(String type, BytesReference source, XContentType xContentType)  (PutIndexTemplateRequest.java)"
        }
      ],
      "comment": "\n     * Adds mapping that will be added when the index gets created.\n     *\n     * @param type   The mapping type\n     * @param source The mapping source\n     * @param xContentType The content type of the source\n     ",
      "vertexLabel": "CreateIndexRequest mapping()"
    },
    {
      "vertexName": "Method public ElasticsearchCorruptionException(Throwable ex)  (ElasticsearchCorruptionException.java)",
      "children": [
        {
          "name": "Method public CorruptStateException(Throwable ex)  (CorruptStateException.java)"
        }
      ],
      "comment": "\n     * Creates a new {@link ElasticsearchCorruptionException} with the given exceptions stacktrace.\n     * This constructor copies the stacktrace as well as the message from the given\n     * {@code Throwable} into this exception.\n     *\n     * @param ex the exception cause\n     ",
      "vertexLabel": "ElasticsearchCorruptionException()"
    },
    {
      "vertexName": "Method private void setInline(XContentParser parser)  (Script.java)",
      "comment": "\n         * Since inline scripts can accept code rather than just an id, they must also be able\n         * to handle template parsing, hence the need for custom parsing code.  Templates can\n         * consist of either an {@link String} or a JSON object.  If a JSON object is discovered\n         * then the content type option must also be saved as a compiler option.\n         ",
      "vertexLabel": "void setInline()"
    },
    {
      "vertexName": "Method public CommonTermsQueryBuilder analyzer(String analyzer)  (CommonTermsQueryBuilder.java)",
      "children": [
        {
          "name": "Method public MultiMatchQueryBuilder analyzer(String analyzer)  (MultiMatchQueryBuilder.java)"
        }
      ],
      "comment": "\n     * Explicitly set the analyzer to use. Defaults to use explicit mapping\n     * config for the field, or, if not set, the default search analyzer.\n     ",
      "vertexLabel": "CommonTermsQueryBuilder analyzer()"
    },
    {
      "vertexName": "Method public GeoShapeQueryBuilder ignoreUnmapped(boolean ignoreUnmapped)  (GeoShapeQueryBuilder.java)",
      "children": [
        {
          "name": "Method public GeoBoundingBoxQueryBuilder ignoreUnmapped(boolean ignoreUnmapped)  (GeoBoundingBoxQueryBuilder.java)"
        }
      ],
      "comment": "\n     * Sets whether the query builder should ignore unmapped fields (and run a\n     * {@link MatchNoDocsQuery} in place of this query) or throw an exception if\n     * the field is unmapped.\n     ",
      "vertexLabel": "GeoShapeQueryBuilder ignoreUnmapped()"
    },
    {
      "vertexName": "Method public ScriptSortBuilder setNestedSort(final NestedSortBuilder nestedSort)  (ScriptSortBuilder.java)",
      "children": [
        {
          "name": "Method public FieldSortBuilder setNestedSort(final NestedSortBuilder nestedSort)  (FieldSortBuilder.java)"
        }
      ],
      "comment": "\n     * Sets the {@link NestedSortBuilder} to be used for fields that are inside a nested\n     * object. The {@link NestedSortBuilder} takes a `path` argument and an optional\n     * nested filter that the nested objects should match with in\n     * order to be taken into account for sorting.\n     ",
      "vertexLabel": "ScriptSortBuilder setNestedSort()"
    },
    {
      "vertexName": "Method public SearchRequestBuilder setPreference(String preference)  (SearchRequestBuilder.java)",
      "children": [
        {
          "name": "Method public SearchRequest preference(String preference)  (SearchRequest.java)"
        }
      ],
      "comment": "\n     * Sets the preference to execute the search. Defaults to randomize across shards. Can be set to\n     * {@code _local} to prefer local shards or a custom value, which guarantees that the same order\n     * will be used across different requests.\n     ",
      "vertexLabel": "SearchRequestBuilder setPreference()"
    },
    {
      "vertexName": "Method public IndicesOptions indicesOptions()  (OpenIndexRequest.java)",
      "children": [
        {
          "name": "Method public IndicesOptions indicesOptions()  (RestoreSnapshotRequest.java)"
        }
      ],
      "comment": "\n     * Specifies what type of requested indices to ignore and how to deal with wildcard expressions.\n     * For example indices that don't exist.\n     *\n     * @return the current behaviour when it comes to index names and wildcard indices expressions\n     ",
      "vertexLabel": "IndicesOptions indicesOptions()"
    },
    {
      "vertexName": "Method public Provider<T> getDelegate()  (ProviderLookup.java)",
      "comment": "\n     * Returns the delegate provider, or {@code null} if it has not yet been initialized. The delegate\n     * will be initialized when this element is processed, or otherwise used to create an injector.\n     ",
      "vertexLabel": "Provider<T> getDelegate()"
    },
    {
      "vertexName": "Method private void addTermFrequencies(Map<String, Int> termFreqMap, Terms vector) throws IOException  (XMoreLikeThis.java)",
      "comment": "\n     * Adds terms and frequencies found in vector into the Map termFreqMap\n     *\n     * @param termFreqMap a Map of terms and their frequencies\n     * @param vector List of terms and their frequencies for a doc/field\n     ",
      "vertexLabel": "void addTermFrequencies()"
    },
    {
      "vertexName": "Method public static boolean isKeyOrder(BucketOrder order)  (InternalOrder.java)",
      "children": [
        {
          "name": "Method public static boolean isKeyAsc(BucketOrder order)  (InternalOrder.java)"
        }
      ],
      "comment": "\n     * Determine if the ordering strategy is sorting on bucket key (ascending or descending).\n     *\n     * @param order bucket ordering strategy to check.\n     * @return {@code true} if the ordering strategy is sorting on bucket key, {@code false} otherwise.\n     ",
      "vertexLabel": "boolean isKeyOrder()"
    },
    {
      "vertexName": "Method public ClusterState applyStartedShards(ClusterState clusterState, List<ShardRouting> startedShards)  (AllocationService.java)",
      "comment": "\n     * Applies the started shards. Note, only initializing ShardRouting instances that exist in the routing table should be\n     * provided as parameter and no duplicates should be contained.\n     * <p>\n     * If the same instance of the {@link ClusterState} is returned, then no change has been made.</p>\n     ",
      "vertexLabel": "ClusterState applyStartedShards()"
    },
    {
      "vertexName": "Method public Setting(Key key, Setting<T> fallbackSetting, Function<String, T> parser, Property... properties)  (Setting.java)",
      "children": [
        {
          "name": "Method public Setting(String key, Setting<T> fallBackSetting, Function<String, T> parser, Property... properties)  (Setting.java)"
        }
      ],
      "comment": "\n     * Creates a new Setting instance\n     * @param key the settings key for this setting.\n     * @param fallbackSetting a setting who's value to fallback on if this setting is not defined\n     * @param parser a parser that parses the string rep into a complex datatype.\n     * @param properties properties for this setting like scope, filtering...\n     ",
      "vertexLabel": "Setting()"
    },
    {
      "vertexName": "Method public static TermsQueryBuilder termsQuery(String name, Collection<?> values)  (QueryBuilders.java)",
      "children": [
        {
          "name": "Method public static TermsQueryBuilder termsQuery(String name, String... values)  (QueryBuilders.java)"
        }
      ],
      "comment": "\n     * A filer for a field based on several terms matching on any of them.\n     *\n     * @param name   The field name\n     * @param values The terms\n     ",
      "vertexLabel": "TermsQueryBuilder termsQuery()"
    },
    {
      "vertexName": "Method public static NodesInfoRequest nodesInfoRequest()  (Requests.java)",
      "comment": "\n     * Creates a nodes info request against all the nodes.\n     *\n     * @return The nodes info request\n     * @see org.elasticsearch.client.ClusterAdminClient#nodesInfo(org.elasticsearch.action.admin.cluster.node.info.NodesInfoRequest)\n     ",
      "vertexLabel": "NodesInfoRequest nodesInfoRequest()"
    },
    {
      "vertexName": "Enum Allocation  (EnableAllocationDecider.java)",
      "children": [
        {
          "name": "Enum Rebalance  (EnableAllocationDecider.java)"
        }
      ],
      "comment": "\n     * Allocation values or rather their string representation to be used used with\n     * {@link EnableAllocationDecider#CLUSTER_ROUTING_ALLOCATION_ENABLE_SETTING} /\n     * {@link EnableAllocationDecider#INDEX_ROUTING_ALLOCATION_ENABLE_SETTING}\n     * via cluster / index settings.\n     ",
      "vertexLabel": "Enum Allocation"
    },
    {
      "vertexName": "Method public static MapDiff<K, T, Map<K, T>> readJdkMapDiff(StreamInput in, KeySerializer<K> keySerializer, Reader<T> reader, Reader<Diff<T>> diffReader) throws IOException  (DiffableUtils.java)",
      "comment": "\n     * Loads an object that represents difference between two Maps of Diffable objects using Diffable proto object\n     ",
      "vertexLabel": "MapDiff<K, T, Map<K, T>> readJdkMapDiff()"
    },
    {
      "vertexName": "Method public void addLowPriorityApplier(ClusterStateApplier applier)  (ClusterService.java)",
      "children": [
        {
          "name": "Method public void addLowPriorityApplier(ClusterStateApplier applier)  (ClusterApplierService.java)"
        }
      ],
      "comment": "\n     * Adds an applier which will be called after all high priority and normal appliers have been called.\n     ",
      "vertexLabel": "void addLowPriorityApplier()"
    },
    {
      "vertexName": "Method public double addEstimateBytesAndMaybeBreak(long bytes, String label) throws CircuitBreakingException  (ChildMemoryCircuitBreaker.java)",
      "children": [
        {
          "name": "Method public long addWithoutBreaking(long bytes)  (ChildMemoryCircuitBreaker.java)"
        }
      ],
      "comment": "\n     * Add a number of bytes, tripping the circuit breaker if the aggregated\n     * estimates are above the limit. Automatically trips the breaker if the\n     * memory limit is set to 0. Will never trip the breaker if the limit is\n     * set &lt; 0, but can still be used to aggregate estimations.\n     * @param bytes number of bytes to add to the breaker\n     * @return number of \"used\" bytes so far\n     ",
      "vertexLabel": "double addEstimateBytesAndMaybeBreak()"
    },
    {
      "vertexName": "Method public final void validate(final Settings settings, final boolean validateDependencies, final boolean validateInternalOrPrivateIndex)  (AbstractScopedSettings.java)",
      "children": [
        {
          "name": "Method public final void validate(final Settings settings, final boolean validateDependencies)  (AbstractScopedSettings.java)"
        }
      ],
      "comment": "\n     * Validates that all settings are registered and valid.\n     *\n     * @param settings                       the settings to validate\n     * @param validateDependencies           true if dependent settings should be validated\n     * @param validateInternalOrPrivateIndex true if internal index settings should be validated\n     * @see Setting#getSettingsDependencies(String)\n     ",
      "vertexLabel": "final void validate()"
    },
    {
      "vertexName": "Method public abstract double next(Collection<Double> values)  (MovAvgModel.java)",
      "comment": "\n     * Returns the next value in the series, according to the underlying smoothing model\n     *\n     * @param values    Collection of numerics to movingAvg, usually windowed\n     * @return          Returns a double, since most smoothing methods operate on floating points\n     ",
      "vertexLabel": "abstract double next()"
    },
    {
      "vertexName": "Method public DeleteIndexRequest(String index)  (DeleteIndexRequest.java)",
      "comment": "\n     * Constructs a new delete index request for the specified index.\n     *\n     * @param index The index to delete. Use \"_all\" to delete all indices.\n     ",
      "vertexLabel": "DeleteIndexRequest()"
    },
    {
      "vertexName": "Method public IndexRequest source(byte[] source, int offset, int length, XContentType xContentType)  (IndexRequest.java)",
      "comment": "\n     * Sets the document to index in bytes form (assumed to be safe to be used from different\n     * threads).\n     *\n     * @param source The source to index\n     * @param offset The offset in the byte array\n     * @param length The length of the data\n     ",
      "vertexLabel": "IndexRequest source()"
    },
    {
      "vertexName": "Method public synchronized MapperService createIndexMapperService(IndexMetaData indexMetaData) throws IOException  (IndicesService.java)",
      "children": [
        {
          "name": "Method public MapperService newIndexMapperService(NamedXContentRegistry xContentRegistry, MapperRegistry mapperRegistry, ScriptService scriptService) throws IOException  (IndexModule.java)"
        }
      ],
      "comment": "\n     * creates a new mapper service for the given index, in order to do administrative work like mapping updates.\n     * This *should not* be used for document parsing. Doing so will result in an exception.\n     *\n     * Note: the returned {@link MapperService} should be closed when unneeded.\n     ",
      "vertexLabel": "synchronized MapperService createIndexMapperService()"
    },
    {
      "vertexName": "Method public Setting(String key, Function<Settings, String> defaultValue, Function<String, T> parser, Property... properties)  (Setting.java)",
      "children": [
        {
          "name": "Method public Setting(Key key, Function<Settings, String> defaultValue, Function<String, T> parser, Property... properties)  (Setting.java)"
        }
      ],
      "comment": "\n     * Creates a new Setting instance\n     * @param key the settings key for this setting.\n     * @param defaultValue a default value function that returns the default values string representation.\n     * @param parser a parser that parses the string rep into a complex datatype.\n     * @param properties properties for this setting like scope, filtering...\n     ",
      "vertexLabel": "Setting()"
    },
    {
      "vertexName": "Method public SearchSourceBuilder storedFields(List<String> fields)  (SearchSourceBuilder.java)",
      "children": [
        {
          "name": "Method public InnerHitBuilder setStoredFieldNames(List<String> fieldNames)  (InnerHitBuilder.java)"
        }
      ],
      "comment": "\n     * Sets the stored fields to load and return as part of the search request. If none\n     * are specified, the source of the document will be returned.\n     ",
      "vertexLabel": "SearchSourceBuilder storedFields()"
    },
    {
      "vertexName": "Method public static PutMappingRequest putMappingRequest(String... indices)  (Requests.java)",
      "children": [
        {
          "name": "Method public static CreateIndexRequest createIndexRequest(String index)  (Requests.java)"
        }
      ],
      "comment": "\n     * Create a create mapping request against one or more indices.\n     *\n     * @param indices The indices to create mapping. Use {@code null} or {@code _all} to execute against all indices\n     * @return The create mapping request\n     * @see org.elasticsearch.client.IndicesAdminClient#putMapping(org.elasticsearch.action.admin.indices.mapping.put.PutMappingRequest)\n     ",
      "vertexLabel": "PutMappingRequest putMappingRequest()"
    },
    {
      "vertexName": "Method public UpdateRequest upsert(byte[] source, XContentType xContentType)  (UpdateRequest.java)",
      "children": [
        {
          "name": "Method public UpdateRequest upsert(XContentBuilder source)  (UpdateRequest.java)"
        }
      ],
      "comment": "\n     * Sets the doc source of the update request to be used when the document does not exists.\n     ",
      "vertexLabel": "UpdateRequest upsert()"
    },
    {
      "vertexName": "Method public synchronized ObjectLongMap<String> getInSyncGlobalCheckpoints()  (ReplicationTracker.java)",
      "comment": "\n     * Get the local knowledge of the global checkpoints for all in-sync allocation IDs.\n     *\n     * @return a map from allocation ID to the local knowledge of the global checkpoint for that allocation ID\n     ",
      "vertexLabel": "synchronized ObjectLongMap<String> getInSyncGlobalCheckpoints()"
    },
    {
      "vertexName": "Method public IpRangeAggregationBuilder addRange(String key, String from, String to)  (IpRangeAggregationBuilder.java)",
      "children": [
        {
          "name": "Method public GeoDistanceAggregationBuilder addRange(String key, double from, double to)  (GeoDistanceAggregationBuilder.java)"
        }
      ],
      "comment": "\n     * Add a new range to this aggregation.\n     *\n     * @param key\n     *            the key to use for this range in the response\n     * @param from\n     *            the lower bound on the distances, inclusive\n     * @param to\n     *            the upper bound on the distances, exclusive\n     ",
      "vertexLabel": "IpRangeAggregationBuilder addRange()"
    },
    {
      "vertexName": "Method public boolean isUnicodeAware()  (FuzzyOptions.java)",
      "comment": "\n     * Returns if all measurements (like edit distance, transpositions and lengths) are in unicode code\n     * points (actual letters) instead of bytes.\n     ",
      "vertexLabel": "boolean isUnicodeAware()"
    },
    {
      "vertexName": "Method public AbstractBulkByScrollRequest(SearchRequest searchRequest, boolean setDefaults)  (AbstractBulkByScrollRequest.java)",
      "comment": "\n     * Constructor for actual use.\n     *\n     * @param searchRequest the search request to execute to get the documents to process\n     * @param setDefaults should this request set the defaults on the search request? Usually set to true but leave it false to support\n     *        request slicing\n     ",
      "vertexLabel": "AbstractBulkByScrollRequest()"
    },
    {
      "vertexName": "Method public boolean canRemain()  (MoveDecision.java)",
      "comment": "\n     * Returns {@code true} if the shard can remain on its current node, returns {@code false} otherwise.\n     * If {@link #isDecisionTaken()} returns {@code false}, then invoking this method will throw an {@code IllegalStateException}.\n     ",
      "vertexLabel": "boolean canRemain()"
    },
    {
      "vertexName": "Method public static long toLong(String stringValue, boolean coerce)  (Numbers.java)",
      "children": [
        {
          "name": "Method public static long toLongExact(Number n)  (Numbers.java)"
        }
      ],
      "comment": " Return the long that {@code stringValue} stores or throws an exception if the\n     *  stored value cannot be converted to a long that stores the exact same\n     *  value and {@code coerce} is false. ",
      "vertexLabel": "long toLong()"
    },
    {
      "vertexName": "Method public InnerHitBuilder setFieldNames(List<String> fieldNames)  (InnerHitBuilder.java)",
      "children": [
        {
          "name": "Method public InnerHitBuilder setStoredFieldNames(List<String> fieldNames)  (InnerHitBuilder.java)"
        }
      ],
      "comment": "\n     * Sets the stored fields to load and return.\n     * If none are specified, the source of the document will be returned.\n     *\n     * @deprecated Use {@link InnerHitBuilder#setStoredFieldNames(List)} instead.\n     ",
      "vertexLabel": "InnerHitBuilder setFieldNames()"
    },
    {
      "vertexName": "Method private void deleteSnapshot(final Snapshot snapshot, final DeleteSnapshotListener listener, final long repositoryStateId, final boolean immediatePriority)  (SnapshotsService.java)",
      "children": [
        {
          "name": "Method private void deleteSnapshotFromRepository(final Snapshot snapshot, @Nullable final DeleteSnapshotListener listener, long repositoryStateId)  (SnapshotsService.java)"
        }
      ],
      "comment": "\n     * Deletes snapshot from repository.\n     * <p>\n     * If the snapshot is still running cancels the snapshot first and then deletes it from the repository.\n     *\n     * @param snapshot snapshot\n     * @param listener listener\n     * @param repositoryStateId the unique id for the state of the repository\n     ",
      "vertexLabel": "void deleteSnapshot()"
    },
    {
      "vertexName": "Method public void validateAliasMetaData(AliasMetaData aliasMetaData, String index, MetaData metaData)  (AliasValidator.java)",
      "comment": "\n     * Allows to validate an {@link org.elasticsearch.cluster.metadata.AliasMetaData} and make sure\n     * it's valid before it gets added to the index metadata. Doesn't validate the alias filter.\n     * @throws IllegalArgumentException if the alias is not valid\n     ",
      "vertexLabel": "void validateAliasMetaData()"
    },
    {
      "vertexName": "Class SortableLongBitsToSortedNumericDoubleValues  (SortableLongBitsToSortedNumericDoubleValues.java)",
      "children": [
        {
          "name": "Class SortableLongBitsToNumericDoubleValues  (SortableLongBitsToNumericDoubleValues.java)"
        }
      ],
      "comment": "\n * {@link SortedNumericDoubleValues} instance that wraps a {@link SortedNumericDocValues}\n * and converts the doubles to sortable long bits using\n * {@link NumericUtils#sortableLongToDouble(long)}.\n ",
      "vertexLabel": "Class SortableLongBitsToSortedNumericDoubleValues"
    },
    {
      "vertexName": "Method public CommonTermsQueryBuilder cutoffFrequency(float cutoffFrequency)  (CommonTermsQueryBuilder.java)",
      "children": [
        {
          "name": "Method public MatchQueryBuilder cutoffFrequency(float cutoff)  (MatchQueryBuilder.java)"
        }
      ],
      "comment": "\n     * Sets the cutoff document frequency for high / low frequent terms. A value\n     * in [0..1] (or absolute number &gt;=1) representing the maximum threshold of\n     * a terms document frequency to be considered a low frequency term.\n     * Defaults to\n     * {@code {@value #DEFAULT_CUTOFF_FREQ}}\n     ",
      "vertexLabel": "CommonTermsQueryBuilder cutoffFrequency()"
    },
    {
      "vertexName": "Class GetRequest  (GetRequest.java)",
      "children": [
        {
          "name": "Class DeleteRequest  (DeleteRequest.java)"
        }
      ],
      "comment": "\n * A request to get a document (its source) from an index based on its type (optional) and id. Best created using\n * {@link org.elasticsearch.client.Requests#getRequest(String)}.\n * <p>\n * The operation requires the {@link #index()}, {@link #type(String)} and {@link #id(String)}\n * to be set.\n *\n * @see org.elasticsearch.action.get.GetResponse\n * @see org.elasticsearch.client.Requests#getRequest(String)\n * @see org.elasticsearch.client.Client#get(GetRequest)\n ",
      "vertexLabel": "Class GetRequest"
    },
    {
      "vertexName": "Method public static TermQueryBuilder termQuery(String name, float value)  (QueryBuilders.java)",
      "children": [
        {
          "name": "Method public static TermQueryBuilder termQuery(String name, String value)  (QueryBuilders.java)"
        }
      ],
      "comment": "\n     * A Query that matches documents containing a term.\n     *\n     * @param name  The name of the field\n     * @param value The value of the term\n     ",
      "vertexLabel": "TermQueryBuilder termQuery()"
    },
    {
      "vertexName": "Method public TopHitsAggregationBuilder sort(String name, SortOrder order)  (TopHitsAggregationBuilder.java)",
      "children": [
        {
          "name": "Method public SearchRequestBuilder addSort(String field, SortOrder order)  (SearchRequestBuilder.java)"
        }
      ],
      "comment": "\n     * Adds a sort against the given field name and the sort ordering.\n     *\n     * @param name\n     *            The name of the field\n     * @param order\n     *            The sort ordering\n     ",
      "vertexLabel": "TopHitsAggregationBuilder sort()"
    },
    {
      "vertexName": "Method public static void checkIndexDeletion(ClusterState currentState, Set<IndexMetaData> indices)  (SnapshotsService.java)",
      "children": [
        {
          "name": "Method public static void checkIndexClosing(ClusterState currentState, Set<IndexMetaData> indices)  (SnapshotsService.java)"
        }
      ],
      "comment": "\n     * Check if any of the indices to be deleted are currently being snapshotted. Fail as deleting an index that is being\n     * snapshotted (with partial == false) makes the snapshot fail.\n     ",
      "vertexLabel": "void checkIndexDeletion()"
    },
    {
      "vertexName": "Method public CreateSnapshotRequestBuilder setIndicesOptions(IndicesOptions indicesOptions)  (CreateSnapshotRequestBuilder.java)",
      "children": [
        {
          "name": "Method public CreateSnapshotRequest indicesOptions(IndicesOptions indicesOptions)  (CreateSnapshotRequest.java)"
        }
      ],
      "comment": "\n     * Specifies the indices options. Like what type of requested indices to ignore. For example indices that don't exist.\n     *\n     * @param indicesOptions the desired behaviour regarding indices options\n     * @return this request\n     ",
      "vertexLabel": "CreateSnapshotRequestBuilder setIndicesOptions()"
    },
    {
      "vertexName": "Method public UpdateRequest upsert(Object... source)  (UpdateRequest.java)",
      "children": [
        {
          "name": "Method public UpdateRequest upsert(byte[] source, XContentType xContentType)  (UpdateRequest.java)"
        }
      ],
      "comment": "\n     * Sets the doc source of the update request to be used when the document does not exists. The doc\n     * includes field and value pairs.\n     ",
      "vertexLabel": "UpdateRequest upsert()"
    },
    {
      "vertexName": "Method public TermsQueryBuilder(String fieldName, float... values)  (TermsQueryBuilder.java)",
      "children": [
        {
          "name": "Method public TermsQueryBuilder(String fieldName, String... values)  (TermsQueryBuilder.java)"
        }
      ],
      "comment": "\n     * A filter for a field based on several terms matching on any of them.\n     *\n     * @param fieldName The field name\n     * @param values The terms\n     ",
      "vertexLabel": "TermsQueryBuilder()"
    },
    {
      "vertexName": "Method public DiscoveryNode get(String nodeId)  (DiscoveryNodes.java)",
      "comment": "\n     * Get a node by its id\n     *\n     * @param nodeId id of the wanted node\n     * @return wanted node if it exists. Otherwise <code>null</code>\n     ",
      "vertexLabel": "DiscoveryNode get()"
    },
    {
      "vertexName": "Method void afterIndexShardDeleted(ShardId shardId, Settings indexSettings)  (IndexEventListener.java)",
      "comment": "\n     * Called after the index shard has been deleted from disk.\n     *\n     * Note: this method is only called if the deletion of the shard did finish without an exception\n     *\n     * @param shardId The shard id\n     * @param indexSettings the shards index settings\n     ",
      "vertexLabel": "void afterIndexShardDeleted()"
    },
    {
      "vertexName": "Method public long getTimeInNanos()  (ThreadBarrier.java)",
      "children": [
        {
          "name": "Method public double getTimeInSeconds()  (ThreadBarrier.java)"
        }
      ],
      "comment": "\n         * Returns the elapsed time between two successive barrier executions.\n         *\n         * @return elapsed time in nanoseconds.\n         ",
      "vertexLabel": "long getTimeInNanos()"
    },
    {
      "vertexName": "Method InputStream readBlob(String blobName) throws IOException  (BlobContainer.java)",
      "comment": "\n     * Creates a new {@link InputStream} for the given blob name.\n     *\n     * @param   blobName\n     *          The name of the blob to get an {@link InputStream} for.\n     * @return  The {@code InputStream} to read the blob.\n     * @throws  NoSuchFileException if the blob does not exist\n     * @throws  IOException if the blob can not be read.\n     ",
      "vertexLabel": "InputStream readBlob()"
    },
    {
      "vertexName": "Method public SnapshotsStatusRequestBuilder addSnapshots(String... snapshots)  (SnapshotsStatusRequestBuilder.java)",
      "children": [
        {
          "name": "Method public GetSnapshotsRequestBuilder addSnapshots(String... snapshots)  (GetSnapshotsRequestBuilder.java)"
        }
      ],
      "comment": "\n     * Adds additional snapshots to the list of snapshots to return\n     *\n     * @param snapshots additional snapshots\n     * @return this builder\n     ",
      "vertexLabel": "SnapshotsStatusRequestBuilder addSnapshots()"
    },
    {
      "vertexName": "Method DateFormatter withZone(ZoneId zoneId)  (DateFormatter.java)",
      "comment": "\n     * Create a copy of this formatter that is configured to parse dates in the specified time zone\n     *\n     * @param zoneId The time zone to act on\n     * @return       A copy of the date formatter this has been called on\n     ",
      "vertexLabel": "DateFormatter withZone()"
    },
    {
      "vertexName": "Method void create(CreateIndexRequest request, ActionListener<CreateIndexResponse> listener)  (IndicesAdminClient.java)",
      "children": [
        {
          "name": "Method void delete(DeleteIndexRequest request, ActionListener<AcknowledgedResponse> listener)  (IndicesAdminClient.java)"
        },
        {
          "name": "Method ActionFuture<CreateIndexResponse> create(CreateIndexRequest request)  (IndicesAdminClient.java)"
        }
      ],
      "comment": "\n     * Creates an index using an explicit request allowing to specify the settings of the index.\n     *\n     * @param request  The create index request\n     * @param listener A listener to be notified with a result\n     * @see org.elasticsearch.client.Requests#createIndexRequest(String)\n     ",
      "vertexLabel": "void create()"
    },
    {
      "vertexName": "Method public Result prepare(UpdateRequest request, IndexShard indexShard, LongSupplier nowInMillis)  (UpdateHelper.java)",
      "comment": "\n     * Prepares an update request by converting it into an index or delete request or an update response (no action).\n     ",
      "vertexLabel": "Result prepare()"
    },
    {
      "vertexName": "Method public MultiSearchRequest add(SearchRequest request)  (MultiSearchRequest.java)",
      "children": [
        {
          "name": "Method public MultiSearchRequest add(SearchRequestBuilder request)  (MultiSearchRequest.java)"
        }
      ],
      "comment": "\n     * Add a search request to execute. Note, the order is important, the search response will be returned in the\n     * same order as the search requests.\n     ",
      "vertexLabel": "MultiSearchRequest add()"
    },
    {
      "vertexName": "Method public static ScoreSortBuilder fromXContent(XContentParser parser, String fieldName)  (ScoreSortBuilder.java)",
      "children": [
        {
          "name": "Method public static FieldSortBuilder fromXContent(XContentParser parser, String fieldName) throws IOException  (FieldSortBuilder.java)"
        }
      ],
      "comment": "\n     * Creates a new {@link ScoreSortBuilder} from the query held by the {@link XContentParser} in\n     * {@link org.elasticsearch.common.xcontent.XContent} format.\n     *\n     * @param parser the input parser. The state on the parser contained in this context will be changed as a side effect of this\n     *        method call\n     * @param fieldName in some sort syntax variations the field name precedes the xContent object that specifies further parameters, e.g.\n     *        in '{ \"foo\": { \"order\" : \"asc\"} }'. When parsing the inner object, the field name can be passed in via this argument\n     ",
      "vertexLabel": "ScoreSortBuilder fromXContent()"
    },
    {
      "vertexName": "Method protected double[] doPredict(Collection<Double> values, int numPredictions)  (HoltLinearModel.java)",
      "children": [
        {
          "name": "Method public double[] predict(Collection<Double> values, int numPredictions)  (MovAvgModel.java)"
        }
      ],
      "comment": "\n     * Predicts the next `n` values in the series, using the smoothing model to generate new values.\n     * Unlike the other moving averages, Holt-Linear has forecasting/prediction built into the algorithm.\n     * Prediction is more than simply adding the next prediction to the window and repeating.  Holt-Linear\n     * will extrapolate into the future by applying the trend information to the smoothed data.\n     *\n     * @param values            Collection of numerics to movingAvg, usually windowed\n     * @param numPredictions    Number of newly generated predictions to return\n     * @return                  Returns an array of doubles, since most smoothing methods operate on floating points\n     ",
      "vertexLabel": "double[] doPredict()"
    },
    {
      "vertexName": "Method public IndicesShardStoresRequest indicesOptions(IndicesOptions indicesOptions)  (IndicesShardStoresRequest.java)",
      "children": [
        {
          "name": "Method public IndicesShardStoreRequestBuilder setIndicesOptions(IndicesOptions indicesOptions)  (IndicesShardStoreRequestBuilder.java)"
        }
      ],
      "comment": "\n     * Specifies what type of requested indices to ignore and wildcard indices expressions\n     * By default, expands wildcards to both open and closed indices\n     ",
      "vertexLabel": "IndicesShardStoresRequest indicesOptions()"
    },
    {
      "vertexName": "Method public GetSnapshotsRequestBuilder addSnapshots(String... snapshots)  (GetSnapshotsRequestBuilder.java)",
      "comment": "\n     * Adds additional snapshots to the list of snapshots to return\n     *\n     * @param snapshots additional snapshots\n     * @return this builder\n     ",
      "vertexLabel": "GetSnapshotsRequestBuilder addSnapshots()"
    },
    {
      "vertexName": "Method void validate(final String key, final Settings settings, final boolean validateDependencies)  (AbstractScopedSettings.java)",
      "comment": "\n     * Validates that the settings is valid.\n     *\n     * @param key the key of the setting to validate\n     * @param settings the settings\n     * @param validateDependencies true if dependent settings should be validated\n     * @throws IllegalArgumentException if the setting is invalid\n     ",
      "vertexLabel": "void validate()"
    },
    {
      "vertexName": "Method public Self waitForActiveShards(ActiveShardCount activeShardCount)  (AbstractBulkByScrollRequestBuilder.java)",
      "comment": "\n     * The number of shard copies that must be active before proceeding with the write.\n     * See {@link ReplicationRequest#waitForActiveShards(ActiveShardCount)} for details.\n     ",
      "vertexLabel": "Self waitForActiveShards()"
    },
    {
      "vertexName": "Method public Self setRequestsPerSecond(float requestsPerSecond)  (AbstractBulkByScrollRequestBuilder.java)",
      "children": [
        {
          "name": "Method public Self setRequestsPerSecond(float requestsPerSecond)  (AbstractBulkByScrollRequest.java)"
        }
      ],
      "comment": "\n     * Set the throttle for this request in sub-requests per second. {@link Float#POSITIVE_INFINITY} means set no throttle and that is the\n     * default. Throttling is done between batches, as we start the next scroll requests. That way we can increase the scroll's timeout to\n     * make sure that it contains any time that we might wait.\n     ",
      "vertexLabel": "Self setRequestsPerSecond()"
    },
    {
      "vertexName": "Method public RestoreSnapshotRequest settings(Map<String, Object> source)  (RestoreSnapshotRequest.java)",
      "comment": "\n     * Sets repository-specific restore settings\n     * <p>\n     * See repository documentation for more information.\n     *\n     * @param source repository-specific snapshot settings\n     * @return this request\n     ",
      "vertexLabel": "RestoreSnapshotRequest settings()"
    },
    {
      "vertexName": "Method void aliases(IndicesAliasesRequest request, ActionListener<AcknowledgedResponse> listener)  (IndicesAdminClient.java)",
      "children": [
        {
          "name": "Method void getAliases(GetAliasesRequest request, ActionListener<GetAliasesResponse> listener)  (IndicesAdminClient.java)"
        },
        {
          "name": "Method ActionFuture<AcknowledgedResponse> aliases(IndicesAliasesRequest request)  (IndicesAdminClient.java)"
        }
      ],
      "comment": "\n     * Allows to add/remove aliases from indices.\n     *\n     * @param request  The index aliases request\n     * @param listener A listener to be notified with a result\n     * @see Requests#indexAliasesRequest()\n     ",
      "vertexLabel": "void aliases()"
    },
    {
      "vertexName": "Method public ChecksumBlobStoreFormat(String codec, String blobNameFormat, CheckedFunction<XContentParser, T, IOException> reader, NamedXContentRegistry namedXContentRegistry, boolean compress)  (ChecksumBlobStoreFormat.java)",
      "comment": "\n     * @param codec          codec name\n     * @param blobNameFormat format of the blobname in {@link String#format} format\n     * @param reader         prototype object that can deserialize T from XContent\n     * @param compress       true if the content should be compressed\n     ",
      "vertexLabel": "ChecksumBlobStoreFormat()"
    },
    {
      "vertexName": "Method public DiscoveryNode getTargetNode()  (AbstractAllocationDecision.java)",
      "comment": "\n     * Get the node that the allocator will assign the shard to, returning {@code null} if there is no node to\n     * which the shard will be assigned or moved.  If {@link #isDecisionTaken()} returns {@code false}, then\n     * invoking this method will throw an {@code IllegalStateException}.\n     ",
      "vertexLabel": "DiscoveryNode getTargetNode()"
    },
    {
      "vertexName": "Method public GeoPolygonQueryBuilder ignoreUnmapped(boolean ignoreUnmapped)  (GeoPolygonQueryBuilder.java)",
      "children": [
        {
          "name": "Method public GeoBoundingBoxQueryBuilder ignoreUnmapped(boolean ignoreUnmapped)  (GeoBoundingBoxQueryBuilder.java)"
        }
      ],
      "comment": "\n     * Sets whether the query builder should ignore unmapped fields (and run a\n     * {@link MatchNoDocsQuery} in place of this query) or throw an exception if\n     * the field is unmapped.\n     ",
      "vertexLabel": "GeoPolygonQueryBuilder ignoreUnmapped()"
    },
    {
      "vertexName": "Method public static QueryValidationException addValidationError(String queryId, String validationError, QueryValidationException validationException)  (QueryValidationException.java)",
      "children": [
        {
          "name": "Method public static QueryValidationException addValidationErrors(List<String> validationErrors, QueryValidationException validationException)  (QueryValidationException.java)"
        }
      ],
      "comment": "\n     * Helper method than can be used to add error messages to an existing {@link QueryValidationException}.\n     * When passing {@code null} as the initial exception, a new exception is created.\n     *\n     * @param queryId the query that caused the error\n     * @param validationError the error message to add to an initial exception\n     * @param validationException an initial exception. Can be {@code null}, in which case a new exception is created.\n     * @return a {@link QueryValidationException} with added validation error message\n     ",
      "vertexLabel": "QueryValidationException addValidationError()"
    },
    {
      "vertexName": "Method public void localShardFailed(final ShardRouting shardRouting, final String message, @Nullable final Exception failure, Listener listener)  (ShardStateAction.java)",
      "comment": "\n     * Send a shard failed request to the master node to update the cluster state when a shard on the local node failed.\n     ",
      "vertexLabel": "void localShardFailed()"
    },
    {
      "vertexName": "Method public CreateSnapshotRequestBuilder setSettings(Settings.Builder settings)  (CreateSnapshotRequestBuilder.java)",
      "children": [
        {
          "name": "Method public CreateSnapshotRequestBuilder setSettings(Settings settings)  (CreateSnapshotRequestBuilder.java)"
        }
      ],
      "comment": "\n     * Sets repository-specific snapshot settings.\n     * <p>\n     * See repository documentation for more information.\n     *\n     * @param settings repository-specific snapshot settings\n     * @return this builder\n     ",
      "vertexLabel": "CreateSnapshotRequestBuilder setSettings()"
    },
    {
      "vertexName": "Method public ClusterAllocationExplainRequestBuilder setCurrentNode(String currentNode)  (ClusterAllocationExplainRequestBuilder.java)",
      "children": [
        {
          "name": "Method public ClusterAllocationExplainRequest setCurrentNode(String currentNodeId)  (ClusterAllocationExplainRequest.java)"
        }
      ],
      "comment": "\n     * Requests the explain API to explain an already assigned replica shard currently allocated to\n     * the given node.\n     ",
      "vertexLabel": "ClusterAllocationExplainRequestBuilder setCurrentNode()"
    },
    {
      "vertexName": "Enum Reason  (UnassignedInfo.java)",
      "comment": "\n     * Reason why the shard is in unassigned state.\n     * <p>\n     * Note, ordering of the enum is important, make sure to add new values\n     * at the end and handle version serialization properly.\n     ",
      "vertexLabel": "Enum Reason"
    },
    {
      "vertexName": "Method public FixedExecutorBuilder(final Settings settings, final String name, final int size, final int queueSize, final String prefix)  (FixedExecutorBuilder.java)",
      "comment": "\n     * Construct a fixed executor builder.\n     *\n     * @param settings  the node-level settings\n     * @param name      the name of the executor\n     * @param size      the fixed number of threads\n     * @param queueSize the size of the backing queue, -1 for unbounded\n     * @param prefix    the prefix for the settings keys\n     ",
      "vertexLabel": "FixedExecutorBuilder()"
    },
    {
      "vertexName": "Class LivenessRequest  (LivenessRequest.java)",
      "comment": "\n * Transport level private response for the transport handler registered under\n * {@value org.elasticsearch.action.admin.cluster.node.liveness.TransportLivenessAction#NAME}\n ",
      "vertexLabel": "Class LivenessRequest"
    },
    {
      "vertexName": "Method public SearchRequestBuilder setPreFilterShardSize(int preFilterShardSize)  (SearchRequestBuilder.java)",
      "children": [
        {
          "name": "Method public void setPreFilterShardSize(int preFilterShardSize)  (SearchRequest.java)"
        }
      ],
      "comment": "\n     * Sets a threshold that enforces a pre-filter roundtrip to pre-filter search shards based on query rewriting if the number of shards\n     * the search request expands to exceeds the threshold. This filter roundtrip can limit the number of shards significantly if for\n     * instance a shard can not match any documents based on it's rewrite method ie. if date filters are mandatory to match but the shard\n     * bounds and the query are disjoint. The default is {@code 128}\n     ",
      "vertexLabel": "SearchRequestBuilder setPreFilterShardSize()"
    },
    {
      "vertexName": "Method public RestoreSnapshotRequest settings(Settings.Builder settings)  (RestoreSnapshotRequest.java)",
      "children": [
        {
          "name": "Method public RestoreSnapshotRequest settings(Settings settings)  (RestoreSnapshotRequest.java)"
        }
      ],
      "comment": "\n     * Sets repository-specific restore settings.\n     * <p>\n     * See repository documentation for more information.\n     *\n     * @param settings repository-specific snapshot settings\n     * @return this request\n     ",
      "vertexLabel": "RestoreSnapshotRequest settings()"
    },
    {
      "vertexName": "Class Builder  (DeleteResponse.java)",
      "children": [
        {
          "name": "Class Builder  (IndexResponse.java)"
        }
      ],
      "comment": "\n     * Builder class for {@link DeleteResponse}. This builder is usually used during xcontent parsing to\n     * temporarily store the parsed values, then the {@link DocWriteResponse.Builder#build()} method is called to\n     * instantiate the {@link DeleteResponse}.\n     ",
      "vertexLabel": "Class Builder"
    },
    {
      "vertexName": "Method SyncedFlushRequestBuilder prepareSyncedFlush(String... indices)  (IndicesAdminClient.java)",
      "comment": "\n     * Explicitly sync flush one or more indices (write sync id to shards for faster recovery).\n     ",
      "vertexLabel": "SyncedFlushRequestBuilder prepareSyncedFlush()"
    },
    {
      "vertexName": "Method public FunctionScoreQuery(Query subQuery, ScoreFunction function, CombineFunction combineFunction, Float minScore, float maxBoost)  (FunctionScoreQuery.java)",
      "children": [
        {
          "name": "Method public FunctionScoreQuery(Query subQuery, Float minScore, float maxBoost)  (FunctionScoreQuery.java)"
        }
      ],
      "comment": "\n     * Creates a FunctionScoreQuery with a single function\n     * @param subQuery The query to match.\n     * @param function The {@link ScoreFunction} to apply.\n     * @param combineFunction Defines how the query and function score should be applied.\n     * @param minScore The minimum score to consider a document.\n     * @param maxBoost The maximum applicable boost.\n     ",
      "vertexLabel": "FunctionScoreQuery()"
    },
    {
      "vertexName": "Method private long getCgroupCpuAcctCpuCfsQuotaMicros(final String controlGroup) throws IOException  (OsProbe.java)",
      "children": [
        {
          "name": "Method private long getCgroupCpuAcctCpuCfsPeriodMicros(final String controlGroup) throws IOException  (OsProbe.java)"
        }
      ],
      "comment": "\n     * The total time in microseconds that all tasks in the Elasticsearch control group can run during one period as specified by {@code\n     * cpu.cfs_period_us}.\n     *\n     * @param controlGroup the control group for the Elasticsearch process for the {@code cpuacct} subsystem\n     * @return the CFS quota in microseconds\n     * @throws IOException if an I/O exception occurs reading {@code cpu.cfs_quota_us} for the control group\n     ",
      "vertexLabel": "long getCgroupCpuAcctCpuCfsQuotaMicros()"
    },
    {
      "vertexName": "Method public SearchRequestBuilder setFetchSource(@Nullable String[] includes, @Nullable String[] excludes)  (SearchRequestBuilder.java)",
      "children": [
        {
          "name": "Method public ExplainRequestBuilder setFetchSource(@Nullable String[] includes, @Nullable String[] excludes)  (ExplainRequestBuilder.java)"
        }
      ],
      "comment": "\n     * Indicate that _source should be returned with every hit, with an \"include\" and/or \"exclude\" set which can include simple wildcard\n     * elements.\n     *\n     * @param includes An optional list of include (optionally wildcarded) pattern to filter the returned _source\n     * @param excludes An optional list of exclude (optionally wildcarded) pattern to filter the returned _source\n     ",
      "vertexLabel": "SearchRequestBuilder setFetchSource()"
    },
    {
      "vertexName": "Method public Script(ScriptType type, String lang, String idOrCode, Map<String, String> options, Map<String, Object> params)  (Script.java)",
      "children": [
        {
          "name": "Method public Script(ScriptType type, String lang, String idOrCode, Map<String, Object> params)  (Script.java)"
        }
      ],
      "comment": "\n     * Constructor for a script that requires the use of compiler options.\n     * @param type     The {@link ScriptType}.\n     * @param lang     The language for this {@link Script} if the {@link ScriptType} is {@link ScriptType#INLINE}.\n     *                 For {@link ScriptType#STORED} scripts this should be null, but can\n     *                 be specified to access scripts stored as part of the stored scripts deprecated API.\n     * @param idOrCode The id for this {@link Script} if the {@link ScriptType} is {@link ScriptType#STORED}.\n     *                 The code for this {@link Script} if the {@link ScriptType} is {@link ScriptType#INLINE}.\n     * @param options  The map of compiler options for this {@link Script} if the {@link ScriptType}\n     *                 is {@link ScriptType#INLINE}, {@code null} otherwise.\n     * @param params   The user-defined params to be bound for script execution.\n     ",
      "vertexLabel": "Script()"
    },
    {
      "vertexName": "Class DateHistogramAggregator  (DateHistogramAggregator.java)",
      "children": [
        {
          "name": "Class AutoDateHistogramAggregator  (AutoDateHistogramAggregator.java)"
        }
      ],
      "comment": "\n * An aggregator for date values. Every date is rounded down using a configured\n * {@link Rounding}.\n *\n * @see Rounding\n ",
      "vertexLabel": "Class DateHistogramAggregator"
    },
    {
      "vertexName": "Method public ChildMemoryCircuitBreaker(BreakerSettings settings, Logger logger, HierarchyCircuitBreakerService parent, String name)  (ChildMemoryCircuitBreaker.java)",
      "comment": "\n     * Create a circuit breaker that will break if the number of estimated\n     * bytes grows above the limit. All estimations will be multiplied by\n     * the given overheadConstant. This breaker starts with 0 bytes used.\n     * @param settings settings to configure this breaker\n     * @param parent parent circuit breaker service to delegate tripped breakers to\n     * @param name the name of the breaker\n     ",
      "vertexLabel": "ChildMemoryCircuitBreaker()"
    },
    {
      "vertexName": "Method public TermsAggregationBuilder minDocCount(long minDocCount)  (TermsAggregationBuilder.java)",
      "comment": "\n     * Set the minimum document count terms should have in order to appear in\n     * the response.\n     ",
      "vertexLabel": "TermsAggregationBuilder minDocCount()"
    },
    {
      "vertexName": "Method public LineStringBuilder close()  (LineStringBuilder.java)",
      "comment": "\n     * Closes the current lineString by adding the starting point as the end point.\n     * This will have no effect if starting and end point are already the same.\n     ",
      "vertexLabel": "LineStringBuilder close()"
    },
    {
      "vertexName": "Method public boolean includeGlobalState()  (SnapshotsService.java)",
      "children": [
        {
          "name": "Method public boolean includeGlobalState()  (CreateSnapshotRequest.java)"
        }
      ],
      "comment": "\n         * Returns true if global state should be stored as part of the snapshot\n         *\n         * @return true if global state should be stored as part of the snapshot\n         ",
      "vertexLabel": "boolean includeGlobalState()"
    },
    {
      "vertexName": "Method void addConnectListener(ActionListener<Void> listener)  (TcpChannel.java)",
      "children": [
        {
          "name": "Method void addCloseListener(ActionListener<Void> listener)  (CloseableChannel.java)"
        }
      ],
      "comment": "\n     * Adds a listener that will be executed when the channel is connected. If the channel is still\n     * unconnected when this listener is added, the listener will be executed by the thread that eventually\n     * finishes the channel connection. If the channel is already connected when the listener is added the\n     * listener will immediately be executed by the thread that is attempting to add the listener.\n     *\n     * @param listener to be executed\n     ",
      "vertexLabel": "void addConnectListener()"
    },
    {
      "vertexName": "Method public boolean ignoreUnmapped()  (GeoDistanceQueryBuilder.java)",
      "children": [
        {
          "name": "Method public boolean ignoreUnmapped()  (GeoBoundingBoxQueryBuilder.java)"
        }
      ],
      "comment": "\n     * Gets whether the query builder will ignore unmapped fields (and run a\n     * {@link MatchNoDocsQuery} in place of this query) or throw an exception if\n     * the field is unmapped.\n     ",
      "vertexLabel": "boolean ignoreUnmapped()"
    },
    {
      "vertexName": "Method public SignificantTermsAggregationBuilder shardMinDocCount(long shardMinDocCount)  (SignificantTermsAggregationBuilder.java)",
      "children": [
        {
          "name": "Method public TermsAggregationBuilder shardMinDocCount(long shardMinDocCount)  (TermsAggregationBuilder.java)"
        }
      ],
      "comment": "\n     * Set the minimum document count terms should have on the shard in order to\n     * appear in the response.\n     ",
      "vertexLabel": "SignificantTermsAggregationBuilder shardMinDocCount()"
    },
    {
      "vertexName": "Method public boolean blocksChanged()  (ClusterChangedEvent.java)",
      "children": [
        {
          "name": "Method public boolean indexRoutingTableChanged(String index)  (ClusterChangedEvent.java)"
        }
      ],
      "comment": "\n     * Returns <code>true</code> iff the cluster level blocks have changed between cluster states.\n     * Note that this is an object reference equality test, not an equals test.\n     ",
      "vertexLabel": "boolean blocksChanged()"
    },
    {
      "vertexName": "Method public boolean completed()  (SnapshotState.java)",
      "comment": "\n     * Returns true if snapshot completed (successfully or not)\n     *\n     * @return true if snapshot completed, false otherwise\n     ",
      "vertexLabel": "boolean completed()"
    },
    {
      "vertexName": "Method public Query like(int docNum) throws IOException  (XMoreLikeThis.java)",
      "children": [
        {
          "name": "Method public Query like(Fields... likeFields) throws IOException  (XMoreLikeThis.java)"
        }
      ],
      "comment": "\n     * Return a query that will return docs like the passed lucene document ID.\n     *\n     * @param docNum the documentID of the lucene doc to generate the 'More Like This\" query for.\n     * @return a query that will return docs like the passed lucene document ID.\n     ",
      "vertexLabel": "Query like()"
    },
    {
      "vertexName": "Method public static void addDirectoryPath(Permissions policy, String configurationName, Path path, String permissions) throws IOException  (FilePermissionUtils.java)",
      "children": [
        {
          "name": "Method public static void addSingleFilePath(Permissions policy, Path path, String permissions) throws IOException  (FilePermissionUtils.java)"
        }
      ],
      "comment": "\n     * Add access to path (and all files underneath it); this also creates the directory if it does not exist.\n     *\n     * @param policy            current policy to add permissions to\n     * @param configurationName the configuration name associated with the path (for error messages only)\n     * @param path              the path itself\n     * @param permissions       set of file permissions to grant to the path\n     ",
      "vertexLabel": "void addDirectoryPath()"
    },
    {
      "vertexName": "Method public RestoreSnapshotRequest indices(String... indices)  (RestoreSnapshotRequest.java)",
      "children": [
        {
          "name": "Method public CreateSnapshotRequest indices(String... indices)  (CreateSnapshotRequest.java)"
        }
      ],
      "comment": "\n     * Sets the list of indices that should be restored from snapshot\n     * <p>\n     * The list of indices supports multi-index syntax. For example: \"+test*\" ,\"-test42\" will index all indices with\n     * prefix \"test\" except index \"test42\". Aliases are not supported. An empty list or {\"_all\"} will restore all open\n     * indices in the snapshot.\n     *\n     * @param indices list of indices\n     * @return this request\n     ",
      "vertexLabel": "RestoreSnapshotRequest indices()"
    },
    {
      "vertexName": "Method public Self setWaitForActiveShards(ActiveShardCount activeShardCount)  (AbstractBulkByScrollRequest.java)",
      "children": [
        {
          "name": "Method public UpdateRequest waitForActiveShards(ActiveShardCount waitForActiveShards)  (UpdateRequest.java)"
        }
      ],
      "comment": "\n     * Sets the number of shard copies that must be active before proceeding with the write.\n     * See {@link ReplicationRequest#waitForActiveShards(ActiveShardCount)} for details.\n     ",
      "vertexLabel": "Self setWaitForActiveShards()"
    },
    {
      "vertexName": "Method protected void requireBinding(Key<?> key)  (AbstractModule.java)",
      "comment": "\n     * Adds a dependency from this module to {@code key}. When the injector is\n     * created, Guice will report an error if {@code key} cannot be injected.\n     * Note that this requirement may be satisfied by implicit binding, such as\n     * a public no-arguments constructor.\n     *\n     * @since 2.0\n     ",
      "vertexLabel": "void requireBinding()"
    },
    {
      "vertexName": "Method public SnapshotsStatusRequest(String repository, String[] snapshots)  (SnapshotsStatusRequest.java)",
      "children": [
        {
          "name": "Method public GetSnapshotsRequest(String repository, String[] snapshots)  (GetSnapshotsRequest.java)"
        }
      ],
      "comment": "\n     * Constructs a new get snapshots request with given repository name and list of snapshots\n     *\n     * @param repository repository name\n     * @param snapshots  list of snapshots\n     ",
      "vertexLabel": "SnapshotsStatusRequest()"
    },
    {
      "vertexName": "Method void refresh(RefreshRequest request, ActionListener<RefreshResponse> listener)  (IndicesAdminClient.java)",
      "children": [
        {
          "name": "Method ActionFuture<RefreshResponse> refresh(RefreshRequest request)  (IndicesAdminClient.java)"
        }
      ],
      "comment": "\n     * Explicitly refresh one or more indices (making the content indexed since the last refresh searchable).\n     *\n     * @param request  The refresh request\n     * @param listener A listener to be notified with a result\n     * @see org.elasticsearch.client.Requests#refreshRequest(String...)\n     ",
      "vertexLabel": "void refresh()"
    },
    {
      "vertexName": "Package org.elasticsearch.persistent  (package-info.java)",
      "children": [
        {
          "name": "Class PersistentTasksExecutor  (PersistentTasksExecutor.java)"
        }
      ],
      "comment": "\n * The Persistent Tasks Executors are responsible for executing restartable tasks that can survive disappearance of a\n * coordinating and executor nodes.\n * <p>\n * In order to be resilient to node restarts, the persistent tasks are using the cluster state instead of a transport service to send\n * requests and responses. The execution is done in six phases:\n * <p>\n * 1. The coordinating node sends an ordinary transport request to the master node to start a new persistent task. This task is handled\n * by the {@link org.elasticsearch.persistent.PersistentTasksService}, which is using\n * {@link org.elasticsearch.persistent.PersistentTasksClusterService} to update cluster state with the record about running persistent\n * task.\n * <p>\n * 2. The master node updates the {@link org.elasticsearch.persistent.PersistentTasksCustomMetaData} in the cluster state to indicate\n * that there is a new persistent task running in the system.\n * <p>\n * 3. The {@link org.elasticsearch.persistent.PersistentTasksNodeService} running on every node in the cluster monitors changes in\n * the cluster state and starts execution of all new tasks assigned to the node it is running on.\n * <p>\n * 4. If the task fails to start on the node, the {@link org.elasticsearch.persistent.PersistentTasksNodeService} uses the\n * {@link org.elasticsearch.persistent.PersistentTasksCustomMetaData} to notify the\n * {@link org.elasticsearch.persistent.PersistentTasksService}, which reassigns the action to another node in the cluster.\n * <p>\n * 5. If a task finishes successfully on the node and calls listener.onResponse(), the corresponding persistent action is removed from the\n * cluster state unless removeOnCompletion flag for this task is set to false.\n * <p>\n * 6. The {@link org.elasticsearch.persistent.RemovePersistentTaskAction} action can be also used to remove the persistent task.\n ",
      "vertexLabel": "Package org.elasticsearch.persistent"
    },
    {
      "vertexName": "Method long getNumDocDeletes()  (InternalEngine.java)",
      "children": [
        {
          "name": "Method long getNumDocUpdates()  (InternalEngine.java)"
        }
      ],
      "comment": "\n     * Returns the number of documents have been deleted since this engine was opened.\n     * This count does not include the deletions from the existing segments before opening engine.\n     ",
      "vertexLabel": "long getNumDocDeletes()"
    },
    {
      "vertexName": "Method public ExecutorService executor(String name)  (ThreadPool.java)",
      "children": [
        {
          "name": "Method public ExecutorService generic()  (ThreadPool.java)"
        }
      ],
      "comment": "\n     * Get the {@link ExecutorService} with the given name. This executor service's\n     * {@link Executor#execute(Runnable)} method will run the {@link Runnable} it is given in the\n     * {@link ThreadContext} of the thread that queues it.\n     * <p>\n     * Warning: this {@linkplain ExecutorService} might not throw {@link RejectedExecutionException}\n     * if you submit a task while it shutdown. It will instead silently queue it and not run it.\n     *\n     * @param name the name of the executor service to obtain\n     * @throws IllegalArgumentException if no executor service with the specified name exists\n     ",
      "vertexLabel": "ExecutorService executor()"
    },
    {
      "vertexName": "Method public String getDefaultRaw(Settings settings)  (Setting.java)",
      "children": [
        {
          "name": "Method public T getDefault(Settings settings)  (Setting.java)"
        }
      ],
      "comment": "\n     * Returns the default value string representation for this setting.\n     * @param settings a settings object for settings that has a default value depending on another setting if available\n     ",
      "vertexLabel": "String getDefaultRaw()"
    },
    {
      "vertexName": "Method void onQueryPhase(SearchContext searchContext, long tookInNanos)  (SearchOperationListener.java)",
      "comment": "\n     * Executed after the query phase successfully finished.\n     * Note: this is not invoked if the query phase execution failed.\n     * @param searchContext the current search context\n     * @param tookInNanos the number of nanoseconds the query execution took\n     *\n     * @see #onFailedQueryPhase(SearchContext)\n     ",
      "vertexLabel": "void onQueryPhase()"
    },
    {
      "vertexName": "Field REST_EXCEPTION_SKIP_STACK_TRACE  (ElasticsearchException.java)",
      "children": [
        {
          "name": "Field REST_EXCEPTION_SKIP_CAUSE  (ElasticsearchException.java)"
        }
      ],
      "comment": "\n     * Passed in the {@link Params} of {@link #generateThrowableXContent(XContentBuilder, Params, Throwable)}\n     * to control if the {@code stack_trace} element should render. Unlike most parameters to {@code toXContent} methods this parameter is\n     * internal only and not available as a URL parameter. Use the {@code error_trace} parameter instead.\n     ",
      "vertexLabel": "Field REST_EXCEPTION_SKIP_STACK_TRACE"
    },
    {
      "vertexName": "Method public synchronized int totalOperations()  (RecoveryState.java)",
      "children": [
        {
          "name": "Method public synchronized int totalOperationsOnStart()  (RecoveryState.java)"
        }
      ],
      "comment": "\n         * returns the total number of translog operations needed to be recovered at this moment.\n         * Note that this can change as the number of operations grows during recovery.\n         * <p>\n         * A value of -1 ({@link RecoveryState.Translog#UNKNOWN} is return if this is unknown (typically a gateway recovery)\n         ",
      "vertexLabel": "synchronized int totalOperations()"
    },
    {
      "vertexName": "Class AutoDateHistogramAggregator  (AutoDateHistogramAggregator.java)",
      "comment": "\n * An aggregator for date values. Every date is rounded down using a configured\n * {@link Rounding}.\n *\n * @see Rounding\n ",
      "vertexLabel": "Class AutoDateHistogramAggregator"
    },
    {
      "vertexName": "Method void snapshotShard(IndexShard shard, Store store, SnapshotId snapshotId, IndexId indexId, IndexCommit snapshotIndexCommit, IndexShardSnapshotStatus snapshotStatus)  (Repository.java)",
      "children": [
        {
          "name": "Method SnapshotContext(Store store, SnapshotId snapshotId, IndexId indexId, IndexShardSnapshotStatus snapshotStatus, long startTime)  (BlobStoreRepository.java)"
        }
      ],
      "comment": "\n     * Creates a snapshot of the shard based on the index commit point.\n     * <p>\n     * The index commit point can be obtained by using {@link org.elasticsearch.index.engine.Engine#acquireLastIndexCommit} method.\n     * Repository implementations shouldn't release the snapshot index commit point. It is done by the method caller.\n     * <p>\n     * As snapshot process progresses, implementation of this method should update {@link IndexShardSnapshotStatus} object and check\n     * {@link IndexShardSnapshotStatus#isAborted()} to see if the snapshot process should be aborted.\n     * @param shard               shard to be snapshotted\n     * @param store               store to be snapshotted\n     * @param snapshotId          snapshot id\n     * @param indexId             id for the index being snapshotted\n     * @param snapshotIndexCommit commit point\n     * @param snapshotStatus      snapshot status\n     ",
      "vertexLabel": "void snapshotShard()"
    },
    {
      "vertexName": "Interface AdjacencyMatrix  (AdjacencyMatrix.java)",
      "children": [
        {
          "name": "Interface Filters  (Filters.java)"
        }
      ],
      "comment": "\n * A multi bucket aggregation where the buckets are defined by a set of filters\n * (a bucket is produced per filter plus a bucket for each non-empty filter \n * intersection so A, B and A&amp;B).\n ",
      "vertexLabel": "Interface AdjacencyMatrix"
    },
    {
      "vertexName": "Method public UpdateRequestBuilder setFetchSource(@Nullable String[] includes, @Nullable String[] excludes)  (UpdateRequestBuilder.java)",
      "children": [
        {
          "name": "Method public ExplainRequestBuilder setFetchSource(@Nullable String[] includes, @Nullable String[] excludes)  (ExplainRequestBuilder.java)"
        }
      ],
      "comment": "\n     * Indicate that _source should be returned, with an\n     * \"include\" and/or \"exclude\" set which can include simple wildcard\n     * elements.\n     *\n     * @param includes\n     *            An optional list of include (optionally wildcarded) pattern to\n     *            filter the returned _source\n     * @param excludes\n     *            An optional list of exclude (optionally wildcarded) pattern to\n     *            filter the returned _source\n     ",
      "vertexLabel": "UpdateRequestBuilder setFetchSource()"
    },
    {
      "vertexName": "Method public UpdateRequestBuilder setRouting(String routing)  (UpdateRequestBuilder.java)",
      "children": [
        {
          "name": "Method public GetRequest routing(String routing)  (GetRequest.java)"
        }
      ],
      "comment": "\n     * Controls the shard routing of the request. Using this value to hash the shard\n     * and not the id.\n     ",
      "vertexLabel": "UpdateRequestBuilder setRouting()"
    },
    {
      "vertexName": "Method QueryBuilder queryName(String queryName)  (QueryBuilder.java)",
      "comment": "\n     * Sets the arbitrary name to be assigned to the query (see named queries).\n     * Implementers should return the concrete type of the\n     * {@link QueryBuilder} so that calls can be chained. This is done\n     * automatically when extending {@link AbstractQueryBuilder}.\n     ",
      "vertexLabel": "QueryBuilder queryName()"
    },
    {
      "vertexName": "Method public PipelineAggregationSpec(String name, Writeable.Reader<? extends PipelineAggregationBuilder> builderReader, Writeable.Reader<? extends PipelineAggregator> aggregatorReader, PipelineAggregator.Parser parser)  (SearchPlugin.java)",
      "children": [
        {
          "name": "Method public AggregationSpec(String name, Writeable.Reader<? extends AggregationBuilder> reader, Aggregator.Parser parser)  (SearchPlugin.java)"
        }
      ],
      "comment": "\n         * Specification of a {@link PipelineAggregator}.\n         *\n         * @param name name by which this aggregation might be parsed or deserialized. Make sure it is the name that the\n         *        {@link PipelineAggregationBuilder} and {@link PipelineAggregator} should return from\n         *        {@link NamedWriteable#getWriteableName()}.\n         * @param builderReader the reader registered for this aggregation's builder. Typically a reference to a constructor that takes a\n         *        {@link StreamInput}\n         * @param aggregatorReader reads the {@link PipelineAggregator} from a stream\n         * @param parser reads the aggregation builder from XContent\n         ",
      "vertexLabel": "PipelineAggregationSpec()"
    },
    {
      "vertexName": "Method public static double unweightedAvg(double[] values)  (MovingFunctions.java)",
      "comment": "\n     * Calculate a simple unweighted (arithmetic) moving average.\n     *\n     * Only finite values are averaged.  NaN or null are ignored.\n     * If all values are missing/null/NaN, the return value will be NaN.\n     * The average is based on the count of non-null, non-NaN values.\n     ",
      "vertexLabel": "double unweightedAvg()"
    },
    {
      "vertexName": "Method public static Script parse(XContentParser parser, String defaultLang) throws IOException  (Script.java)",
      "children": [
        {
          "name": "Method public XContentBuilder toXContent(XContentBuilder builder, Params builderParams) throws IOException  (Script.java)"
        }
      ],
      "comment": "\n     * This will parse XContent into a {@link Script}.  The following formats can be parsed:\n     *\n     * The simple format defaults to an {@link ScriptType#INLINE} with no compiler options or user-defined params:\n     *\n     * Example:\n     * {@code\n     * \"return Math.log(doc.popularity) * 100;\"\n     * }\n     *\n     * The complex format where {@link ScriptType} and idOrCode are required while lang, options and params are not required.\n     *\n     * {@code\n     * {\n     *     // Exactly one of \"id\" or \"source\" must be specified\n     *     \"id\" : \"<id>\",\n     *     // OR\n     *     \"source\": \"<source>\",\n     *     \"lang\" : \"<lang>\",\n     *     \"options\" : {\n     *         \"option0\" : \"<option0>\",\n     *         \"option1\" : \"<option1>\",\n     *         ...\n     *     },\n     *     \"params\" : {\n     *         \"param0\" : \"<param0>\",\n     *         \"param1\" : \"<param1>\",\n     *         ...\n     *     }\n     * }\n     * }\n     *\n     * Example:\n     * {@code\n     * {\n     *     \"source\" : \"return Math.log(doc.popularity) * params.multiplier\",\n     *     \"lang\" : \"painless\",\n     *     \"params\" : {\n     *         \"multiplier\" : 100.0\n     *     }\n     * }\n     * }\n     *\n     * This also handles templates in a special way.  If a complexly formatted query is specified as another complex\n     * JSON object the query is assumed to be a template, and the format will be preserved.\n     *\n     * {@code\n     * {\n     *     \"source\" : { \"query\" : ... },\n     *     \"lang\" : \"<lang>\",\n     *     \"options\" : {\n     *         \"option0\" : \"<option0>\",\n     *         \"option1\" : \"<option1>\",\n     *         ...\n     *     },\n     *     \"params\" : {\n     *         \"param0\" : \"<param0>\",\n     *         \"param1\" : \"<param1>\",\n     *         ...\n     *     }\n     * }\n     * }\n     *\n     * @param parser       The {@link XContentParser} to be used.\n     * @param defaultLang  The default language to use if no language is specified.  The default language isn't necessarily\n     *                     the one defined by {@link Script#DEFAULT_SCRIPT_LANG} due to backwards compatibility requirements\n     *                     related to stored queries using previously default languages.\n     *\n     * @return             The parsed {@link Script}.\n     ",
      "vertexLabel": "Script parse()"
    },
    {
      "vertexName": "Method public IndicesOptions indicesOptions()  (RestoreSnapshotRequest.java)",
      "children": [
        {
          "name": "Method public CreateSnapshotRequestBuilder setIndicesOptions(IndicesOptions indicesOptions)  (CreateSnapshotRequestBuilder.java)"
        },
        {
          "name": "Method public MultiSearchRequestBuilder setIndicesOptions(IndicesOptions indicesOptions)  (MultiSearchRequestBuilder.java)"
        }
      ],
      "comment": "\n     * Specifies what type of requested indices to ignore and how to deal with wildcard expressions.\n     * For example indices that don't exist.\n     *\n     * @return the desired behaviour regarding indices to ignore and wildcard indices expression\n     ",
      "vertexLabel": "IndicesOptions indicesOptions()"
    },
    {
      "vertexName": "Method public SignificantTermsAggregationBuilder shardSize(int shardSize)  (SignificantTermsAggregationBuilder.java)",
      "children": [
        {
          "name": "Method public TermsAggregationBuilder shardSize(int shardSize)  (TermsAggregationBuilder.java)"
        }
      ],
      "comment": "\n     * Sets the shard_size - indicating the number of term buckets each shard\n     * will return to the coordinating node (the node that coordinates the\n     * search execution). The higher the shard size is, the more accurate the\n     * results are.\n     ",
      "vertexLabel": "SignificantTermsAggregationBuilder shardSize()"
    },
    {
      "vertexName": "Method public boolean isShardsAcknowledged()  (OpenIndexClusterStateUpdateResponse.java)",
      "children": [
        {
          "name": "Method public boolean isShardsAcknowledged()  (CreateIndexClusterStateUpdateResponse.java)"
        }
      ],
      "comment": "\n     * Returns whether the requisite number of shard copies started before the completion of the operation.\n     ",
      "vertexLabel": "boolean isShardsAcknowledged()"
    },
    {
      "vertexName": "Method public Map<String, Object> getResponseAsMap()  (TaskResult.java)",
      "children": [
        {
          "name": "Method public Map<String, Object> getErrorAsMap()  (TaskResult.java)"
        },
        {
          "name": "Method public BytesReference getResponse()  (TaskResult.java)"
        }
      ],
      "comment": "\n     * Convert {@link #getResponse()} from XContent to a Map for easy processing. Will return an empty map if the task was finished with an\n     * error, hasn't yet finished, or didn't store its result.\n     ",
      "vertexLabel": "Map<String, Object> getResponseAsMap()"
    },
    {
      "vertexName": "Method public static MultiMatchQueryBuilder multiMatchQuery(Object text, String... fieldNames)  (QueryBuilders.java)",
      "children": [
        {
          "name": "Method public static MatchQueryBuilder matchQuery(String name, Object text)  (QueryBuilders.java)"
        }
      ],
      "comment": "\n     * Creates a match query with type \"BOOLEAN\" for the provided field name and text.\n     *\n     * @param fieldNames The field names.\n     * @param text       The query text (to be analyzed).\n     ",
      "vertexLabel": "MultiMatchQueryBuilder multiMatchQuery()"
    },
    {
      "vertexName": "Method public GetSettingsRequestBuilder setIndicesOptions(IndicesOptions options)  (GetSettingsRequestBuilder.java)",
      "children": [
        {
          "name": "Method public DeleteIndexRequestBuilder setIndicesOptions(IndicesOptions options)  (DeleteIndexRequestBuilder.java)"
        }
      ],
      "comment": "\n     * Specifies what type of requested indices to ignore and wildcard indices expressions.\n     * <p>\n     * For example indices that don't exist.\n     ",
      "vertexLabel": "GetSettingsRequestBuilder setIndicesOptions()"
    },
    {
      "vertexName": "Method public TopHitsAggregationBuilder fetchSource(@Nullable String include, @Nullable String exclude)  (TopHitsAggregationBuilder.java)",
      "children": [
        {
          "name": "Method public SearchRequestBuilder setFetchSource(@Nullable String include, @Nullable String exclude)  (SearchRequestBuilder.java)"
        }
      ],
      "comment": "\n     * Indicate that _source should be returned with every hit, with an\n     * \"include\" and/or \"exclude\" set which can include simple wildcard\n     * elements.\n     *\n     * @param include\n     *            An optional include (optionally wildcarded) pattern to\n     *            filter the returned _source\n     * @param exclude\n     *            An optional exclude (optionally wildcarded) pattern to\n     *            filter the returned _source\n     ",
      "vertexLabel": "TopHitsAggregationBuilder fetchSource()"
    },
    {
      "vertexName": "Field retryBackoffInitialTime  (AbstractBulkByScrollRequest.java)",
      "comment": "\n     * Initial delay after a rejection before retrying a bulk request. With the default maxRetries the total backoff for retrying rejections\n     * is about one minute per bulk request. Once the entire bulk request is successful the retry counter resets.\n     ",
      "vertexLabel": "Field retryBackoffInitialTime"
    },
    {
      "vertexName": "Class QueryProfileBreakdown  (QueryProfileBreakdown.java)",
      "children": [
        {
          "name": "Class AbstractProfileBreakdown  (AbstractProfileBreakdown.java)"
        }
      ],
      "comment": "\n * A record of timings for the various operations that may happen during query execution.\n * A node's time may be composed of several internal attributes (rewriting, weighting,\n * scoring, etc).\n ",
      "vertexLabel": "Class QueryProfileBreakdown"
    },
    {
      "vertexName": "Method public void setWaitForActiveShards(final int waitForActiveShards)  (ResizeRequest.java)",
      "children": [
        {
          "name": "Method public BulkRequest waitForActiveShards(final int waitForActiveShards)  (BulkRequest.java)"
        }
      ],
      "comment": "\n     * A shortcut for {@link #setWaitForActiveShards(ActiveShardCount)} where the numerical\n     * shard count is passed in, instead of having to first call {@link ActiveShardCount#from(int)}\n     * to get the ActiveShardCount.\n     ",
      "vertexLabel": "void setWaitForActiveShards()"
    },
    {
      "vertexName": "Method InetSocketAddress getRemoteAddress()  (TcpChannel.java)",
      "comment": "\n     * Returns the remote address for this channel. Can be null if channel does not have a remote address.\n     *\n     * @return the remote address of this channel.\n     ",
      "vertexLabel": "InetSocketAddress getRemoteAddress()"
    },
    {
      "vertexName": "Method public QueryBuilder getNestedFilter()  (GeoDistanceSortBuilder.java)",
      "children": [
        {
          "name": "Method public QueryBuilder getNestedFilter()  (FieldSortBuilder.java)"
        }
      ],
      "comment": "\n     * Returns the nested filter that the nested objects should match with in order to be taken into account\n     * for sorting.\n     * @deprecated set nested sort with {@link #setNestedSort(NestedSortBuilder)}\n     *             and retrieve with {@link #getNestedSort()}\n     *",
      "vertexLabel": "QueryBuilder getNestedFilter()"
    },
    {
      "vertexName": "Class LinearModel  (LinearModel.java)",
      "comment": "\n * Calculate a linearly weighted moving average, such that older values are\n * linearly less important.  \"Time\" is determined by position in collection\n ",
      "vertexLabel": "Class LinearModel"
    },
    {
      "vertexName": "Method public MembersInjector<T> getDelegate()  (MembersInjectorLookup.java)",
      "children": [
        {
          "name": "Method public Provider<T> getDelegate()  (ProviderLookup.java)"
        }
      ],
      "comment": "\n     * Returns the delegate members injector, or {@code null} if it has not yet been initialized.\n     * The delegate will be initialized when this element is processed, or otherwise used to create\n     * an injector.\n     ",
      "vertexLabel": "MembersInjector<T> getDelegate()"
    },
    {
      "vertexName": "Method public static short toShortExact(Number n)  (Numbers.java)",
      "children": [
        {
          "name": "Method public static int toIntExact(Number n)  (Numbers.java)"
        }
      ],
      "comment": " Return the short that {@code n} stores, or throws an exception if the\n     *  stored value cannot be converted to a short that stores the exact same\n     *  value. ",
      "vertexLabel": "short toShortExact()"
    },
    {
      "vertexName": "Method void deleteUnassignedIndex(String reason, IndexMetaData metaData, ClusterState clusterState)  (IndicesClusterStateService.java)",
      "children": [
        {
          "name": "Method public void deleteUnassignedIndex(String reason, IndexMetaData metaData, ClusterState clusterState)  (IndicesService.java)"
        }
      ],
      "comment": "\n         * Deletes an index that is not assigned to this node. This method cleans up all disk folders relating to the index\n         * but does not deal with in-memory structures. For those call {@link #removeIndex(Index, IndexRemovalReason, String)}\n         ",
      "vertexLabel": "void deleteUnassignedIndex()"
    },
    {
      "vertexName": "Method public static TermQueryBuilder termQuery(String name, String value)  (QueryBuilders.java)",
      "comment": "\n     * A Query that matches documents containing a term.\n     *\n     * @param name  The name of the field\n     * @param value The value of the term\n     ",
      "vertexLabel": "TermQueryBuilder termQuery()"
    },
    {
      "vertexName": "Method public void setMaxConcurrentShardRequests(int maxConcurrentShardRequests)  (SearchRequest.java)",
      "children": [
        {
          "name": "Method public void setBatchedReduceSize(int batchedReduceSize)  (SearchRequest.java)"
        }
      ],
      "comment": "\n     * Sets the number of shard requests that should be executed concurrently on a single node. This value should be used as a\n     * protection mechanism to reduce the number of shard requests fired per high level search request. Searches that hit the entire\n     * cluster can be throttled with this number to reduce the cluster load. The default is {@code 5}\n     ",
      "vertexLabel": "void setMaxConcurrentShardRequests()"
    },
    {
      "vertexName": "Method BigArrays createBigArrays(PageCacheRecycler pageCacheRecycler, CircuitBreakerService circuitBreakerService)  (Node.java)",
      "comment": "\n     * Creates a new {@link BigArrays} instance used for this node.\n     * This method can be overwritten by subclasses to change their {@link BigArrays} implementation for instance for testing\n     ",
      "vertexLabel": "BigArrays createBigArrays()"
    },
    {
      "vertexName": "Method public BaseTermQueryBuilder(String fieldName, String value)  (BaseTermQueryBuilder.java)",
      "comment": "\n     * Constructs a new base term query.\n     *\n     * @param fieldName  The name of the field\n     * @param value The value of the term\n     ",
      "vertexLabel": "BaseTermQueryBuilder()"
    },
    {
      "vertexName": "Method public boolean isPreserveExisting()  (UpdateSettingsClusterStateUpdateRequest.java)",
      "comment": "\n     * Returns <code>true</code> iff the settings update should only add but not update settings. If the setting already exists\n     * it should not be overwritten by this update. The default is <code>false</code>\n     ",
      "vertexLabel": "boolean isPreserveExisting()"
    },
    {
      "vertexName": "Method void termVectors(TermVectorsRequest request, ActionListener<TermVectorsResponse> listener)  (Client.java)",
      "comment": "\n     * An action that returns the term vectors for a specific document.\n     *\n     * @param request The term vector request\n     ",
      "vertexLabel": "void termVectors()"
    },
    {
      "vertexName": "Method public void validateAliasFilter(String alias, String filter, QueryShardContext queryShardContext, NamedXContentRegistry xContentRegistry)  (AliasValidator.java)",
      "comment": "\n     * Validates an alias filter by parsing it using the\n     * provided {@link org.elasticsearch.index.query.QueryShardContext}\n     * @throws IllegalArgumentException if the filter is not valid\n     ",
      "vertexLabel": "void validateAliasFilter()"
    },
    {
      "vertexName": "Method public int getTotal()  (ReplicationResponse.java)",
      "comment": "\n         * @return the total number of shards the write should go to (replicas and primaries). This includes relocating shards, so this\n         *         number can be higher than the number of shards.\n         ",
      "vertexLabel": "int getTotal()"
    },
    {
      "vertexName": "Method ActionFuture<AcknowledgedResponse> aliases(IndicesAliasesRequest request)  (IndicesAdminClient.java)",
      "comment": "\n     * Allows to add/remove aliases from indices.\n     *\n     * @param request The index aliases request\n     * @return The result future\n     * @see Requests#indexAliasesRequest()\n     ",
      "vertexLabel": "ActionFuture<AcknowledgedResponse> aliases()"
    },
    {
      "vertexName": "Method private OsStats.Cgroup.CpuStat getCgroupCpuAcctCpuStat(final String controlGroup) throws IOException  (OsProbe.java)",
      "comment": "\n     * The CPU time statistics for all tasks in the Elasticsearch control group.\n     *\n     * @param controlGroup the control group for the Elasticsearch process for the {@code cpuacct} subsystem\n     * @return the CPU time statistics\n     * @throws IOException if an I/O exception occurs reading {@code cpu.stat} for the control group\n     ",
      "vertexLabel": "OsStats.Cgroup.CpuStat getCgroupCpuAcctCpuStat()"
    },
    {
      "vertexName": "Method public long getCpuAcctUsageNanos()  (OsStats.java)",
      "comment": "\n         * The total CPU time consumed by all tasks in the\n         * {@code cpuacct} control group from\n         * {@link Cgroup#cpuAcctControlGroup}.\n         *\n         * @return the total CPU time in nanoseconds\n         ",
      "vertexLabel": "long getCpuAcctUsageNanos()"
    },
    {
      "vertexName": "Method public long getShardSize(ShardRouting shardRouting, long defaultValue)  (ClusterInfo.java)",
      "children": [
        {
          "name": "Method public Long getShardSize(ShardRouting shardRouting)  (ClusterInfo.java)"
        }
      ],
      "comment": "\n     * Returns the shard size for the given shard routing or <code>defaultValue</code> it that metric is not available.\n     ",
      "vertexLabel": "long getShardSize()"
    },
    {
      "vertexName": "Method public FieldSortBuilder setNestedPath(String nestedPath)  (FieldSortBuilder.java)",
      "children": [
        {
          "name": "Method public ScriptSortBuilder setNestedPath(String nestedPath)  (ScriptSortBuilder.java)"
        }
      ],
      "comment": "\n     * Sets the nested path if sorting occurs on a field that is inside a nested\n     * object. By default when sorting on a field inside a nested object, the\n     * nearest upper nested object is selected as nested path.\n     *\n     * @deprecated set nested sort with {@link #setNestedSort(NestedSortBuilder)} and retrieve with {@link #getNestedSort()}\n     ",
      "vertexLabel": "FieldSortBuilder setNestedPath()"
    },
    {
      "vertexName": "Method public AnalysisProvider<CharFilterFactory> getCharFilterProvider(String charFilter, IndexSettings indexSettings)  (AnalysisRegistry.java)",
      "children": [
        {
          "name": "Method public AnalysisProvider<TokenizerFactory> getTokenizerProvider(String tokenizer, IndexSettings indexSettings)  (AnalysisRegistry.java)"
        }
      ],
      "comment": "\n     * Returns a registered {@link CharFilterFactory} provider by {@link IndexSettings}\n     *  or a registered {@link CharFilterFactory} provider by predefined name\n     *  or <code>null</code> if the charFilter was not registered\n     * @param charFilter global or defined charFilter name\n     * @param indexSettings an index settings\n     * @return {@link CharFilterFactory} provider or <code>null</code>\n     ",
      "vertexLabel": "AnalysisProvider<CharFilterFactory> getCharFilterProvider()"
    },
    {
      "vertexName": "Method public final QB boost(float boost)  (AbstractQueryBuilder.java)",
      "comment": "\n     * Sets the boost for this query.  Documents matching this query will (in addition to the normal\n     * weightings) have their score multiplied by the boost provided.\n     ",
      "vertexLabel": "final QB boost()"
    },
    {
      "vertexName": "Method public FuzzyQueryBuilder(String fieldName, double value)  (FuzzyQueryBuilder.java)",
      "children": [
        {
          "name": "Method public FuzzyQueryBuilder(String fieldName, String value)  (FuzzyQueryBuilder.java)"
        }
      ],
      "comment": "\n     * Constructs a new fuzzy query.\n     *\n     * @param fieldName  The name of the field\n     * @param value The value of the text\n     ",
      "vertexLabel": "FuzzyQueryBuilder()"
    },
    {
      "vertexName": "Method public IndexShardRoutingTable shardRoutingTable(String index, int shardId)  (RoutingTable.java)",
      "children": [
        {
          "name": "Method public IndexShardRoutingTable shardRoutingTable(ShardId shardId)  (RoutingTable.java)"
        }
      ],
      "comment": "\n     * All shards for the provided index and shard id\n     * @return All the shard routing entries for the given index and shard id\n     * @throws IndexNotFoundException if provided index does not exist\n     * @throws ShardNotFoundException if provided shard id is unknown\n     ",
      "vertexLabel": "IndexShardRoutingTable shardRoutingTable()"
    },
    {
      "vertexName": "Method public GroupShardsIterator<ShardIterator> allAssignedShardsGrouped(String[] indices, boolean includeEmpty, boolean includeRelocationTargets)  (RoutingTable.java)",
      "children": [
        {
          "name": "Method public GroupShardsIterator allActiveShardsGrouped(String[] indices, boolean includeEmpty, boolean includeRelocationTargets)  (RoutingTable.java)"
        }
      ],
      "comment": "\n     * Return GroupShardsIterator where each assigned shard routing has it's own shard iterator.\n     *\n     * @param includeEmpty             if true, a shard iterator will be added for non-assigned shards as well\n     * @param includeRelocationTargets if true, an <b>extra</b> shard iterator will be added for relocating shards. The extra\n     *                                 iterator contains a single ShardRouting pointing at the relocating target\n     ",
      "vertexLabel": "GroupShardsIterator<ShardIterator> allAssignedShardsGrouped()"
    },
    {
      "vertexName": "Method ActionFuture<AcknowledgedResponse> close(CloseIndexRequest request)  (IndicesAdminClient.java)",
      "children": [
        {
          "name": "Method ActionFuture<OpenIndexResponse> open(OpenIndexRequest request)  (IndicesAdminClient.java)"
        }
      ],
      "comment": "\n     * Closes an index based on the index name.\n     *\n     * @param request The close index request\n     * @return The result future\n     * @see org.elasticsearch.client.Requests#closeIndexRequest(String)\n     ",
      "vertexLabel": "ActionFuture<AcknowledgedResponse> close()"
    },
    {
      "vertexName": "Method public synchronized void initiateTracking(final String allocationId)  (ReplicationTracker.java)",
      "comment": "\n     * Called when the recovery process for a shard has opened the engine on the target shard. Ensures that the right data structures\n     * have been set up locally to track local checkpoint information for the shard and that the shard is added to the replication group.\n     *\n     * @param allocationId  the allocation ID of the shard for which recovery was initiated\n     ",
      "vertexLabel": "synchronized void initiateTracking()"
    },
    {
      "vertexName": "Method public static MatchPhrasePrefixQueryBuilder matchPhrasePrefixQuery(String name, Object text)  (QueryBuilders.java)",
      "children": [
        {
          "name": "Method public static MatchQueryBuilder matchQuery(String name, Object text)  (QueryBuilders.java)"
        }
      ],
      "comment": "\n     * Creates a match query with type \"PHRASE_PREFIX\" for the provided field name and text.\n     *\n     * @param name The field name.\n     * @param text The query text (to be analyzed).\n     ",
      "vertexLabel": "MatchPhrasePrefixQueryBuilder matchPhrasePrefixQuery()"
    },
    {
      "vertexName": "Method public boolean forcedRefresh()  (DocWriteResponse.java)",
      "comment": "\n     * Did this request force a refresh? Requests that set {@link WriteRequest#setRefreshPolicy(RefreshPolicy)} to\n     * {@link RefreshPolicy#IMMEDIATE} will always return true for this. Requests that set it to {@link RefreshPolicy#WAIT_UNTIL} will\n     * only return true here if they run out of refresh listener slots (see {@link IndexSettings#MAX_REFRESH_LISTENERS_PER_SHARD}).\n     ",
      "vertexLabel": "boolean forcedRefresh()"
    },
    {
      "vertexName": "Method public static MatchPhraseQueryBuilder matchPhraseQuery(String name, Object text)  (QueryBuilders.java)",
      "comment": "\n     * Creates a text query with type \"PHRASE\" for the provided field name and text.\n     *\n     * @param name The field name.\n     * @param text The query text (to be analyzed).\n     ",
      "vertexLabel": "MatchPhraseQueryBuilder matchPhraseQuery()"
    },
    {
      "vertexName": "Method public ClusterUpdateSettingsRequest transientSettings(String source, XContentType xContentType)  (ClusterUpdateSettingsRequest.java)",
      "comment": "\n     * Sets the source containing the transient settings to be updated. They will not survive a full cluster restart\n     ",
      "vertexLabel": "ClusterUpdateSettingsRequest transientSettings()"
    },
    {
      "vertexName": "Method public Self setRequestsPerSecond(float requestsPerSecond)  (AbstractBulkByScrollRequest.java)",
      "children": [
        {
          "name": "Field requestsPerSecond  (AbstractBulkByScrollRequest.java)"
        }
      ],
      "comment": "\n     * Set the throttle for this request in sub-requests per second. {@link Float#POSITIVE_INFINITY} means set no throttle and that is the\n     * default. Throttling is done between batches, as we start the next scroll requests. That way we can increase the scroll's timeout to\n     * make sure that it contains any time that we might wait.\n     ",
      "vertexLabel": "Self setRequestsPerSecond()"
    },
    {
      "vertexName": "Method public GeoDistanceSortBuilder setNestedSort(final NestedSortBuilder nestedSort)  (GeoDistanceSortBuilder.java)",
      "children": [
        {
          "name": "Method public FieldSortBuilder setNestedSort(final NestedSortBuilder nestedSort)  (FieldSortBuilder.java)"
        }
      ],
      "comment": "\n     * Sets the {@link NestedSortBuilder} to be used for fields that are inside a nested\n     * object. The {@link NestedSortBuilder} takes a `path` argument and an optional\n     * nested filter that the nested objects should match with in\n     * order to be taken into account for sorting.\n     ",
      "vertexLabel": "GeoDistanceSortBuilder setNestedSort()"
    },
    {
      "vertexName": "Method public PutIndexTemplateRequestBuilder addMapping(String type, XContentBuilder source)  (PutIndexTemplateRequestBuilder.java)",
      "children": [
        {
          "name": "Method public CreateIndexRequest mapping(String type, XContentBuilder source)  (CreateIndexRequest.java)"
        }
      ],
      "comment": "\n     * Adds mapping that will be added when the index template gets created.\n     *\n     * @param type   The mapping type\n     * @param source The mapping source\n     ",
      "vertexLabel": "PutIndexTemplateRequestBuilder addMapping()"
    },
    {
      "vertexName": "Method public abstract int docValueCount()  (SortedNumericDoubleValues.java)",
      "children": [
        {
          "name": "Method public abstract int docValueCount()  (SortedBinaryDocValues.java)"
        }
      ],
      "comment": " \n     * Retrieves the number of values for the current document.  This must always\n     * be greater than zero.\n     * It is illegal to call this method after {@link #advanceExact(int)}\n     * returned {@code false}.\n     ",
      "vertexLabel": "abstract int docValueCount()"
    },
    {
      "vertexName": "Method TermVectorsRequestBuilder prepareTermVectors(String index, String type, String id)  (Client.java)",
      "comment": "\n     * Builder for the term vector request.\n     *\n     * @param index The index to load the document from\n     * @param type  The type of the document\n     * @param id    The id of the document\n     ",
      "vertexLabel": "TermVectorsRequestBuilder prepareTermVectors()"
    },
    {
      "vertexName": "Method public UpdateRequest script(String script, @Nullable String scriptLang, ScriptType scriptType, @Nullable Map<String, Object> scriptParams)  (UpdateRequest.java)",
      "children": [
        {
          "name": "Method public UpdateRequest script(String script, ScriptType scriptType)  (UpdateRequest.java)"
        }
      ],
      "comment": "\n     * The script to execute. Note, make sure not to send different script each\n     * times and instead use script params if possible with the same\n     * (automatically compiled) script.\n     *\n     * @param script\n     *            The script to execute\n     * @param scriptLang\n     *            The script language\n     * @param scriptType\n     *            The script type\n     * @param scriptParams\n     *            The script parameters\n     *\n     * @deprecated Use {@link #script(Script)} instead\n     ",
      "vertexLabel": "UpdateRequest script()"
    },
    {
      "vertexName": "Field startTime  (Task.java)",
      "comment": "\n     * The task's start time as a wall clock time since epoch ({@link System#currentTimeMillis()} style).\n     ",
      "vertexLabel": "Field startTime"
    },
    {
      "vertexName": "Method protected CountDownLatch updateNodeStats(final ActionListener<NodesStatsResponse> listener)  (InternalClusterInfoService.java)",
      "comment": "\n     * Retrieve the latest nodes stats, calling the listener when complete\n     * @return a latch that can be used to wait for the nodes stats to complete if desired\n     ",
      "vertexLabel": "CountDownLatch updateNodeStats()"
    },
    {
      "vertexName": "Method Provider<T> getProvider(Key<T> key)  (TypeEncounter.java)",
      "comment": "\n     * Returns the provider used to obtain instances for the given injection key. The returned\n     * provider will not be valid until the injector has been created. The provider will throw an\n     * {@code IllegalStateException} if you try to use it beforehand.\n     ",
      "vertexLabel": "Provider<T> getProvider()"
    },
    {
      "vertexName": "Method public ClusterStateHealth(final ClusterState clusterState, final String[] concreteIndices)  (ClusterStateHealth.java)",
      "children": [
        {
          "name": "Method public ClusterStateHealth(final ClusterState clusterState)  (ClusterStateHealth.java)"
        }
      ],
      "comment": "\n     * Creates a new <code>ClusterStateHealth</code> instance considering the current cluster state and the provided index names.\n     *\n     * @param clusterState    The current cluster state. Must not be null.\n     * @param concreteIndices An array of index names to consider. Must not be null but may be empty.\n     ",
      "vertexLabel": "ClusterStateHealth()"
    },
    {
      "vertexName": "Method long ramBytesUsedForRefresh()  (LiveVersionMap.java)",
      "comment": "\n     * Returns how much RAM would be freed up by refreshing. This is {@link #ramBytesUsed} except does not include tombstones because they\n     * don't clear on refresh.\n     ",
      "vertexLabel": "long ramBytesUsedForRefresh()"
    },
    {
      "vertexName": "Method public UpdateRequest script(Script script)  (UpdateRequest.java)",
      "comment": "\n     * The script to execute. Note, make sure not to send different script each times and instead\n     * use script params if possible with the same (automatically compiled) script.\n     ",
      "vertexLabel": "UpdateRequest script()"
    },
    {
      "vertexName": "Method public FieldSortBuilder sortMode(SortMode sortMode)  (FieldSortBuilder.java)",
      "children": [
        {
          "name": "Enum MultiValueMode  (MultiValueMode.java)"
        },
        {
          "name": "Method public SortMode sortMode()  (FieldSortBuilder.java)"
        }
      ],
      "comment": "\n     * Defines what values to pick in the case a document contains multiple\n     * values for the targeted sort field. Possible values: min, max, sum and\n     * avg\n     *\n     * <p>\n     * The last two values are only applicable for number based fields.\n     ",
      "vertexLabel": "FieldSortBuilder sortMode()"
    },
    {
      "vertexName": "Method public ClusterRerouteRequestBuilder add(AllocationCommand... commands)  (ClusterRerouteRequestBuilder.java)",
      "children": [
        {
          "name": "Method public ClusterRerouteRequest add(AllocationCommand... commands)  (ClusterRerouteRequest.java)"
        }
      ],
      "comment": "\n     * Adds allocation commands to be applied to the cluster. Note, can be empty, in which case\n     * will simply run a simple \"reroute\".\n     ",
      "vertexLabel": "ClusterRerouteRequestBuilder add()"
    },
    {
      "vertexName": "Method T actionGet(long timeout, TimeUnit unit)  (ActionFuture.java)",
      "children": [
        {
          "name": "Method T actionGet(String timeout)  (ActionFuture.java)"
        }
      ],
      "comment": "\n     * Similar to {@link #get(long, java.util.concurrent.TimeUnit)}, just catching the {@link InterruptedException} and throwing\n     * an {@link IllegalStateException} instead. Also catches\n     * {@link java.util.concurrent.ExecutionException} and throws the actual cause instead.\n     ",
      "vertexLabel": "T actionGet()"
    },
    {
      "vertexName": "Method protected SendSnapshotResult sendSnapshot(final long startingSeqNo, long requiredSeqNoRangeStart, long endingSeqNo, final Translog.Snapshot snapshot, final long maxSeenAutoIdTimestamp, final long maxSeqNoOfUpdatesOrDeletes) throws IOException  (RecoverySourceHandler.java)",
      "children": [
        {
          "name": "Method long phase2(final long startingSeqNo, long requiredSeqNoRangeStart, long endingSeqNo, final Translog.Snapshot snapshot, final long maxSeenAutoIdTimestamp, final long maxSeqNoOfUpdatesOrDeletes) throws IOException  (RecoverySourceHandler.java)"
        }
      ],
      "comment": "\n     * Send the given snapshot's operations with a sequence number greater than the specified staring sequence number to this handler's\n     * target node.\n     * <p>\n     * Operations are bulked into a single request depending on an operation count limit or size-in-bytes limit.\n     *\n     * @param startingSeqNo              the sequence number for which only operations with a sequence number greater than this will be sent\n     * @param requiredSeqNoRangeStart    the lower sequence number of the required range\n     * @param endingSeqNo                the upper bound of the sequence number range to be sent (inclusive)\n     * @param snapshot                   the translog snapshot to replay operations from  @return the local checkpoint on the target and the\n     *                                   total number of operations sent\n     * @param maxSeenAutoIdTimestamp     the max auto_id_timestamp of append-only requests on the primary\n     * @param maxSeqNoOfUpdatesOrDeletes the max seq_no of updates or deletes on the primary after these operations were executed on it.\n     * @throws IOException if an I/O exception occurred reading the translog snapshot\n     ",
      "vertexLabel": "SendSnapshotResult sendSnapshot()"
    },
    {
      "vertexName": "Method public boolean updateDynamicSettings(Settings toApply, Settings.Builder target, Settings.Builder updates, String type)  (AbstractScopedSettings.java)",
      "children": [
        {
          "name": "Method public boolean updateSettings(Settings toApply, Settings.Builder target, Settings.Builder updates, String type)  (AbstractScopedSettings.java)"
        }
      ],
      "comment": "\n     * Updates a target settings builder with new, updated or deleted settings from a given settings builder.\n     * <p>\n     * Note: This method will only allow updates to dynamic settings. if a non-dynamic setting is updated an\n     * {@link IllegalArgumentException} is thrown instead.\n     * </p>\n     *\n     * @param toApply the new settings to apply\n     * @param target the target settings builder that the updates are applied to. All keys that have explicit null value in toApply will be\n     *        removed from this builder\n     * @param updates a settings builder that holds all updates applied to target\n     * @param type a free text string to allow better exceptions messages\n     * @return <code>true</code> if the target has changed otherwise <code>false</code>\n     ",
      "vertexLabel": "boolean updateDynamicSettings()"
    },
    {
      "vertexName": "Method public MultiSearchRequestBuilder setMaxConcurrentSearchRequests(int maxConcurrentSearchRequests)  (MultiSearchRequestBuilder.java)",
      "children": [
        {
          "name": "Method public MultiSearchRequest maxConcurrentSearchRequests(int maxConcurrentSearchRequests)  (MultiSearchRequest.java)"
        }
      ],
      "comment": "\n     * Sets how many search requests specified in this multi search requests are allowed to be ran concurrently.\n     ",
      "vertexLabel": "MultiSearchRequestBuilder setMaxConcurrentSearchRequests()"
    },
    {
      "vertexName": "Method public Builder setUnicodeAware(boolean unicodeAware)  (FuzzyOptions.java)",
      "children": [
        {
          "name": "Method public boolean isUnicodeAware()  (FuzzyOptions.java)"
        }
      ],
      "comment": "\n         * Set to true if all measurements (like edit distance, transpositions and lengths) are in unicode\n         * code points (actual letters) instead of bytes. Default is false.\n         ",
      "vertexLabel": "Builder setUnicodeAware()"
    },
    {
      "vertexName": "Method public static long readMinTranslogGeneration(final Path location, final String expectedTranslogUUID) throws IOException  (Translog.java)",
      "children": [
        {
          "name": "Method public static long readGlobalCheckpoint(final Path location, final String expectedTranslogUUID) throws IOException  (Translog.java)"
        }
      ],
      "comment": "\n     * Returns the minimum translog generation retained by the translog at the given location.\n     * This ensures that the translogUUID from this translog matches with the provided translogUUID.\n     *\n     * @param location the location of the translog\n     * @return the minimum translog generation\n     * @throws IOException                if an I/O exception occurred reading the checkpoint\n     * @throws TranslogCorruptedException if the translog is corrupted or mismatched with the given uuid\n     ",
      "vertexLabel": "long readMinTranslogGeneration()"
    },
    {
      "vertexName": "Method SearchScrollRequestBuilder prepareSearchScroll(String scrollId)  (Client.java)",
      "comment": "\n     * A search scroll request to continue searching a previous scrollable search request.\n     ",
      "vertexLabel": "SearchScrollRequestBuilder prepareSearchScroll()"
    },
    {
      "vertexName": "Method public static void validateMapperStructure(String type, Collection<ObjectMapper> objectMappers, Collection<FieldMapper> fieldMappers, Collection<FieldAliasMapper> fieldAliasMappers, Map<String, ObjectMapper> fullPathObjectMappers, FieldTypeLookup fieldTypes)  (MapperMergeValidator.java)",
      "children": [
        {
          "name": "Method public static void validateFieldReferences(List<FieldMapper> fieldMappers, List<FieldAliasMapper> fieldAliasMappers, Map<String, ObjectMapper> fullPathObjectMappers, FieldTypeLookup fieldTypes)  (MapperMergeValidator.java)"
        }
      ],
      "comment": "\n     * Validates the overall structure of the mapping addition, including whether\n     * duplicate fields are present, and if the provided fields have already been\n     * defined with a different data type.\n     *\n     * @param type The mapping type, for use in error messages.\n     * @param objectMappers The newly added object mappers.\n     * @param fieldMappers The newly added field mappers.\n     * @param fieldAliasMappers The newly added field alias mappers.\n     * @param fullPathObjectMappers All object mappers, indexed by their full path.\n     * @param fieldTypes All field and field alias mappers, collected into a lookup structure.\n     ",
      "vertexLabel": "void validateMapperStructure()"
    },
    {
      "vertexName": "Method public Query like(Fields... likeFields) throws IOException  (XMoreLikeThis.java)",
      "children": [
        {
          "name": "Method public Query like(Terms... likeTerms) throws IOException  (XMoreLikeThis.java)"
        }
      ],
      "comment": "\n     * Return a query that will return docs like the passed Fields.\n     *\n     * @return a query that will return docs like the passed Fields.\n     ",
      "vertexLabel": "Query like()"
    },
    {
      "vertexName": "Method public QueryStringQueryBuilder type(MultiMatchQueryBuilder.Type type)  (QueryStringQueryBuilder.java)",
      "comment": "\n     * @param type Sets how multiple fields should be combined to build textual part queries.\n     ",
      "vertexLabel": "QueryStringQueryBuilder type()"
    },
    {
      "vertexName": "Method public PutIndexTemplateRequestBuilder addMapping(String type, String source, XContentType xContentType)  (PutIndexTemplateRequestBuilder.java)",
      "children": [
        {
          "name": "Method public PutIndexTemplateRequestBuilder addMapping(String type, XContentBuilder source)  (PutIndexTemplateRequestBuilder.java)"
        }
      ],
      "comment": "\n     * Adds mapping that will be added when the index template gets created.\n     *\n     * @param type   The mapping type\n     * @param source The mapping source\n     * @param xContentType The type/format of the source\n     ",
      "vertexLabel": "PutIndexTemplateRequestBuilder addMapping()"
    },
    {
      "vertexName": "Method public void initiateTracking(final String allocationId)  (IndexShard.java)",
      "children": [
        {
          "name": "Method public synchronized void initiateTracking(final String allocationId)  (ReplicationTracker.java)"
        }
      ],
      "comment": "\n     * Called when the recovery process for a shard has opened the engine on the target shard. Ensures that the right data structures\n     * have been set up locally to track local checkpoint information for the shard and that the shard is added to the replication group.\n     *\n     * @param allocationId  the allocation ID of the shard for which recovery was initiated\n     ",
      "vertexLabel": "void initiateTracking()"
    },
    {
      "vertexName": "Method public long add(long key)  (LongHash.java)",
      "children": [
        {
          "name": "Method public long add(BytesRef key, int code)  (BytesRefHash.java)"
        }
      ],
      "comment": "\n     * Try to add <code>key</code>. Return its newly allocated id if it wasn't in the hash table yet, or <code>-1-id</code>\n     * if it was already present in the hash table.\n     ",
      "vertexLabel": "long add()"
    },
    {
      "vertexName": "Method public RestoreSnapshotRequest includeGlobalState(boolean includeGlobalState)  (RestoreSnapshotRequest.java)",
      "comment": "\n     * If set to true the restore procedure will restore global cluster state.\n     * <p>\n     * The global cluster state includes persistent settings and index template definitions.\n     *\n     * @param includeGlobalState true if global state should be restored from the snapshot\n     * @return this request\n     ",
      "vertexLabel": "RestoreSnapshotRequest includeGlobalState()"
    },
    {
      "vertexName": "Method public void registerRepository(final RegisterRepositoryRequest request, final ActionListener<ClusterStateUpdateResponse> listener)  (RepositoriesService.java)",
      "children": [
        {
          "name": "Method public void unregisterRepository(final UnregisterRepositoryRequest request, final ActionListener<ClusterStateUpdateResponse> listener)  (RepositoriesService.java)"
        }
      ],
      "comment": "\n     * Registers new repository in the cluster\n     * <p>\n     * This method can be only called on the master node. It tries to create a new repository on the master\n     * and if it was successful it adds new repository to cluster metadata.\n     *\n     * @param request  register repository request\n     * @param listener register repository listener\n     ",
      "vertexLabel": "void registerRepository()"
    },
    {
      "vertexName": "Method public MoreLikeThisQueryBuilder minimumShouldMatch(String minimumShouldMatch)  (MoreLikeThisQueryBuilder.java)",
      "children": [
        {
          "name": "Method public String getMinimumShouldMatch()  (MoreLikeThisQuery.java)"
        }
      ],
      "comment": "\n     * Number of terms that must match the generated query expressed in the\n     * common syntax for minimum should match. Defaults to {@code 30%}.\n     *\n     * @see    org.elasticsearch.common.lucene.search.Queries#calculateMinShouldMatch(int, String)\n     ",
      "vertexLabel": "MoreLikeThisQueryBuilder minimumShouldMatch()"
    },
    {
      "vertexName": "Method public AnalyzeRequestBuilder setTokenizer(Map<String, ?> tokenizer)  (AnalyzeRequestBuilder.java)",
      "children": [
        {
          "name": "Method public AnalyzeRequestBuilder setTokenizer(String tokenizer)  (AnalyzeRequestBuilder.java)"
        }
      ],
      "comment": "\n     * Instead of setting the analyzer, sets the tokenizer using custom settings that will be used as part of a custom\n     * analyzer.\n     ",
      "vertexLabel": "AnalyzeRequestBuilder setTokenizer()"
    },
    {
      "vertexName": "EnumConstant SEE_OTHER  (RestStatus.java)",
      "comment": "\n     * The response to the request can be found under a different URI and SHOULD be retrieved using a GET method on\n     * that resource. This method exists primarily to allow the output of a POST-activated script to redirect the\n     * user agent to a selected resource. The new URI is not a substitute reference for the originally requested\n     * resource. The 303 response MUST NOT be cached, but the response to the second (redirected) request might be\n     * cacheable.\n     * <p>\n     * The different URI SHOULD be given by the Location field in the response. Unless the request method was\n     * HEAD, the entity of the response SHOULD contain a short hypertext note with a hyperlink to the new URI(s).\n     ",
      "vertexLabel": "EnumConstant SEE_OTHER"
    },
    {
      "vertexName": "Method public boolean isBoost()  (XMoreLikeThis.java)",
      "children": [
        {
          "name": "Method public void setBoost(boolean boost)  (XMoreLikeThis.java)"
        }
      ],
      "comment": "\n     * Returns whether to boost terms in query based on \"score\" or not. The default is\n     * {@link #DEFAULT_BOOST}.\n     *\n     * @return whether to boost terms in query based on \"score\" or not.\n     * @see #setBoost\n     ",
      "vertexLabel": "boolean isBoost()"
    },
    {
      "vertexName": "Method public static double holtWinters(double[] values, double alpha, double beta, double gamma, int period, boolean multiplicative)  (MovingFunctions.java)",
      "children": [
        {
          "name": "Method public static double holt(double[] values, double alpha, double beta)  (MovingFunctions.java)"
        }
      ],
      "comment": "\n     * Calculate a triple exponential weighted moving average\n     *\n     * Alpha controls the smoothing of the data.  Alpha = 1 retains no memory of past values\n     * (e.g. a random walk), while alpha = 0 retains infinite memory of past values (e.g.\n     * the series mean).  Useful values are somewhere in between.  Defaults to 0.5.\n     *\n     * Beta is equivalent to alpha, but controls the smoothing of the trend instead of the data.\n     * Gamma is equivalent to alpha, but controls the smoothing of the seasonality instead of the data\n     *\n     * Only finite values are averaged.  NaN or null are ignored.\n     * If all values are missing/null/NaN, the return value will be NaN\n     * The average is based on the count of non-null, non-NaN values.\n     *\n     * @param alpha A double between 0-1 inclusive, controls data smoothing\n     * @param beta a double between 0-1 inclusive, controls trend smoothing\n     * @param gamma a double between 0-1 inclusive, controls seasonality smoothing\n     * @param period the expected periodicity of the data\n     * @param multiplicative true if multiplicative HW should be used. False for additive\n     ",
      "vertexLabel": "double holtWinters()"
    },
    {
      "vertexName": "Method void onElectedAsMaster(ClusterState state)  (NodeJoinController.java)",
      "children": [
        {
          "name": "Method void onFailure(Throwable t)  (NodeJoinController.java)"
        }
      ],
      "comment": "\n         * called when the local node is successfully elected as master\n         * Guaranteed to be called on the cluster state update thread\n         *",
      "vertexLabel": "void onElectedAsMaster()"
    },
    {
      "vertexName": "Method public HoltLinearModelBuilder beta(double beta)  (HoltLinearModel.java)",
      "comment": "\n         * Equivalent to <code>alpha</code>, but controls the smoothing of the trend instead of the data\n         *\n         * @param beta a double between 0-1 inclusive, controls trend smoothing\n         *\n         * @return The builder to continue chaining\n         ",
      "vertexLabel": "HoltLinearModelBuilder beta()"
    },
    {
      "vertexName": "Method public static Injector createInjector(Iterable<? extends Module> modules)  (Guice.java)",
      "comment": "\n     * Creates an injector for the given set of modules.\n     *\n     * @throws CreationException if one or more errors occur during Injector\n     *                           creation\n     ",
      "vertexLabel": "Injector createInjector()"
    },
    {
      "vertexName": "Method Map<String, BlobMetaData> listBlobs() throws IOException  (BlobContainer.java)",
      "comment": "\n     * Lists all blobs in the container.\n     *\n     * @return  A map of all the blobs in the container.  The keys in the map are the names of the blobs and\n     *          the values are {@link BlobMetaData}, containing basic information about each blob.\n     * @throws  IOException if there were any failures in reading from the blob container.\n     ",
      "vertexLabel": "Map<String, BlobMetaData> listBlobs()"
    },
    {
      "vertexName": "Method public abstract boolean advanceExact(int doc) throws IOException  (MultiGeoPointValues.java)",
      "children": [
        {
          "name": "Method public abstract boolean advanceExact(int doc) throws IOException  (SortedBinaryDocValues.java)"
        }
      ],
      "comment": "\n     * Advance this instance to the given document id\n     * @return true if there is a value for this document\n     ",
      "vertexLabel": "abstract boolean advanceExact()"
    },
    {
      "vertexName": "Field translogGenerationOfLastCommit  (TranslogDeletionPolicy.java)",
      "comment": "\n     * This translog generation is used to calculate the number of uncommitted operations since the last index commit.\n     ",
      "vertexLabel": "Field translogGenerationOfLastCommit"
    },
    {
      "vertexName": "Method public final void validate(AggregatorFactory<?> parent, Collection<AggregationBuilder> factories, Collection<PipelineAggregationBuilder> pipelineAggregatorFactories)  (AbstractPipelineAggregationBuilder.java)",
      "comment": "\n     * Validates the state of this factory (makes sure the factory is properly\n     * configured)\n     ",
      "vertexLabel": "final void validate()"
    },
    {
      "vertexName": "Method public String[] concreteIndexNames(ClusterState state, IndicesRequest request)  (IndexNameExpressionResolver.java)",
      "children": [
        {
          "name": "Method public Index[] concreteIndices(ClusterState state, IndicesRequest request)  (IndexNameExpressionResolver.java)"
        }
      ],
      "comment": "\n     * Same as {@link #concreteIndexNames(ClusterState, IndicesOptions, String...)}, but the index expressions and options\n     * are encapsulated in the specified request.\n     ",
      "vertexLabel": "String[] concreteIndexNames()"
    },
    {
      "vertexName": "Method private static AfterEffect parseAfterEffect(Version indexCreatedVersion, Settings settings)  (SimilarityProviders.java)",
      "children": [
        {
          "name": "Method private static Lambda parseLambda(Settings settings)  (SimilarityProviders.java)"
        }
      ],
      "comment": "\n     * Parses the given Settings and creates the appropriate {@link AfterEffect}\n     *\n     * @param settings Settings to parse\n     * @return {@link AfterEffect} referred to in the Settings\n     ",
      "vertexLabel": "AfterEffect parseAfterEffect()"
    },
    {
      "vertexName": "Method Map<String, BlobMetaData> listBlobsByPrefix(String blobNamePrefix) throws IOException  (BlobContainer.java)",
      "children": [
        {
          "name": "Method Map<String, BlobMetaData> listBlobs() throws IOException  (BlobContainer.java)"
        }
      ],
      "comment": "\n     * Lists all blobs in the container that match the specified prefix.\n     *\n     * @param   blobNamePrefix\n     *          The prefix to match against blob names in the container.\n     * @return  A map of the matching blobs in the container.  The keys in the map are the names of the blobs\n     *          and the values are {@link BlobMetaData}, containing basic information about each blob.\n     * @throws  IOException if there were any failures in reading from the blob container.\n     ",
      "vertexLabel": "Map<String, BlobMetaData> listBlobsByPrefix()"
    },
    {
      "vertexName": "Method T actionGet()  (ActionFuture.java)",
      "comment": "\n     * Similar to {@link #get()}, just catching the {@link InterruptedException} and throwing\n     * an {@link IllegalStateException} instead. Also catches\n     * {@link java.util.concurrent.ExecutionException} and throws the actual cause instead.\n     ",
      "vertexLabel": "T actionGet()"
    },
    {
      "vertexName": "Method public TopHitsAggregationBuilder storedFields(List<String> fields)  (TopHitsAggregationBuilder.java)",
      "comment": "\n     * Sets the stored fields to load and return as part of the search request.\n     * To disable the stored fields entirely (source and metadata fields) use {@code storedField(\"_none_\")}.\n     ",
      "vertexLabel": "TopHitsAggregationBuilder storedFields()"
    },
    {
      "vertexName": "Method public BulkProcessor add(IndexRequest request)  (BulkProcessor.java)",
      "comment": "\n     * Adds an {@link IndexRequest} to the list of actions to execute. Follows the same behavior of {@link IndexRequest}\n     * (for example, if no id is provided, one will be generated, or usage of the create flag).\n     ",
      "vertexLabel": "BulkProcessor add()"
    },
    {
      "vertexName": "Method final long getMinRetainedSeqNo()  (InternalEngine.java)",
      "children": [
        {
          "name": "Method synchronized long getMinRetainedSeqNo()  (SoftDeletesPolicy.java)"
        }
      ],
      "comment": "\n     * Returns the minimum seqno that is retained in the Lucene index.\n     * Operations whose seq# are at least this value should exist in the Lucene index.\n     ",
      "vertexLabel": "final long getMinRetainedSeqNo()"
    },
    {
      "vertexName": "Method DateFormatter withLocale(Locale locale)  (DateFormatter.java)",
      "children": [
        {
          "name": "Method DateFormatter withZone(ZoneId zoneId)  (DateFormatter.java)"
        }
      ],
      "comment": "\n     * Create a copy of this formatter that is configured to parse dates in the specified locale\n     *\n     * @param locale The local to use for the new formatter\n     * @return       A copy of the date formatter this has been called on\n     ",
      "vertexLabel": "DateFormatter withLocale()"
    },
    {
      "vertexName": "Method public DeleteIndexRequest(String... indices)  (DeleteIndexRequest.java)",
      "children": [
        {
          "name": "Method public DeleteIndexRequest(String index)  (DeleteIndexRequest.java)"
        }
      ],
      "comment": "\n     * Constructs a new delete index request for the specified indices.\n     *\n     * @param indices The indices to delete. Use \"_all\" to delete all indices.\n     ",
      "vertexLabel": "DeleteIndexRequest()"
    },
    {
      "vertexName": "Method ActionFuture<GetResponse> get(GetRequest request)  (Client.java)",
      "comment": "\n     * Gets the document that was indexed from an index with a type and id.\n     *\n     * @param request The get request\n     * @return The result future\n     * @see Requests#getRequest(String)\n     ",
      "vertexLabel": "ActionFuture<GetResponse> get()"
    },
    {
      "vertexName": "Class RealMultibinder  (Multibinder.java)",
      "comment": "\n     * The actual multibinder plays several roles:\n     * <p>\n     * As a Multibinder, it acts as a factory for LinkedBindingBuilders for\n     * each of the set's elements. Each binding is given an annotation that\n     * identifies it as a part of this set.\n     * <p>\n     * As a Module, it installs the binding to the set itself. As a module,\n     * this implements equals() and hashcode() in order to trick Guice into\n     * executing its configure() method only once. That makes it so that\n     * multiple multibinders can be created for the same target collection, but\n     * only one is bound. Since the list of bindings is retrieved from the\n     * injector itself (and not the multibinder), each multibinder has access to\n     * all contributions from all multibinders.\n     * <p>\n     * As a Provider, this constructs the set instances.\n     * <p>\n     * We use a subclass to hide 'implements Module, Provider' from the public\n     * API.\n     ",
      "vertexLabel": "Class RealMultibinder"
    },
    {
      "vertexName": "Method public int getSuccessful()  (ReplicationResponse.java)",
      "children": [
        {
          "name": "Method public int getTotal()  (ReplicationResponse.java)"
        }
      ],
      "comment": "\n         * @return the total number of shards the write succeeded on (replicas and primaries). This includes relocating shards, so this\n         *         number can be higher than the number of shards.\n         ",
      "vertexLabel": "int getSuccessful()"
    },
    {
      "vertexName": "Method protected Key()  (Key.java)",
      "children": [
        {
          "name": "Method protected TypeLiteral()  (TypeLiteral.java)"
        }
      ],
      "comment": "\n     * Constructs a new key. Derives the type from this class's type parameter.\n     * <p>\n     * Clients create an empty anonymous subclass. Doing so embeds the type\n     * parameter in the anonymous class's type hierarchy so we can reconstitute it\n     * at runtime despite erasure.\n     * <p>\n     * Example usage for a binding of type {@code Foo}:\n     * <p>\n     * {@code new Key<Foo>() {}}.\n     ",
      "vertexLabel": "Key()"
    },
    {
      "vertexName": "Method public CloseIndexRequest indicesOptions(IndicesOptions indicesOptions)  (CloseIndexRequest.java)",
      "children": [
        {
          "name": "Method public RestoreSnapshotRequest indicesOptions(IndicesOptions indicesOptions)  (RestoreSnapshotRequest.java)"
        }
      ],
      "comment": "\n     * Specifies what type of requested indices to ignore and how to deal wild wildcard expressions.\n     * For example indices that don't exist.\n     *\n     * @param indicesOptions the desired behaviour regarding indices to ignore and wildcard indices expressions\n     * @return the request itself\n     ",
      "vertexLabel": "CloseIndexRequest indicesOptions()"
    },
    {
      "vertexName": "Method public static void writeHistogramOrder(BucketOrder order, StreamOutput out, boolean bwcOrderFlag) throws IOException  (InternalOrder.java)",
      "children": [
        {
          "name": "Method public static void writeOrder(BucketOrder order, StreamOutput out) throws IOException  (InternalOrder.java)"
        }
      ],
      "comment": "\n         * ONLY FOR HISTOGRAM ORDER: Backwards compatibility logic to write a {@link BucketOrder} to a stream.\n         *\n         * @param order        order to write to the stream.\n         * @param out          stream to write the order to.\n         * @param bwcOrderFlag {@code true} to always {@code out.writeBoolean(true)} for the backwards compat logic before\n         *                     writing the order. {@code false} to skip this flag.\n         * @throws IOException on error writing to the stream.\n         ",
      "vertexLabel": "void writeHistogramOrder()"
    },
    {
      "vertexName": "Method QueryBuilder boost(float boost)  (QueryBuilder.java)",
      "children": [
        {
          "name": "Method public final QB boost(float boost)  (AbstractQueryBuilder.java)"
        },
        {
          "name": "Method QueryBuilder queryName(String queryName)  (QueryBuilder.java)"
        }
      ],
      "comment": "\n     * Sets the boost for this query.  Documents matching this query will (in addition to the normal\n     * weightings) have their score multiplied by the boost provided.\n     * Implementers should return the concrete type of the\n     * {@link QueryBuilder} so that calls can be chained. This is done\n     * automatically when extending {@link AbstractQueryBuilder}.\n     ",
      "vertexLabel": "QueryBuilder boost()"
    },
    {
      "vertexName": "Method public static List<T> readList(String processorType, String processorTag, Map<String, Object> configuration, String propertyName)  (ConfigurationUtils.java)",
      "children": [
        {
          "name": "Method public static List<T> readOptionalList(String processorType, String processorTag, Map<String, Object> configuration, String propertyName)  (ConfigurationUtils.java)"
        }
      ],
      "comment": "\n     * Returns and removes the specified property of type list from the specified configuration map.\n     *\n     * If the property value isn't of type list an {@link ElasticsearchParseException} is thrown.\n     * If the property is missing an {@link ElasticsearchParseException} is thrown\n     ",
      "vertexLabel": "List<T> readList()"
    },
    {
      "vertexName": "Method public SearchRequestBuilder setSearchType(String searchType)  (SearchRequestBuilder.java)",
      "children": [
        {
          "name": "Method public SearchRequest searchType(String searchType)  (SearchRequest.java)"
        }
      ],
      "comment": "\n     * The a string representation search type to execute, defaults to {@link SearchType#DEFAULT}. Can be\n     * one of \"dfs_query_then_fetch\"/\"dfsQueryThenFetch\", \"dfs_query_and_fetch\"/\"dfsQueryAndFetch\",\n     * \"query_then_fetch\"/\"queryThenFetch\", and \"query_and_fetch\"/\"queryAndFetch\".\n     ",
      "vertexLabel": "SearchRequestBuilder setSearchType()"
    },
    {
      "vertexName": "Method public final int getNumReducePhases()  (SearchResponseSections.java)",
      "children": [
        {
          "name": "Method public int getNumReducePhases()  (SearchResponse.java)"
        }
      ],
      "comment": "\n     * Returns the number of reduce phases applied to obtain this search response\n     ",
      "vertexLabel": "final int getNumReducePhases()"
    },
    {
      "vertexName": "Method public static void readFromFileChannelWithEofException(FileChannel channel, long channelPosition, byte[] dest, int destOffset, int length) throws IOException  (Channels.java)",
      "children": [
        {
          "name": "Method public static void readFromFileChannelWithEofException(FileChannel channel, long channelPosition, ByteBuffer dest) throws IOException  (Channels.java)"
        }
      ],
      "comment": "\n     * read <i>length</i> bytes from <i>position</i> of a file channel. An EOFException will be thrown if you\n     * attempt to read beyond the end of file.\n     *\n     * @param channel         channel to read from\n     * @param channelPosition position to read from\n     * @param dest            destination byte array to put data in\n     * @param destOffset      offset in dest to read into\n     * @param length          number of bytes to read\n     ",
      "vertexLabel": "void readFromFileChannelWithEofException()"
    },
    {
      "vertexName": "Method public RangeAggregationBuilder addUnboundedFrom(String key, double from)  (RangeAggregationBuilder.java)",
      "children": [
        {
          "name": "Method public DateRangeAggregationBuilder addUnboundedFrom(String key, String from)  (DateRangeAggregationBuilder.java)"
        }
      ],
      "comment": "\n     * Add a new range with no upper bound.\n     *\n     * @param key\n     *            the key to use for this range in the response\n     * @param from\n     *            the lower bound on the distances, inclusive\n     ",
      "vertexLabel": "RangeAggregationBuilder addUnboundedFrom()"
    },
    {
      "vertexName": "Method public static int geoHashLevelsForPrecision(String distance)  (GeoUtils.java)",
      "children": [
        {
          "name": "Method public static int geoHashLevelsForPrecision(double meters)  (GeoUtils.java)"
        }
      ],
      "comment": "\n     * Calculate the number of levels needed for a specific precision. GeoHash\n     * cells will not exceed the specified size (diagonal) of the precision.\n     * @param distance Maximum size of cells as unit string (must greater or equal to zero)\n     * @return levels need to achieve precision\n     ",
      "vertexLabel": "int geoHashLevelsForPrecision()"
    },
    {
      "vertexName": "Method public SearchSourceBuilder docValueField(String name)  (SearchSourceBuilder.java)",
      "children": [
        {
          "name": "Method public TopHitsAggregationBuilder docValueField(String docValueField, String format)  (TopHitsAggregationBuilder.java)"
        }
      ],
      "comment": "\n     * Adds a field to load from the doc values and return as part of the\n     * search request.\n     ",
      "vertexLabel": "SearchSourceBuilder docValueField()"
    },
    {
      "vertexName": "Method public DiscoveryNode(final String id, TransportAddress address, Version version)  (DiscoveryNode.java)",
      "comment": "\n     * Creates a new {@link DiscoveryNode}\n     * <p>\n     * <b>Note:</b> if the version of the node is unknown {@link Version#minimumCompatibilityVersion()} should be used for the current\n     * version. it corresponds to the minimum version this elasticsearch version can communicate with. If a higher version is used\n     * the node might not be able to communicate with the remote node. After initial handshakes node versions will be discovered\n     * and updated.\n     * </p>\n     *\n     * @param id               the nodes unique (persistent) node id. This constructor will auto generate a random ephemeral id.\n     * @param address          the nodes transport address\n     * @param version          the version of the node\n     ",
      "vertexLabel": "DiscoveryNode()"
    },
    {
      "vertexName": "Method void onFreeContext(SearchContext context)  (SearchOperationListener.java)",
      "comment": "\n     * Executed when a previously created search context is freed.\n     * This happens either when the search execution finishes, if the\n     * execution failed or if the search context as idle for and needs to be\n     * cleaned up.\n     * @param context the freed search context\n     ",
      "vertexLabel": "void onFreeContext()"
    },
    {
      "vertexName": "Method public CreateSnapshotRequest indices(List<String> indices)  (CreateSnapshotRequest.java)",
      "children": [
        {
          "name": "Method public CreateSnapshotRequest indices(String... indices)  (CreateSnapshotRequest.java)"
        }
      ],
      "comment": "\n     * Sets a list of indices that should be included into the snapshot\n     * <p>\n     * The list of indices supports multi-index syntax. For example: \"+test*\" ,\"-test42\" will index all indices with\n     * prefix \"test\" except index \"test42\". Aliases are supported. An empty list or {\"_all\"} will snapshot all open\n     * indices in the cluster.\n     *\n     * @return this request\n     ",
      "vertexLabel": "CreateSnapshotRequest indices()"
    },
    {
      "vertexName": "Method public static TermsQueryBuilder termsQuery(String name, int... values)  (QueryBuilders.java)",
      "children": [
        {
          "name": "Method public static TermsQueryBuilder termsQuery(String name, String... values)  (QueryBuilders.java)"
        }
      ],
      "comment": "\n     * A filer for a field based on several terms matching on any of them.\n     *\n     * @param name   The field name\n     * @param values The terms\n     ",
      "vertexLabel": "TermsQueryBuilder termsQuery()"
    },
    {
      "vertexName": "Class QueryProfileShardResult  (QueryProfileShardResult.java)",
      "children": [
        {
          "name": "Class AggregationProfileShardResult  (AggregationProfileShardResult.java)"
        }
      ],
      "comment": "\n * A container class to hold the profile results for a single shard in the request.\n * Contains a list of query profiles, a collector tree and a total rewrite tree.\n ",
      "vertexLabel": "Class QueryProfileShardResult"
    },
    {
      "vertexName": "Method public PolygonBuilder hole(LineStringBuilder hole, boolean coerce)  (PolygonBuilder.java)",
      "children": [
        {
          "name": "Method public PolygonBuilder hole(LineStringBuilder hole)  (PolygonBuilder.java)"
        }
      ],
      "comment": "\n     * Add a new hole to the polygon\n     * @param hole linear ring defining the hole\n     * @param coerce if set to true, it will try to close the hole by adding starting point as end point\n     * @return this\n     ",
      "vertexLabel": "PolygonBuilder hole()"
    }
  ]
}
